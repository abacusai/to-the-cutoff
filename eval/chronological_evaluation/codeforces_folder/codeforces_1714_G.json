[
    {
        "name": "Path Prefixes",
        "description": "You are given a rooted tree. It contains \n    n\n vertices, which are numbered\nfrom \n    1\n to \n    n\n. The root is the vertex \n    1\n. Each edge has two\npositive integer values. Thus, two positive integers \n    a_j\n and \n    b_j\n\nare given for each edge. Output \n    n-1\n numbers \n    r_2, r_3, \n    \u2026,\n    r_n\n, where \n    r_i\n is defined as follows. Consider the path from the root\n(vertex \n    1\n) to \n    i\n (\n    2 \n    \u2264 i \n    \u2264 n\n). Let the sum of the\ncosts of \n    a_j\n along this path be \n    A_i\n. Then \n    r_i\n is equal to\nthe length of the maximum prefix of this path such that the sum of \n    b_j\n\nalong this prefix does not exceed \n    A_i\n. Example for \n    n=9\n. The blue\ncolor shows the costs of \n    a_j\n, and the red color shows the costs of\n\n    b_j\n. Consider an example. In this case: \n    r_2=0\n, since the path to\n\n    2\n has an amount of \n    a_j\n equal to \n    5\n, only the prefix of this\npath of length \n    0\n has a smaller or equal amount of \n    b_j\n;\n\n    r_3=3\n, since the path to \n    3\n has an amount of \n    a_j\n equal to\n\n    5+9+5=19\n, the prefix of length \n    3\n of this path has a sum of\n\n    b_j\n equal to \n    6+10+1=17\n ( the number is \n    17 \n    \u2264 19\n);\n\n    r_4=1\n, since the path to \n    4\n has an amount of \n    a_j\n equal to\n\n    5+9=14\n, the prefix of length \n    1\n of this path has an amount of\n\n    b_j\n equal to \n    6\n (this is the longest suitable prefix, since the\nprefix of length \n    2\n already has an amount of \n    b_j\n equal to\n\n    6+10=16\n, which is more than \n    14\n); \n    r_5=2\n, since the path to\n\n    5\n has an amount of \n    a_j\n equal to \n    5+9+2=16\n, the prefix of\nlength \n    2\n of this path has a sum of \n    b_j\n equal to \n    6+10=16\n\n(this is the longest suitable prefix, since the prefix of length \n    3\n\nalready has an amount of \n    b_j\n equal to \n    6+10+1=17\n, what is more than\n\n    16\n); \n    r_6=1\n, since the path up to \n    6\n has an amount of\n\n    a_j\n equal to \n    2\n, the prefix of length \n    1\n of this path has an\namount of \n    b_j\n equal to \n    1\n; \n    r_7=1\n, since the path to \n    7\n\nhas an amount of \n    a_j\n equal to \n    5+3=8\n, the prefix of length \n    1\n\nof this path has an amount of \n    b_j\n equal to \n    6\n (this is the longest\nsuitable prefix, since the prefix of length \n    2\n already has an amount of\n\n    b_j\n equal to \n    6+3=9\n, which is more than \n    8\n); \n    r_8=2\n,\nsince the path up to \n    8\n has an amount of \n    a_j\n equal to \n    2+4=6\n,\nthe prefix of length \n    2\n of this path has an amount of \n    b_j\n equal to\n\n    1+3=4\n; \n    r_9=3\n, since the path to \n    9\n has an amount of \n    a_j\n\nequal to \n    2+4+1=7\n, the prefix of length \n    3\n of this path has a sum of\n\n    b_j\n equal to \n    1+3+3=7\n. Input The first line contains an integer\n\n    t\n (\n    1 \n    \u2264 t \n    \u2264 10^4\n) \u2014 the number of test cases in the test.\nThe descriptions of test cases follow. Each description begins with a line\nthat contains an integer \n    n\n (\n    2 \n    \u2264 n \n    \u2264 2\n    \u00b710^5\n) \u2014 the\nnumber of vertices in the tree. This is followed by \n    n-1\n string, each of\nwhich contains three numbers \n    p_j, a_j, b_j\n (\n    1 \n    \u2264 p_j \n    \u2264 n\n;\n\n    1 \n    \u2264 a_j,b_j \n    \u2264 10^9\n) \u2014 the ancestor of the vertex \n    j\n, the\nfirst and second values an edge that leads from \n    p_j\n to \n    j\n. The\nvalue of \n    j\n runs through all values from \n    2\n to \n    n\n inclusive. It\nis guaranteed that each set of input data has a correct hanged tree with a\nroot at the vertex \n    1\n. It is guaranteed that the sum of \n    n\n over all\ninput test cases does not exceed \n    2\n    \u00b710^5\n. Output For each test\ncase, output \n    n-1\n integer in one line: \n    r_2, r_3, \n    \u2026, r_n\n.\nExample Input 4 9 1 5 6 4 5 1 2 9 10 4 2 1 1 2 1 2 3 3 6 4 3 8 1 3 4 1 1 100 2\n1 1 3 101 1 4 1 100 1 2 1 1 3 1 101 10 1 1 4 2 3 5 2 5 1 3 4 3 3 1 5 5 3 5 5 2\n1 1 3 2 6 2 1 Output 0 3 1 2 1 1 2 3 0 0 3 1 2 2 0 1 2 1 1 2 2 1 1 Note The\nfirst example is clarified in the statement. In the second example:\n\n    r_2=0\n, since the path to \n    2\n has an amount of \n    a_j\n equal to\n\n    1\n, only the prefix of this path of length \n    0\n has a smaller or equal\namount of \n    b_j\n; \n    r_3=0\n, since the path to \n    3\n has an amount of\n\n    a_j\n equal to \n    1+1=2\n, the prefix of length \n    1\n of this path has\nan amount of \n    b_j\n equal to \n    100\n (\n    100 > 2\n); \n    r_4=3\n, since\nthe path to \n    4\n has an amount of \n    a_j\n equal to \n    1+1+101=103\n, the\nprefix of length \n    3\n of this path has an amount of \n    b_j\n equal to\n\n    102\n, .\n\n",
        "cf_contest_id": 1714,
        "cf_index": "G",
        "cf_rating": 1700,
        "difficulty": 0,
        "cf_tags": [
            "binary search",
            "data structures",
            "dfs and similar",
            "trees"
        ],
        "time_limit_seconds": 3.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "4\r\n9\r\n1 5 6\r\n4 5 1\r\n2 9 10\r\n4 2 1\r\n1 2 1\r\n2 3 3\r\n6 4 3\r\n8 1 3\r\n4\r\n1 1 100\r\n2 1 1\r\n3 101 1\r\n4\r\n1 100 1\r\n2 1 1\r\n3 1 101\r\n10\r\n1 1 4\r\n2 3 5\r\n2 5 1\r\n3 4 3\r\n3 1 5\r\n5 3 5\r\n5 2 1\r\n1 3 2\r\n6 2 1\r\n",
                "0 3 1 2 1 1 2 3\r\n0 0 3\r\n1 2 2\r\n0 1 2 1 1 2 2 1 1\r\n"
            ]
        ],
        "private_cases": []
    }
]