[
    {
        "name": "Prefix Flip (Hard Version)",
        "description": "This is the hard version of the problem. The difference between the versions\nis the constraint on \n    n\n and the required number of operations. You can\nmake hacks only if all versions of the problem are solved. There are two\nbinary strings \n    a\n and \n    b\n of length \n    n\n (a binary string is a\nstring consisting of symbols \n    0\n and \n    1\n). In an operation, you select\na prefix of \n    a\n, and simultaneously invert the bits in the prefix (\n    0\n\nchanges to \n    1\n and \n    1\n changes to \n    0\n) and reverse the order of\nthe bits in the prefix. For example, if \n    a=001011\n and you select the\nprefix of length \n    3\n, it becomes \n    011011\n. Then if you select the\nentire string, it becomes \n    001001\n. Your task is to transform the string\n\n    a\n into \n    b\n in at most \n    2n\n operations. It can be proved that it\nis always possible. Input The first line contains a single integer \n    t\n\n(\n    1\n    \u2264 t\n    \u2264 1000\n) \u2014 the number of test cases. Next \n    3t\n lines\ncontain descriptions of test cases. The first line of each test case contains\na single integer \n    n\n (\n    1\n    \u2264 n\n    \u2264 10^5\n) \u2014 the length of the binary\nstrings. The next two lines contain two binary strings \n    a\n and \n    b\n of\nlength \n    n\n. It is guaranteed that the sum of \n    n\n across all test cases\ndoes not exceed \n    10^5\n. Output For each test case, output an integer\n\n    k\n (\n    0\n    \u2264 k\n    \u2264 2n\n), followed by \n    k\n integers\n\n    p_1,\n    \u2026,p_k\n (\n    1\n    \u2264 p_i\n    \u2264 n\n). Here \n    k\n is the number\nof operations you use and \n    p_i\n is the length of the prefix you flip in\nthe \n    i\n-th operation. Example Input 5 2 01 10 5 01011 11100 2 01 01 10\n0110011011 1000110100 1 0 1 Output 3 1 2 1 6 5 2 5 3 1 2 0 9 4 1 2 10 4 1 2 1\n5 1 1 Note In the first test case, we have \n    01\n    \u2192 11\n    \u2192 00\n    \u2192 10\n.\nIn the second test case, we have \n    01011\n    \u2192 00101\n    \u2192 11101\n    \u2192\n    01000\n    \u2192 10100\n    \u2192 00100\n    \u2192 11100\n. In the third test case, the strings\nare already the same. Another solution is to flip the prefix of length\n\n    2\n, which will leave \n    a\n unchanged.\n\n",
        "cf_contest_id": 1381,
        "cf_index": "A2",
        "cf_rating": 1700,
        "difficulty": 0,
        "cf_tags": [
            "constructive algorithms",
            "data structures",
            "implementation",
            "strings",
            "two pointers"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "5\r\n2\r\n01\r\n10\r\n5\r\n01011\r\n11100\r\n2\r\n01\r\n01\r\n10\r\n0110011011\r\n1000110100\r\n1\r\n0\r\n1\r\n",
                "3 1 2 1\r\n5 1 2 3 5 3\r\n4 1 2 2 1\r\n11 1 3 5 7 8 10 8 7 6 4 1\r\n1 1\r\n"
            ]
        ],
        "private_cases": []
    }
]