[
    {
        "name": "String Similarity",
        "description": "A binary string is a string where each character is either 0 or 1. Two binary\nstrings \n    a\n and \n    b\n of equal length are similar, if they have the same\ncharacter in some position (there exists an integer \n    i\n such that \n    a_i =\n    b_i\n). For example: 10010 and 01111 are similar (they have the same\ncharacter in position \n    4\n); 10010 and 11111 are similar; 111 and 111 are\nsimilar; 0110 and 1001 are not similar. You are given an integer \n    n\n and a\nbinary string \n    s\n consisting of \n    2n-1\n characters. Let's denote\n\n    s[l..r]\n as the contiguous substring of \n    s\n starting with \n    l\n-th\ncharacter and ending with \n    r\n-th character (in other words, \n    s[l..r] =\n    s_l s_l + 1 s_l + 2\n    \u2026 s_r\n). You have to construct a binary string\n\n    w\n of length \n    n\n which is similar to all of the following strings:\n\n    s[1..n]\n, \n    s[2..n+1]\n, \n    s[3..n+2]\n, ..., \n    s[n..2n-1]\n. Input\nThe first line contains a single integer \n    t\n (\n    1 \n    \u2264 t \n    \u2264 1000\n)\n\u2014 the number of test cases. The first line of each test case contains a single\ninteger \n    n\n (\n    1 \n    \u2264 n \n    \u2264 50\n). The second line of each test case\ncontains the binary string \n    s\n of length \n    2n - 1\n. Each character\n\n    s_i\n is either 0 or 1. Output For each test case, print the corresponding\nbinary string \n    w\n of length \n    n\n. If there are multiple such strings \u2014\nprint any of them. It can be shown that at least one string \n    w\n meeting\nthe constraints always exists. Example Input 4 1 1 3 00000 4 1110000 2 101\nOutput 1 000 1010 00 Note The explanation of the sample case (equal characters\nin equal positions are bold): The first test case: \n    1\n is\nsimilar to \n    s[1..1] = \n    1\n. The second test case:\n\n    000\n is similar to \n    s[1..3] = \n    000\n;\n\n    000\n is similar to \n    s[2..4] = \n    000\n;\n\n    000\n is similar to \n    s[3..5] = \n    000\n. The third\ntest case: \n    10\n    10\n is similar to \n    s[1..4] =\n    \n    11\n    10\n; \n    101\n    0\n is similar to\n\n    s[2..5] = \n    110\n    0\n; \n    101\n    0\n\nis similar to \n    s[3..6] = \n    100\n    0\n;\n\n    1\n    01\n    0\n is similar to \n    s[4..7] =\n    0\n    00\n    0\n. The fourth test case: \n    0\n    0\n is\nsimilar to \n    s[1..2] = 1\n    0\n; \n    00\n is similar to\n\n    s[2..3] = \n    01\n.\n\n",
        "cf_contest_id": 1400,
        "cf_index": "A",
        "cf_rating": 800,
        "difficulty": 0,
        "cf_tags": [
            "constructive algorithms",
            "strings"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "4\r\n1\r\n1\r\n3\r\n00000\r\n4\r\n1110000\r\n2\r\n101\r\n",
                "1\r\n000\r\n1100\r\n11\r\n"
            ]
        ],
        "private_cases": [
            [
                "1\r\n7\r\n0000000000001\r\n",
                "0000001\r\n"
            ]
        ]
    }
]