[
    {
        "name": "Sum Graph",
        "description": "This is an interactive problem. There is a hidden permutation \n    p_1, p_2,\n    \n    \u2026, p_n\n. Consider an undirected graph with \n    n\n nodes only with no\nedges. You can make two types of queries: Specify an integer \n    x\n\nsatisfying \n    2 \n    \u2264 x \n    \u2264 2n\n. For all integers \n    i\n (\n    1 \n    \u2264 i\n    \n    \u2264 n\n) such that \n    1 \n    \u2264 x-i \n    \u2264 n\n, an edge between node \n    i\n\nand node \n    x-i\n will be added. Query the number of edges in the shortest\npath between node \n    p_i\n and node \n    p_j\n. As the answer to this question\nyou will get the number of edges in the shortest path if such a path exists,\nor \n    -1\n if there is no such path. Note that you can make both types of\nqueries in any order. Within \n    2n\n queries (including type \n    1\n and type\n\n    2\n), guess two possible permutations, at least one of which is \n    p_1,\n    p_2, \n    \u2026, p_n\n. You get accepted if at least one of the permutations is\ncorrect. You are allowed to guess the same permutation twice. A permutation of\nlength \n    n\n is an array consisting of \n    n\n distinct integers from\n\n    1\n to \n    n\n in arbitrary order. For example, \n    [2,3,1,5,4]\n is a\npermutation, but \n    [1,2,2]\n is not a permutation (\n    2\n appears twice in\nthe array), and \n    [1,3,4]\n is also not a permutation (\n    n=3\n but there\nis \n    4\n in the array). Input Each test contains multiple test cases. The\nfirst line contains a single integer \n    t\n (\n    1 \n    \u2264 t \n    \u2264 100\n) \u2014 the\nnumber of test cases. The first line of each test case contains a single\ninteger \n    n\n (\n    2 \n    \u2264 n \n    \u2264 10^3\n) \u2014 the length of the permutation.\nIt is guaranteed that the sum of \n    n\n over all test cases does not exceed\n\n    10^3\n. Interaction The interaction for each test case begins by reading\nthe integer \n    n\n. Then, make at most \n    2n\n queries: If you want to make\na type \n    1\n query, output \"+ x\". \n    x\n must be an integer between \n    2\n\nand \n    2n\n inclusive. After doing that read \n    1\n or \n    -2\n. If you read\n\n    1\n your query was valid, otherwise it was invalid or you exceed the limit\nof queries, and your program must terminate immediately to receive a Wrong\nAnswer verdict. If you want to make a type \n    2\n query, output \"? i j\".\n\n    i\n and \n    j\n must be integers between \n    1\n and \n    n\n inclusive.\nAfter that, read in a single integer \n    r\n (\n    -1 \n    \u2264 r \n    \u2264 n\n) \u2014 the\nanswer to your query. If you receive the integer \n    \u22122\n instead of an\nanswer, it means your program has made an invalid query, or has exceeded the\nlimit of queries. Your program must terminate immediately to receive a Wrong\nAnswer verdict. At any point of the interaction, if you want to guess two\npermutations, output \"! \n    p_1,1\n \n    p_1,2\n \n    \u2026\n\n\n    p_1,n\n \n    p_2,1\n \n    p_2,2\n \n    \u2026\n \n    p_2,n\n\". Note\nthat you should output the two permutations on the same line, and no\nexclamation mark is needed to separate the two permutations. After doing that\nread \n    1\n or \n    -2\n. If you read \n    1\n your answer was correct,\notherwise it was incorrect and your program must terminate immediately to\nreceive a Wrong Answer verdict. After that, move on to the next test case, or\nterminate the program if there are none. Note that reporting the answer does\nnot count as a query. Note that even if you output a correct permutation, the\nsecond permutation should be a permutation and not an arbitrary array. At any\npoint, if you continue interaction after reading in the integer \n    -2\n, you\ncan get an arbitrary verdict because your solution will continue to read from\na closed stream. After printing a query or the answer do not forget to output\nthe end of line and flush the output. Otherwise, you will get Idleness limit\nexceeded. To do this, use: fflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java; flush(output) in Pascal; stdout.flush() in Python;\nsee the documentation for other languages.Interactor is non-adaptive. This\nmeans that all permutations are fixed before the interaction starts. Hacks To\nmake a hack, use the following format. The first line should contain a single\ninteger \n    t\n (\n    1 \n    \u2264 t \n    \u2264 100\n) \u2014 the number of test cases. The\nfirst line of each test case should contain a single integer \n    n\n (\n    2\n    \n    \u2264 n \n    \u2264 10^3\n) \u2014 the length of the permutation. The second line of\neach test case should contain \n    n\n distinct integers \n    p_1, p_2, \n    \u2026,\n    p_n\n (\n    1 \n    \u2264 p_i \n    \u2264 n\n) \u2014 the hidden permutation. The sum of\n\n    n\n over all test cases should not exceed \n    10^3\n. Example Input 2 6 1\n1 1 1 1 2 -1 1 2 1 Output  12  2  3 ? 1 3  5 ? 1 5 ? 4 5 ! 1 4 2 5 3 6\n1 2 3 4 5 6 ! 1 2 2 1 Note In the first test case, \n    n=6\n and the hidden\npermutation \n    p = [1,4,2,5,3,6]\n. Firstly, make a type \n    1\n query on\n\n    x=12, 2, 3\n respectively. This adds four edges to the graph in total: An\nedge that connects node \n    6\n and node \n    6\n. An edge that connects node\n\n    1\n and node \n    1\n. An edge that connects node \n    1\n and node \n    2\n.\nAn edge that connects node \n    2\n and node \n    1\n. Since all of these\nqueries are valid, the interactor returns \n    1\n after each of them. Then,\nquery the number of edges in the shortest path between node \n    p_1 = 1\n and\n\n    p_3 = 2\n, which is equal to \n    1\n. Then, make a type \n    1\n query on\n\n    x=5\n. This adds four edges to the graph in total: An edge that connects\nnode \n    1\n and node \n    4\n. An edge that connects node \n    2\n and node\n\n    3\n. An edge that connects node \n    3\n and node \n    2\n. An edge that\nconnects node \n    4\n and node \n    1\n. Since this query is valid, the\ninteractor returns \n    1\n. Then, query the number of edges in the shortest\npath between node \n    p_1 = 1\n and \n    p_5 = 3\n, which is equal to \n    2\n.\nThen, query the number of edges in the shortest path between node \n    p_4 =\n    5\n and \n    p_5 = 3\n. Such a path doesn't exist, therefore the interactor\nreturns \n    -1\n. Afterwards, due to some magic, two possible permutations\nthat can be \n    p\n are determined: the first permutation is\n\n    [1,4,2,5,3,6]\n and the second permutation is \n    [1,2,3,4,5,6]\n. Since\nthe first permutation is equal to the hidden permutation, this test case is\nsolved correctly. In total, \n    7\n queries are used, which is within the\nlimit of \n    2 \n    \u00b7 6 = 12\n queries. Since the answer is correct, the\ninteractor returns \n    1\n. In the second test case, \n    n=2\n and the hidden\npermutation is \n    p = [2,1]\n. Since there are only \n    2! = 2\n possible\npermutations, no queries are needed. It is sufficient to just output the two\npermutations, \n    [1,2]\n and \n    [2,1]\n. In total, \n    0\n queries are used,\nwhich is within the limit of \n    2 \n    \u00b7 2 = 4\n queries. Since the answer\nis correct, the interactor returns \n    1\n.\n\n",
        "cf_contest_id": 1815,
        "cf_index": "B",
        "cf_rating": 2000,
        "difficulty": 0,
        "cf_tags": [
            "brute force",
            "constructive algorithms",
            "graphs",
            "implementation",
            "interactive",
            "shortest paths",
            "trees"
        ],
        "time_limit_seconds": 3.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "2\r\n6\r\n1 4 2 5 3 6\r\n2\r\n1 2\r\n",
                "12\r\n4\r\n"
            ]
        ],
        "private_cases": []
    }
]