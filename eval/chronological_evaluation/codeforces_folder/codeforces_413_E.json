[
    {
        "name": "Maze 2D",
        "description": "The last product of the R2 company in the 2D games' field is a new\nrevolutionary algorithm of searching for the shortest path in a 2 \u00d7 n maze.\nImagine a maze that looks like a 2 \u00d7 n rectangle, divided into unit squares.\nEach unit square is either an empty cell or an obstacle. In one unit of time,\na person can move from an empty cell of the maze to any side-adjacent empty\ncell. The shortest path problem is formulated as follows. Given two free maze\ncells, you need to determine the minimum time required to go from one cell to\nthe other. Unfortunately, the developed algorithm works well for only one\nrequest for finding the shortest path, in practice such requests occur quite\noften. You, as the chief R2 programmer, are commissioned to optimize the\nalgorithm to find the shortest path. Write a program that will effectively\nrespond to multiple requests to find the shortest path in a 2 \u00d7 n maze. Input\nThe first line contains two integers, n and m (1 \u2264 n \u2264 2\u00b710^5; 1 \u2264 m \u2264 2\u00b710^5)\n\u2014 the width of the maze and the number of queries, correspondingly. Next two\nlines contain the maze. Each line contains n characters, each character equals\neither '.' (empty cell), or 'X' (obstacle). Each of the next m lines contains\ntwo integers vi and ui (1 \u2264 vi, ui \u2264 2n) \u2014 the description of the i-th\nrequest. Numbers vi, ui mean that you need to print the value of the shortest\npath from the cell of the maze number vi to the cell number ui. We assume that\nthe cells of the first line of the maze are numbered from 1 to n, from left to\nright, and the cells of the second line are numbered from n + 1 to 2n from\nleft to right. It is guaranteed that both given cells are empty. Output Print\nm lines. In the i-th line print the answer to the i-th request \u2014 either the\nsize of the shortest path or -1, if we can't reach the second cell from the\nfirst one. Examples Input 4 7 .X.. ...X 5 1 1 3 7 7 1 4 6 1 4 7 5 7 Output 1 4\n0 5 2 2 2 Input 10 3 X...X..X.. ..X...X..X 11 7 7 18 18 10 Output 9 -1 3\n\n",
        "cf_contest_id": 413,
        "cf_index": "E",
        "cf_rating": 2200,
        "difficulty": 0,
        "cf_tags": [
            "data structures",
            "divide and conquer"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "4 7\r\n.X..\r\n...X\r\n5 1\r\n1 3\r\n7 7\r\n1 4\r\n6 1\r\n4 7\r\n5 7\r\n",
                "1\r\n4\r\n0\r\n5\r\n2\r\n2\r\n2\r\n"
            ],
            [
                "10 3\r\nX...X..X..\r\n..X...X..X\r\n11 7\r\n7 18\r\n18 10\r\n",
                "9\r\n-1\r\n3\r\n"
            ]
        ],
        "private_cases": [
            [
                "1 1\r\n.\r\n.\r\n1 2\r\n",
                "1\r\n"
            ],
            [
                "2 1\r\n..\r\n.X\r\n1 2\r\n",
                "1\r\n"
            ],
            [
                "2 1\r\n..\r\nX.\r\n1 2\r\n",
                "1\r\n"
            ],
            [
                "2 1\r\n..\r\nX.\r\n1 4\r\n",
                "2\r\n"
            ],
            [
                "2 1\r\n.X\r\n..\r\n1 4\r\n",
                "2\r\n"
            ],
            [
                "2 1\r\nX.\r\n..\r\n2 3\r\n",
                "2\r\n"
            ],
            [
                "2 1\r\n..\r\n.X\r\n3 2\r\n",
                "2\r\n"
            ]
        ]
    }
]