[
    {
        "name": "Tree Generator\u2122",
        "description": "Owl Pacino has always been into trees \u2014 unweighted rooted trees in particular.\nHe loves determining the diameter of every tree he sees \u2014 that is, the maximum\nlength of any simple path in the tree. Owl Pacino's owl friends decided to\npresent him the Tree Generator\u2122 \u2014 a powerful machine creating rooted trees\nfrom their descriptions. An \n    n\n-vertex rooted tree can be described by a\nbracket sequence of length \n    2(n - 1)\n in the following way: find any walk\nstarting and finishing in the root that traverses each edge exactly twice \u2014\nonce down the tree, and later up the tree. Then follow the path and write down\n\"(\" (an opening parenthesis) if an edge is followed down the tree, and \")\" (a\nclosing parenthesis) otherwise. The following figure shows sample rooted trees\nand their descriptions: Owl wrote down the description of an \n    n\n-vertex\nrooted tree. Then, he rewrote the description \n    q\n times. However, each\ntime he wrote a new description, he picked two different characters in the\ndescription he wrote the last time, swapped them and wrote down the resulting\nstring. He always made sure that each written string was the description of a\nrooted tree. Pacino then used Tree Generator\u2122 for each description he wrote\ndown. What is the diameter of each constructed tree? Input The first line of\nthe input contains two integers \n    n, q\n (\n    3 \n    \u2264 n \n    \u2264 100\n     000\n,\n\n    1 \n    \u2264 q \n    \u2264 100\n     000\n) \u2014 the number of vertices in the tree and the\nnumber of changes to the tree description. The following line contains a\ndescription of the initial tree \u2014 a string of length \n    2(n-1)\n consisting\nof opening and closing parentheses. Each of the following \n    q\n lines\ndescribes a single change to the description and contains two space-separated\nintegers \n    a_i, b_i\n (\n    2 \n    \u2264 a_i, b_i \n    \u2264 2n-3\n) which identify\nthe indices of two brackets to be swapped. You can assume that the description\nwill change after each query, and that after each change a tree can be\nconstructed from the description. Output Output \n    q + 1\n integers \u2014 the\ndiameter of each constructed tree, in the order their descriptions have been\nwritten down. Examples Input 5 5 (((()))) 4 5 3 4 5 6 3 6 2 5 Output 4 3 3 2 4\n4 Input 6 4 (((())())) 6 7 5 4 6 4 7 4 Output 4 4 4 5 3 Note The following\nfigure shows each constructed tree and its description in the first example\ntest:\n\n",
        "cf_contest_id": 1149,
        "cf_index": "C",
        "cf_rating": 2700,
        "difficulty": 0,
        "cf_tags": [
            "data structures",
            "implementation",
            "trees"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "5 5\r\n(((())))\r\n4 5\r\n3 4\r\n5 6\r\n3 6\r\n2 5\r\n",
                "4\r\n3\r\n3\r\n2\r\n4\r\n4\r\n"
            ],
            [
                "6 4\r\n(((())()))\r\n6 7\r\n5 4\r\n6 4\r\n7 4\r\n",
                "4\r\n4\r\n4\r\n5\r\n3\r\n"
            ]
        ],
        "private_cases": [
            [
                "3 5\r\n()()\r\n2 3\r\n3 2\r\n2 3\r\n3 2\r\n3 2\r\n",
                "2\r\n2\r\n2\r\n2\r\n2\r\n2\r\n"
            ],
            [
                "57 1\r\n()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()\r\n65 54\r\n",
                "2\r\n4\r\n"
            ]
        ]
    }
]