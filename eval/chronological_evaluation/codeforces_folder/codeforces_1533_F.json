[
    {
        "name": "Binary String Partition",
        "description": "Let's call a string \n    t\n consisting of characters 0 and/or 1 beautiful, if\neither the number of occurrences of character 0 in this string does not exceed\n\n    k\n, or the number of occurrences of characters 1 in this string does not\nexceed \n    k\n (or both). For example, if \n    k = 3\n, the strings 101010,\n111, 0, 00000, 1111111000 are beautiful, and the strings 1111110000, 01010101\nare not beautiful. You are given a string \n    s\n. You have to divide it into\nthe minimum possible number of beautiful strings, i. e., find a sequence of\nstrings \n    t_1, t_2, \n    \u2026, t_m\n such that every \n    t_i\n is beautiful,\n\n    t_1 + t_2 + \n    \u2026 + t_m = s\n (where \n    +\n is the concatenation\noperator), and \n    m\n is minimum possible. For every \n    k\n from \n    1\n to\n\n    |s|\n, find the minimum possible number of strings such that \n    s\n can\nbe divided into them (i. e. the minimum possible \n    m\n in the partition).\nInput The only line contains one string \n    s\n (\n    1 \n    \u2264 |s| \n    \u2264 2\n    \n    \u00b7 10^5\n). Each character of \n    s\n is either 0 or 1. Output Print\n\n    |s|\n integers. The \n    i\n-th integer should be equal to the minimum\nnumber of strings in the partition of \n    s\n, when \n    k = i\n. Examples\nInput 00100010 Output 2 1 1 1 1 1 1 1 Input 1001011100 Output 3 2 2 2 1 1 1 1\n1 1\n\n",
        "cf_contest_id": 1533,
        "cf_index": "F",
        "cf_rating": 0,
        "difficulty": 0,
        "cf_tags": [
            "*special",
            "binary search",
            "greedy"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "00100010\r\n",
                "2 1 1 1 1 1 1 1\r\n"
            ],
            [
                "1001011100\r\n",
                "3 2 2 2 1 1 1 1 1 1\r\n"
            ]
        ],
        "private_cases": [
            [
                "0\r\n",
                "1\r\n"
            ],
            [
                "0110100101110110100110000\r\n",
                "7 4 3 3 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n"
            ],
            [
                "1011110000111101111111101011001111111101111000011110110101110011011000101100000010101011010101110001\r\n",
                "21 15 11 9 7 6 5 5 4 4 4 4 3 3 3 3 3 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n"
            ]
        ]
    }
]