[
    {
        "name": "Guessing the Greatest (easy version)",
        "description": "The only difference between the easy and the hard version is the limit to the\nnumber of queries. This is an interactive problem. There is an array \n    a\n\nof \n    n\n different numbers. In one query you can ask the position of the\nsecond maximum element in a subsegment \n    a[l..r]\n. Find the position of the\nmaximum element in the array in no more than 40 queries. A subsegment\n\n    a[l..r]\n is all the elements \n    a_l, a_l + 1, ..., a_r\n. After asking\nthis subsegment you will be given the position of the second maximum from this\nsubsegment in the whole array. Input The first line contains a single integer\n\n    n\n \n    (2 \n    \u2264 n \n    \u2264 10^5)\n \u2014 the number of elements in the array.\nInteraction You can ask queries by printing \"? \n    l\n \n    r\n\" \n    (1 \n    \u2264 l\n    < r \n    \u2264 n)\n. The answer is the index of the second maximum of all\nelements \n    a_l, a_l + 1, \n    \u2026, a_r\n. Array \n    a\n is fixed\nbeforehand and can't be changed in time of interaction. You can output the\nanswer by printing \"! \n    p\n\", where \n    p\n is the index of the maximum\nelement in the array. You can ask no more than 40 queries. Printing the answer\ndoesn't count as a query. After printing a query do not forget to output end\nof line and flush the output. Otherwise, you will get Idleness limit exceeded.\nTo do this, use: fflush(stdout) or cout.flush() in C++; System.out.flush() in\nJava; flush(output) in Pascal; stdout.flush() in Python; see documentation for\nother languages Hacks To make a hack, use the following test format. In the\nfirst line output a single integer \n    n\n \n    (2 \n    \u2264 n \n    \u2264 10^5)\n. In\nthe second line output a permutation of \n    n\n integers \n    1\n to \n    n\n.\nThe position of \n    n\n in the permutation is the position of the maximum\nExample Input 5 3 4 Output ? 1 5 ? 4 5 ! 1 Note In the sample suppose \n    a\n\nis \n    [5, 1, 4, 2, 3]\n. So after asking the \n    [1..5]\n subsegment \n    4\n\nis second to max value, and it's position is \n    3\n. After asking the\n\n    [4..5]\n subsegment \n    2\n is second to max value and it's position in\nthe whole array is \n    4\n. Note that there are other arrays \n    a\n that\nwould produce the same interaction, and the answer for them might be\ndifferent. Example output is given in purpose of understanding the\ninteraction.\n\n",
        "cf_contest_id": 1486,
        "cf_index": "C1",
        "cf_rating": 1600,
        "difficulty": 0,
        "cf_tags": [
            "binary search",
            "interactive"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "5\r\n5 1 4 2 3\r\n",
                "3\r\n"
            ]
        ],
        "private_cases": [
            [
                "2\r\n1 2\r\n",
                "1\r\n"
            ],
            [
                "10\r\n5 1 6 2 8 3 4 10 9 7\r\n",
                "4\r\n"
            ],
            [
                "100\r\n98 52 63 2 18 96 31 58 84 40 41 45 66 100 46 71 26 48 81 20 73 91 68 76 13 93 17 29 64 95 79 21 55 75 19 85 54 51 89 78 15 87 43 59 36 1 90 35 65 56 62 28 86 5 82 49 3 99 33 9 92 32 74 69 27 22 77 16 44 94 34 6 57 70 23 12 61 25 8 11 67 47 83 88 10 14 30 7 97 60 42 37 24 38 53 50 4 80 72 39\r\n",
                "8\r\n"
            ]
        ]
    }
]