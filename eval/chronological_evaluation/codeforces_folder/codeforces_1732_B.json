[
    {
        "name": "Ugu",
        "description": "A binary string is a string consisting only of the characters 0 and 1. You are\ngiven a binary string \n    s_1 s_2 \n    \u2026 s_n\n. It is necessary to make this\nstring non-decreasing in the least number of operations. In other words, each\ncharacter should be not less than the previous. In one operation, you can do\nthe following: Select an arbitrary index \n    1 \n    \u2264 i \n    \u2264 n\n in the\nstring; For all \n    j \n    \u2265 i\n, change the value in the \n    j\n-th position\nto the opposite, that is, if \n    s_j = 1\n, then make \n    s_j = 0\n, and vice\nversa.What is the minimum number of operations needed to make the string non-\ndecreasing? Input Each test consists of multiple test cases. The first line\ncontains an integer \n    t\n (\n    1 \n    \u2264 t \n    \u2264 10^4\n) \u2014 the number of\ntest cases. The description of test cases follows. The first line of each test\ncases a single integer \n    n\n (\n    1 \n    \u2264 n \n    \u2264 10^5\n) \u2014 the length of\nthe string. The second line of each test case contains a binary string \n    s\n\nof length \n    n\n. It is guaranteed that the sum of \n    n\n over all test\ncases does not exceed \n    2 \n    \u00b7 10^5\n. Output For each test case, output\na single integer \u2014 the minimum number of operations that are needed to make\nthe string non-decreasing. Example Input 8 1 1 2 10 3 101 4 1100 5 11001 6\n100010 10 0000110000 7 0101010 Output 0 1 2 1 2 3 1 5 Note In the first test\ncase, the string is already non-decreasing. In the second test case, you can\nselect \n    i = 1\n and then \n    s = \n    01\n. In the third test case,\nyou can select \n    i = 1\n and get \n    s = \n    010\n, and then select\n\n    i = 2\n. As a result, we get \n    s = \n    001\n, that is, a non-\ndecreasing string. In the sixth test case, you can select \n    i = 5\n at the\nfirst iteration and get \n    s = \n    100001\n. Then choose \n    i = 2\n,\nthen \n    s = \n    111110\n. Then we select \n    i = 1\n, getting the non-\ndecreasing string \n    s = \n    000001\n.\n\n",
        "cf_contest_id": 1732,
        "cf_index": "B",
        "cf_rating": 900,
        "difficulty": 0,
        "cf_tags": [
            "brute force",
            "dp",
            "greedy",
            "implementation"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "8\r\n1\r\n1\r\n2\r\n10\r\n3\r\n101\r\n4\r\n1100\r\n5\r\n11001\r\n6\r\n100010\r\n10\r\n0000110000\r\n7\r\n0101010\r\n",
                "0\r\n1\r\n2\r\n1\r\n2\r\n3\r\n1\r\n5\r\n"
            ]
        ],
        "private_cases": []
    }
]