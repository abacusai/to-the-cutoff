[
    {
        "name": "Bit Flipping",
        "description": "You are given a binary string of length \n    n\n. You have exactly \n    k\n\nmoves. In one move, you must select a single bit. The state of all bits except\nthat bit will get flipped (\n    0\n becomes \n    1\n, \n    1\n becomes \n    0\n).\nYou need to output the lexicographically largest string that you can get after\nusing all \n    k\n moves. Also, output the number of times you will select each\nbit. If there are multiple ways to do this, you may output any of them. A\nbinary string \n    a\n is lexicographically larger than a binary string \n    b\n\nof the same length, if and only if the following holds: in the first position\nwhere \n    a\n and \n    b\n differ, the string \n    a\n contains a \n    1\n, and\nthe string \n    b\n contains a \n    0\n. Input The first line contains a single\ninteger \n    t\n (\n    1 \n    \u2264 t \n    \u2264 1000\n) \u2014 the number of test cases. Each\ntest case has two lines. The first line has two integers \n    n\n and \n    k\n\n(\n    1 \n    \u2264 n \n    \u2264 2 \n    \u00b7 10^5\n; \n    0 \n    \u2264 k \n    \u2264 10^9\n). The\nsecond line has a binary string of length \n    n\n, each character is either\n\n    0\n or \n    1\n. The sum of \n    n\n over all test cases does not exceed\n\n    2 \n    \u00b7 10^5\n. Output For each test case, output two lines. The first\nline should contain the lexicographically largest string you can obtain. The\nsecond line should contain \n    n\n integers \n    f_1, f_2, \n    \u2026, f_n\n,\nwhere \n    f_i\n is the number of times the \n    i\n-th bit is selected. The sum\nof all the integers must be equal to \n    k\n. Example Input 6 6 3 100001 6 4\n100011 6 0 000000 6 1 111001 6 11 101100 6 12 001110 Output 111110 1 0 0 2 0 0\n111110 0 1 1 1 0 1 000000 0 0 0 0 0 0 100110 1 0 0 0 0 0 111111 1 2 1 3 0 4\n111110 1 1 4 2 0 4 Note Here is the explanation for the first testcase. Each\nstep shows how the binary string changes in a move. Choose bit \n    1\n:\n\n    100001\n    \u2192\n    \n    1\n    11110\n. Choose bit \n    4\n:\n\n    111\n    110\n    \u2192\n    000\n    \n    1\n    01\n. Choose\nbit \n    4\n: \n    000\n    101\n    \u2192\n    111\n    \n    1\n    10\n. The\nfinal string is \n    111110\n and this is the lexicographically largest string\nwe can get.\n\n",
        "cf_contest_id": 1659,
        "cf_index": "B",
        "cf_rating": 1300,
        "difficulty": 0,
        "cf_tags": [
            "bitmasks",
            "constructive algorithms",
            "greedy",
            "strings"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "6\r\n6 3\r\n100001\r\n6 4\r\n100011\r\n6 0\r\n000000\r\n6 1\r\n111001\r\n6 11\r\n101100\r\n6 12\r\n001110\r\n",
                "111110\r\n1 0 0 0 0 2\r\n111110\r\n0 1 1 1 0 1\r\n000000\r\n0 0 0 0 0 0\r\n100110\r\n1 0 0 0 0 0\r\n111111\r\n1 0 1 1 0 8\r\n111110\r\n1 1 0 0 0 10\r\n"
            ]
        ],
        "private_cases": []
    }
]