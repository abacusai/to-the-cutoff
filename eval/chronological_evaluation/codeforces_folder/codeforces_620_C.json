[
    {
        "name": "Pearls in a Row",
        "description": "There are n pearls in a row. Let's enumerate them with integers from 1 to n\nfrom the left to the right. The pearl number i has the type ai. Let's call a\nsequence of consecutive pearls a segment. Let's call a segment good if it\ncontains two pearls of the same type. Split the row of the pearls to the\nmaximal number of good segments. Note that each pearl should appear in exactly\none segment of the partition. As input/output can reach huge size it is\nrecommended to use fast input/output methods: for example, prefer to use\nscanf/printf instead of cin/cout in C++, prefer to use\nBufferedReader/PrintWriter instead of Scanner/System.out in Java. Input The\nfirst line contains integer n (1 \u2264 n \u2264 3\u00b710^5) \u2014 the number of pearls in a\nrow. The second line contains n integers ai (1 \u2264 ai \u2264 10^9) \u2013 the type of the\ni-th pearl. Output On the first line print integer k \u2014 the maximal number of\nsegments in a partition of the row. Each of the next k lines should contain\ntwo integers lj, rj (1 \u2264 lj \u2264 rj \u2264 n) \u2014 the number of the leftmost and the\nrightmost pearls in the j-th segment. Note you should print the correct\npartition of the row of the pearls, so each pearl should be in exactly one\nsegment and all segments should contain two pearls of the same type. If there\nare several optimal solutions print any of them. You can print the segments in\nany order. If there are no correct partitions of the row print the number\n\"-1\". Examples Input 5 1 2 3 4 1 Output 1 1 5 Input 5 1 2 3 4 5 Output -1\nInput 7 1 2 1 3 1 2 1 Output 2 1 3 4 7\n\n",
        "cf_contest_id": 620,
        "cf_index": "C",
        "cf_rating": 1500,
        "difficulty": 0,
        "cf_tags": [
            "greedy"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "5\r\n1 2 3 4 1\r\n",
                "1\r\n1 5\r\n"
            ],
            [
                "5\r\n1 2 3 4 5\r\n",
                "-1\r\n"
            ],
            [
                "7\r\n1 2 1 3 1 2 1\r\n",
                "2\r\n1 3\r\n4 7\r\n"
            ]
        ],
        "private_cases": [
            [
                "9\r\n1 2 1 2 1 2 1 2 1\r\n",
                "3\r\n1 3\r\n4 6\r\n7 9\r\n"
            ],
            [
                "11\r\n1 1 2 1 2 1 2 1 2 1 1\r\n",
                "4\r\n1 2\r\n3 5\r\n6 8\r\n9 11\r\n"
            ],
            [
                "1\r\n576560149\r\n",
                "-1\r\n"
            ],
            [
                "10\r\n460626451 460626451 460626451 460626451 460626451 460626451 460626451 460626451 460626451 460626451\r\n",
                "5\r\n1 2\r\n3 4\r\n5 6\r\n7 8\r\n9 10\r\n"
            ],
            [
                "10\r\n933677171 80672280 80672280 933677171 933677171 933677171 933677171 80672280 80672280 933677171\r\n",
                "4\r\n1 3\r\n4 5\r\n6 7\r\n8 10\r\n"
            ],
            [
                "10\r\n522312461 21923894 21923894 544064902 488228616 329635457 522312461 488228616 654502493 598654597\r\n",
                "2\r\n1 3\r\n4 10\r\n"
            ],
            [
                "7\r\n13 9 19 13 3 13 12\r\n",
                "1\r\n1 7\r\n"
            ],
            [
                "3\r\n1 1 1\r\n",
                "1\r\n1 3\r\n"
            ],
            [
                "5\r\n1 2 2 2 3\r\n",
                "1\r\n1 5\r\n"
            ],
            [
                "5\r\n1 2 2 2 1\r\n",
                "1\r\n1 5\r\n"
            ],
            [
                "13\r\n1 1 1 1 1 1 1 1 1 1 1 1 1\r\n",
                "6\r\n1 2\r\n3 4\r\n5 6\r\n7 8\r\n9 10\r\n11 13\r\n"
            ],
            [
                "4\r\n1 2 1 2\r\n",
                "1\r\n1 4\r\n"
            ]
        ]
    }
]