[
    {
        "name": "The Forbidden Permutation",
        "description": "You are given a permutation \n    p\n of length \n    n\n, an array of \n    m\n\ndistinct integers \n    a_1, a_2, \n    \u2026, a_m\n (\n    1 \n    \u2264 a_i \n    \u2264 n\n),\nand an integer \n    d\n. Let \n    pos(x)\n be the index of \n    x\n in\nthe permutation \n    p\n. The array \n    a\n is not good if\n\n    pos(a_i) < \n    pos(a_i + 1) \n    \u2264\n    pos(a_i) + d\n for all \n    1 \n    \u2264 i < m\n. For example, with\nthe permutation \n    p = [4, 2, 1, 3, 6, 5]\n and \n    d = 2\n: \n    a = [2, 3,\n    6]\n is a not good array. \n    a = [2, 6, 5]\n is good because\n\n    pos(a_1) = 2\n, \n    pos(a_2) = 5\n, so the condition\n\n    pos(a_2) \n    \u2264\n    pos(a_1) + d\n is not satisfied. \n    a\n    = [1, 6, 3]\n is good because \n    pos(a_2) = 5\n,\n\n    pos(a_3) = 4\n, so the condition \n    pos(a_2) <\n    \n    pos(a_3)\n is not satisfied. In one move, you can swap two\nadjacent elements of the permutation \n    p\n. What is the minimum number of\nmoves needed such that the array \n    a\n becomes good? It can be shown that\nthere always exists a sequence of moves so that the array \n    a\n becomes\ngood. A permutation is an array consisting of \n    n\n distinct integers from\n\n    1\n to \n    n\n in arbitrary order. For example, \n    [2,3,1,5,4]\n is a\npermutation, but \n    [1,2,2]\n is not a permutation (\n    2\n appears twice in\nthe array) and \n    [1,3,4]\n is also not a permutation (\n    n=3\n, but there\nis \n    4\n in the array). Input Each test contains multiple test cases. The\nfirst line contains the number of test cases \n    t\n (\n    1 \n    \u2264 t \n    \u2264\n    10^4\n). The description of the test cases follows. The first line of each\ntest case contains three integers \n    n\n, \n    m\n and \n    d\n (\n    2\n    \u2264 n\n    \n    \u2264 10^5\n, \n    2\n    \u2264 m\n    \u2264 n\n, \n    1 \n    \u2264 d \n    \u2264 n\n), the length\nof the permutation \n    p\n, the length of the array \n    a\n and the value of\n\n    d\n. The second line contains \n    n\n integers \n    p_1, p_2, \n    \u2026,\n    p_n\n (\n    1\n    \u2264 p_i \n    \u2264 n\n, \n    p_i \n     p_j\n for \n    i \n     j\n).\nThe third line contains \n    m\n distinct integers \n    a_1, a_2, \n    \u2026,\n    a_m\n (\n    1\n    \u2264 a_i \n    \u2264 n\n, \n    a_i \n     a_j\n for \n    i \n     j\n).\nThe sum of \n    n\n over all test cases doesn't exceed \n    5 \n    \u00b7 10^5\n.\nOutput For each test case, print the minimum number of moves needed such that\nthe array \n    a\n becomes good. Example Input 5 4 2 2 1 2 3 4 1 3 5 2 4 5 4 3\n2 1 5 2 5 3 3 3 4 1 5 2 3 1 2 2 2 1 1 2 2 1 6 2 4 1 2 3 4 5 6 2 5 Output 1 3 2\n0 2 Note In the first case, \n    pos(a_1)=1\n, \n    pos(a_2)=3\n. To make the\narray good, one way is to swap \n    p_3\n and \n    p_4\n. After that, the array\n\n    a\n will be good because the condition \n    pos(a_2) \n    \u2264\n    pos(a_1) + d\n won't be satisfied. In the second case,\n\n    pos(a_1)=1\n, \n    pos(a_2)=4\n. The \n    3\n moves could be: Swap \n    p_3\n\nand \n    p_4\n. Swap \n    p_2\n and \n    p_3\n. Swap \n    p_1\n and \n    p_2\n.\nAfter these moves, the permutation \n    p\n will be \n    [2,5,4,3,1]\n. The\narray \n    a\n will be good because the condition \n    pos(a_1) <\n    \n    pos(a_2)\n won't be satisfied. It can be shown that you can't make\nthe array \n    a\n good with fewer moves.In the third case, \n    pos(a_1)=1\n,\n\n    pos(a_2)=3\n, \n    pos(a_3)=5\n. The \n    2\n moves can be: Swap \n    p_4\n\nand \n    p_5\n. Swap \n    p_3\n and \n    p_4\n. After these moves, the\npermutation \n    p\n will be \n    [3,4,2,1,5]\n. The array \n    a\n will be good\nbecause the condition \n    pos(a_2) < \n    pos(a_3)\n won't be\nsatisfied. It can be shown that you can't make the array \n    a\n good with\nfewer moves.In the fourth case, \n    pos(a_1)=2\n, \n    pos(a_2)=1\n. The array\n\n    a\n is already good. In the fifth case, \n    pos(a_1)=2\n,\n\n    pos(a_2)=5\n. The \n    2\n moves are: Swap \n    p_1\n and \n    p_2\n. Swap\n\n    p_5\n and \n    p_6\n.\n\n",
        "cf_contest_id": 1778,
        "cf_index": "B",
        "cf_rating": 1300,
        "difficulty": 0,
        "cf_tags": [
            "greedy",
            "math"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "5\r\n4 2 2\r\n1 2 3 4\r\n1 3\r\n5 2 4\r\n5 4 3 2 1\r\n5 2\r\n5 3 3\r\n3 4 1 5 2\r\n3 1 2\r\n2 2 1\r\n1 2\r\n2 1\r\n6 2 4\r\n1 2 3 4 5 6\r\n2 5\r\n",
                "1\r\n3\r\n2\r\n0\r\n2\r\n"
            ]
        ],
        "private_cases": []
    }
]