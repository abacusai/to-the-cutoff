[
    {
        "name": "Tokitsukaze and Good 01-String (easy version)",
        "description": "This is the easy version of the problem. The only difference between the two\nversions is that the harder version asks additionally for a minimum number of\nsubsegments. Tokitsukaze has a binary string \n    s\n of length \n    n\n,\nconsisting only of zeros and ones, \n    n\n is even. Now Tokitsukaze divides\n\n    s\n into the minimum number of contiguous subsegments, and for each\nsubsegment, all bits in each subsegment are the same. After that, \n    s\n is\nconsidered good if the lengths of all subsegments are even. For example, if\n\n    s\n is \"11001111\", it will be divided into \"11\", \"00\" and \"1111\". Their\nlengths are \n    2\n, \n    2\n, \n    4\n respectively, which are all even\nnumbers, so \"11001111\" is good. Another example, if \n    s\n is \"1110011000\",\nit will be divided into \"111\", \"00\", \"11\" and \"000\", and their lengths are\n\n    3\n, \n    2\n, \n    2\n, \n    3\n. Obviously, \"1110011000\" is not good.\nTokitsukaze wants to make \n    s\n good by changing the values of some\npositions in \n    s\n. Specifically, she can perform the operation any number\nof times: change the value of \n    s_i\n to '0' or '1'(\n    1 \n    \u2264 i \n    \u2264\n    n\n). Can you tell her the minimum number of operations to make \n    s\n good?\nInput The first contains a single positive integer \n    t\n (\n    1 \n    \u2264 t\n    \n    \u2264 10\n     000\n) \u2014 the number of test cases. For each test case, the first\nline contains a single integer \n    n\n (\n    2 \n    \u2264 n \n    \u2264 2 \n    \u00b7\n    10^5\n) \u2014 the length of \n    s\n, it is guaranteed that \n    n\n is even. The\nsecond line contains a binary string \n    s\n of length \n    n\n, consisting\nonly of zeros and ones. It is guaranteed that the sum of \n    n\n over all test\ncases does not exceed \n    2 \n    \u00b7 10^5\n. Output For each test case, print a\nsingle line with one integer \u2014 the minimum number of operations to make\n\n    s\n good. Example Input 5 10 1110011000 8 11001111 2 00 2 11 6 100110\nOutput 3 0 0 0 3 Note In the first test case, one of the ways to make \n    s\n\ngood is the following. Change \n    s_3\n, \n    s_6\n and \n    s_7\n to '0', after\nthat \n    s\n becomes \"1100000000\", it can be divided into \"11\" and \"00000000\",\nwhich lengths are \n    2\n and \n    8\n respectively. There are other ways to\noperate \n    3\n times to make \n    s\n good, such as \"1111110000\",\n\"1100001100\", \"1111001100\". In the second, third and fourth test cases,\n\n    s\n is good initially, so no operation is required.\n\n",
        "cf_contest_id": 1678,
        "cf_index": "B1",
        "cf_rating": 800,
        "difficulty": 0,
        "cf_tags": [
            "implementation"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "5\r\n10\r\n1110011000\r\n8\r\n11001111\r\n2\r\n00\r\n2\r\n11\r\n6\r\n100110\r\n",
                "3\r\n0\r\n0\r\n0\r\n3\r\n"
            ]
        ],
        "private_cases": []
    }
]