[
    {
        "name": "Tokitsukaze and Good 01-String (hard version)",
        "description": "This is the hard version of the problem. The only difference between the two\nversions is that the harder version asks additionally for a minimum number of\nsubsegments. Tokitsukaze has a binary string \n    s\n of length \n    n\n,\nconsisting only of zeros and ones, \n    n\n is even. Now Tokitsukaze divides\n\n    s\n into the minimum number of contiguous subsegments, and for each\nsubsegment, all bits in each subsegment are the same. After that, \n    s\n is\nconsidered good if the lengths of all subsegments are even. For example, if\n\n    s\n is \"11001111\", it will be divided into \"11\", \"00\" and \"1111\". Their\nlengths are \n    2\n, \n    2\n, \n    4\n respectively, which are all even\nnumbers, so \"11001111\" is good. Another example, if \n    s\n is \"1110011000\",\nit will be divided into \"111\", \"00\", \"11\" and \"000\", and their lengths are\n\n    3\n, \n    2\n, \n    2\n, \n    3\n. Obviously, \"1110011000\" is not good.\nTokitsukaze wants to make \n    s\n good by changing the values of some\npositions in \n    s\n. Specifically, she can perform the operation any number\nof times: change the value of \n    s_i\n to '0' or '1' (\n    1 \n    \u2264 i \n    \u2264\n    n\n). Can you tell her the minimum number of operations to make \n    s\n good?\nMeanwhile, she also wants to know the minimum number of subsegments that\n\n    s\n can be divided into among all solutions with the minimum number of\noperations. Input The first contains a single positive integer \n    t\n (\n    1\n    \n    \u2264 t \n    \u2264 10\n     000\n) \u2014 the number of test cases. For each test case,\nthe first line contains a single integer \n    n\n (\n    2 \n    \u2264 n \n    \u2264 2\n    \n    \u00b7 10^5\n) \u2014 the length of \n    s\n, it is guaranteed that \n    n\n is\neven. The second line contains a binary string \n    s\n of length \n    n\n,\nconsisting only of zeros and ones. It is guaranteed that the sum of \n    n\n\nover all test cases does not exceed \n    2 \n    \u00b7 10^5\n. Output For each test\ncase, print a single line with two integers \u2014 the minimum number of operations\nto make \n    s\n good, and the minimum number of subsegments that \n    s\n can\nbe divided into among all solutions with the minimum number of operations.\nExample Input 5 10 1110011000 8 11001111 2 00 2 11 6 100110 Output 3 2 0 3 0 1\n0 1 3 1 Note In the first test case, one of the ways to make \n    s\n good is\nthe following. Change \n    s_3\n, \n    s_6\n and \n    s_7\n to '0', after that\n\n    s\n becomes \"1100000000\", it can be divided into \"11\" and \"00000000\",\nwhich lengths are \n    2\n and \n    8\n respectively, the number of subsegments\nof it is \n    2\n. There are other ways to operate \n    3\n times to make\n\n    s\n good, such as \"1111110000\", \"1100001100\", \"1111001100\", the number of\nsubsegments of them are \n    2\n, \n    4\n, \n    4\n respectively. It's easy to\nfind that the minimum number of subsegments among all solutions with the\nminimum number of operations is \n    2\n. In the second, third and fourth test\ncases, \n    s\n is good initially, so no operation is required.\n\n",
        "cf_contest_id": 1678,
        "cf_index": "B2",
        "cf_rating": 1800,
        "difficulty": 0,
        "cf_tags": [
            "dp",
            "greedy",
            "implementation"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "5\r\n10\r\n1110011000\r\n8\r\n11001111\r\n2\r\n00\r\n2\r\n11\r\n6\r\n100110\r\n",
                "3 2\r\n0 3\r\n0 1\r\n0 1\r\n3 1\r\n"
            ]
        ],
        "private_cases": []
    }
]