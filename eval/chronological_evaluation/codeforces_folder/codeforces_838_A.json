[
    {
        "name": "Binary Blocks",
        "description": "You are given an image, that can be represented with a 2-d n by m grid of\npixels. Each pixel of the image is either on or off, denoted by the characters\n\"0\" or \"1\", respectively. You would like to compress this image. You want to\nchoose an integer k > 1 and split the image into k by k blocks. If n and m are\nnot divisible by k, the image is padded with only zeros on the right and\nbottom so that they are divisible by k. Each pixel in each individual block\nmust have the same value. The given image may not be compressible in its\ncurrent state. Find the minimum number of pixels you need to toggle (after\npadding) in order for the image to be compressible for some k. More\nspecifically, the steps are to first choose k, then the image is padded with\nzeros, then, we can toggle the pixels so it is compressible for this k. The\nimage must be compressible in that state. Input The first line of input will\ncontain two integers n, m (2 \u2264 n, m \u2264 2 500), the dimensions of the image. The\nnext n lines of input will contain a binary string with exactly m characters,\nrepresenting the image. Output Print a single integer, the minimum number of\npixels needed to toggle to make the image compressible. Example Input 3 5\n00100 10110 11001 Output 5 Note We first choose k = 2. The image is padded as\nfollows: 001000 101100 110010 000000 We can toggle the image to look as\nfollows: 001100 001100 000000 000000 We can see that this image is\ncompressible for k = 2.\n\n",
        "cf_contest_id": 838,
        "cf_index": "A",
        "cf_rating": 1400,
        "difficulty": 0,
        "cf_tags": [
            "brute force"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "3 5\r\n00100\r\n10110\r\n11001\r\n",
                "5"
            ]
        ],
        "private_cases": []
    }
]