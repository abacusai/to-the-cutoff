[
    {
        "name": "Good Subarrays (Hard Version)",
        "description": "This is the hard version of this problem. In this version, we have queries.\nNote that we do not have multiple test cases in this version. You can make\nhacks only if both versions of the problem are solved. An array \n    b\n of\nlength \n    m\n is good if for all \n    i\n the \n    i\n-th element is greater\nthan or equal to \n    i\n. In other words, \n    b\n is good if and only if\n\n    b_i \n    \u2265 i\n for all \n    i\n (\n    1 \n    \u2264 i \n    \u2264 m\n). You are given\nan array \n    a\n consisting of \n    n\n positive integers, and you are asked\n\n    q\n queries. In each query, you are given two integers \n    p\n and \n    x\n\n(\n    1 \n    \u2264 p,x \n    \u2264 n\n). You have to do \n    a_p := x\n (assign \n    x\n\nto \n    a_p\n). In the updated array, find the number of pairs of indices\n\n    (l, r)\n, where \n    1 \n    \u2264 l \n    \u2264 r \n    \u2264 n\n, such that the array\n\n    [a_l, a_l+1, \n    \u2026, a_r]\n is good. Note that all queries are\nindependent, which means after each query, the initial array \n    a\n is\nrestored. Input The first line contains a single integer \n    n\n (\n    1 \n    \u2264 n\n    \n    \u2264 2 \n    \u00b7 10^5\n). The second line contains \n    n\n integers \n    a_1,\n    a_2, \n    \u2026, a_n\n (\n    1 \n    \u2264 a_i \n    \u2264 n\n). The third line contains an\ninteger \n    q\n (\n    1 \n    \u2264 q \n    \u2264 2 \n    \u00b7 10^5\n) \u2014 the number of\nqueries. Each of the next \n    q\n lines contains two integers \n    p_j\n and\n\n    x_j\n (\n    1 \n    \u2264 p_j, x_j \n    \u2264 n\n) \u2013 the description of the\n\n    j\n-th query. Output For each query, print the number of suitable pairs of\nindices after making the change. Examples Input 4 2 4 1 4 3 2 4 3 3 2 1 Output\n6 10 5 Input 5 1 1 3 2 1 3 1 3 2 5 4 5 Output 7 9 8 Note Here are notes for\nfirst example. In first query, after update \n    a=[2,4,1,4]\n. Now\n\n    (1,1)\n, \n    (2,2)\n, \n    (3,3)\n, \n    (4,4)\n, \n    (1,2)\n, and\n\n    (3,4)\n are suitable pairs. In second query, after update\n\n    a=[2,4,3,4]\n. Now all subarrays of \n    a\n are good. In third query,\nafter update \n    a=[2,1,1,4]\n. Now \n    (1,1)\n, \n    (2,2)\n, \n    (3,3)\n,\n\n    (4,4)\n, and \n    (3,4)\n are suitable.\n\n",
        "cf_contest_id": 1736,
        "cf_index": "C2",
        "cf_rating": 2400,
        "difficulty": 0,
        "cf_tags": [
            "binary search",
            "data structures",
            "dp",
            "two pointers"
        ],
        "time_limit_seconds": 3.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "4\r\n2 4 1 4\r\n3\r\n2 4\r\n3 3\r\n2 1\r\n",
                "6\r\n10\r\n5\r\n"
            ],
            [
                "5\r\n1 1 3 2 1\r\n3\r\n1 3\r\n2 5\r\n4 5\r\n",
                "7\r\n9\r\n8\r\n"
            ]
        ],
        "private_cases": []
    }
]