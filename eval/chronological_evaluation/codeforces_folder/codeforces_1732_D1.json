[
    {
        "name": "Balance (Easy version)",
        "description": "This is the easy version of the problem. The only difference is that in this\nversion there are no \"remove\" queries. Initially you have a set containing one\nelement \u2014 \n    0\n. You need to handle \n    q\n queries of the following types:\n \n    x\n \u2014 add the integer \n    x\n to the set. It is guaranteed that this\ninteger is not contained in the set; ? \n    k\n \u2014 find the \n    k\n    -mex\n\nof the set. In our problem, we define the \n    k\n    -mex\n of a set of\nintegers as the smallest non-negative integer \n    x\n that is divisible by\n\n    k\n and which is not contained in the set. Input The first line contains\nan integer \n    q\n (\n    1 \n    \u2264 q \n    \u2264 2 \n    \u00b7 10^5\n) \u2014 the number of\nqueries. The following \n    q\n lines describe the queries. An addition query\nof integer \n    x\n is given in the format + \n    x\n (\n    1 \n    \u2264 x \n    \u2264\n    10^18\n). It is guaranteed that \n    x\n was not contained in the set. A\nsearch query of \n    k\n    -mex\n is given in the format ? \n    k\n (\n    1\n    \n    \u2264 k \n    \u2264 10^18\n). It is guaranteed that there will be at least one\nquery of type ?. Output For each query of type ? output a single integer \u2014 the\n\n    k\n    -mex\n of the set. Examples Input 15  1  2 ? 1  4 ? 2  6\n? 3  7  8 ? 1 ? 2  5 ? 1  1000000000000000000 ? 1000000000000000000\nOutput 3 6 3 3 10 3 2000000000000000000 Input 6  100 ? 100  200 ? 100 \n50 ? 50 Output 200 300 150 Note In the first example: After the first and\nsecond queries, the set will contain elements \n    0, 1, 2\n. The\nsmallest non-negative number that is divisible by \n    1\n and is not contained\nin the set is \n    3\n. After the fourth query, the set will contain the\nelements \n    0, 1, 2, 4\n. The smallest non-negative number that is\ndivisible by \n    2\n and is not contained in the set is \n    6\n. In the second\nexample: Initially, the set contains only the element \n    0\n. After\nadding an integer \n    100\n the set contains elements \n    0, 100\n.\n\n    100\n    -mex\n of the set is \n    200\n. After adding an integer\n\n    200\n the set contains elements \n    0, 100, 200\n.\n\n    100\n    -mex\n of the set is \n    300\n. After adding an integer\n\n    50\n the set contains elements \n    0, 50, 100, 200\n.\n\n    50\n    -mex\n of the set is \n    150\n.\n\n",
        "cf_contest_id": 1732,
        "cf_index": "D1",
        "cf_rating": 1500,
        "difficulty": 0,
        "cf_tags": [
            "brute force",
            "data structures",
            "implementation",
            "number theory"
        ],
        "time_limit_seconds": 3.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "15\r\n+ 1\r\n+ 2\r\n? 1\r\n+ 4\r\n? 2\r\n+ 6\r\n? 3\r\n+ 7\r\n+ 8\r\n? 1\r\n? 2\r\n+ 5\r\n? 1\r\n+ 1000000000000000000\r\n? 1000000000000000000\r\n",
                "3\r\n6\r\n3\r\n3\r\n10\r\n3\r\n2000000000000000000\r\n"
            ],
            [
                "6\r\n+ 100\r\n? 100\r\n+ 200\r\n? 100\r\n+ 50\r\n? 50\r\n",
                "200\r\n300\r\n150\r\n"
            ]
        ],
        "private_cases": []
    }
]