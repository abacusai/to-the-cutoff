[
    {
        "name": "Unstable String",
        "description": "You are given a string \n    s\n consisting of the characters 0, 1, and ?. Let's\ncall a string unstable if it consists of the characters 0 and 1 and any two\nadjacent characters are different (i. e. it has the form 010101... or\n101010...). Let's call a string beautiful if it consists of the characters 0,\n1, and ?, and you can replace the characters ? to 0 or 1 (for each character,\nthe choice is independent), so that the string becomes unstable. For example,\nthe strings 0??10, 0, and ??? are beautiful, and the strings 00 and ?1??1 are\nnot. Calculate the number of beautiful contiguous substrings of the string\n\n    s\n. Input The first line contains a single integer \n    t\n (\n    1 \n    \u2264 t\n    \n    \u2264 10^4\n) \u2014 number of test cases. The first and only line of each test\ncase contains the string \n    s\n (\n    1 \n    \u2264 |s| \n    \u2264 2 \n    \u00b7 10^5\n)\nconsisting of characters 0, 1, and ?. It is guaranteed that the sum of the\nstring lengths over all test cases does not exceed \n    2 \n    \u00b7 10^5\n.\nOutput For each test case, output a single integer \u2014 the number of beautiful\nsubstrings of the string \n    s\n. Example Input 3 0?10 ??? ?10??1100 Output 8\n6 25\n\n",
        "cf_contest_id": 1535,
        "cf_index": "C",
        "cf_rating": 1400,
        "difficulty": 0,
        "cf_tags": [
            "binary search",
            "dp",
            "greedy",
            "implementation",
            "strings",
            "two pointers"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "3\r\n0?10\r\n???\r\n?10??1100\r\n",
                "8\r\n6\r\n25\r\n"
            ]
        ],
        "private_cases": [
            [
                "1\r\n00000000\r\n",
                "8\r\n"
            ]
        ]
    }
]