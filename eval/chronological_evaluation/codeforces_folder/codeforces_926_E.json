[
    {
        "name": "Merge Equal Elements",
        "description": "You are given a sequence of positive integers a1, a2, ..., an. While possible,\nyou perform the following operation: find a pair of equal consecutive\nelements. If there are more than one such pair, find the leftmost (with the\nsmallest indices of elements). If the two integers are equal to x, delete both\nand insert a single integer x + 1 on their place. This way the number of\nelements in the sequence is decreased by 1 on each step. You stop performing\nthe operation when there is no pair of equal consecutive elements. For\nexample, if the initial sequence is [5, 2, 1, 1, 2, 2], then after the first\noperation you get [5, 2, 2, 2, 2], after the second \u2014 [5, 3, 2, 2], after the\nthird \u2014 [5, 3, 3], and finally after the fourth you get [5, 4]. After that\nthere are no equal consecutive elements left in the sequence, so you stop the\nprocess. Determine the final sequence after you stop performing the operation.\nInput The first line contains a single integer n (2 \u2264 n \u2264 2\u00b710^5) \u2014 the number\nof elements in the sequence. The second line contains the sequence of integers\na1, a2, ..., an (1 \u2264 ai \u2264 10^9). Output In the first line print a single\ninteger k \u2014 the number of elements in the sequence after you stop performing\nthe operation. In the second line print k integers \u2014 the sequence after you\nstop performing the operation. Examples Input 6 5 2 1 1 2 2 Output 2 5 4 Input\n4 1000000000 1000000000 1000000000 1000000000 Output 1 1000000002 Input 7 4 10\n22 11 12 5 6 Output 7 4 10 22 11 12 5 6 Note The first example is described in\nthe statements. In the second example the initial sequence is [1000000000,\n1000000000, 1000000000, 1000000000]. After the first operation the sequence is\nequal to [1000000001, 1000000000, 1000000000]. After the second operation the\nsequence is [1000000001, 1000000001]. After the third operation the sequence\nis [1000000002]. In the third example there are no two equal consecutive\nelements initially, so the sequence does not change.\n\n",
        "cf_contest_id": 926,
        "cf_index": "E",
        "cf_rating": 1900,
        "difficulty": 0,
        "cf_tags": [
            "constructive algorithms",
            "data structures"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "6\r\n5 2 1 1 2 2\r\n",
                "2\r\n5 4\r\n"
            ],
            [
                "4\r\n1000000000 1000000000 1000000000 1000000000\r\n",
                "1\r\n1000000002\r\n"
            ],
            [
                "7\r\n4 10 22 11 12 5 6\r\n",
                "7\r\n4 10 22 11 12 5 6\r\n"
            ]
        ],
        "private_cases": [
            [
                "2\r\n1 1\r\n",
                "1\r\n2\r\n"
            ],
            [
                "3\r\n2 1 1\r\n",
                "1\r\n3\r\n"
            ],
            [
                "4\r\n3 2 1 1\r\n",
                "1\r\n4\r\n"
            ],
            [
                "7\r\n5 5 4 4 5 6 7\r\n",
                "3\r\n7 6 7\r\n"
            ]
        ]
    }
]