[
    {
        "name": "Omkar and Heavenly Tree",
        "description": "Lord Omkar would like to have a tree with \n    n\n nodes (\n    3 \n    \u2264 n \n    \u2264\n    10^5\n) and has asked his disciples to construct the tree. However, Lord\nOmkar has created \n    m\n (\n    1 \n    \u2264 \ud835\udc26 < \ud835\udc27\n) restrictions to\nensure that the tree will be as heavenly as possible. A tree with \n    n\n\nnodes is an connected undirected graph with \n    n\n nodes and \n    n-1\n edges.\nNote that for any two nodes, there is exactly one simple path between them,\nwhere a simple path is a path between two nodes that does not contain any node\nmore than once. Here is an example of a tree: A restriction consists of\n\n    3\n pairwise distinct integers, \n    a\n, \n    b\n, and \n    c\n (\n    1 \n    \u2264\n    a,b,c \n    \u2264 n\n). It signifies that node \n    b\n cannot lie on the simple\npath between node \n    a\n and node \n    c\n. Can you help Lord Omkar and become\nhis most trusted disciple? You will need to find heavenly trees for multiple\nsets of restrictions. It can be shown that a heavenly tree will always exist\nfor any set of restrictions under the given constraints. Input Each test\ncontains multiple test cases. The first line contains the number of test cases\n\n    t\n (\n    1 \n    \u2264 t \n    \u2264 10^4\n). Description of the test cases follows.\nThe first line of each test case contains two integers, \n    n\n and \n    m\n\n(\n    3 \n    \u2264 n \n    \u2264 10^5\n, \n    1 \n    \u2264 \ud835\udc26 < \ud835\udc27\n), representing\nthe size of the tree and the number of restrictions. The \n    i\n-th of the\nnext \n    m\n lines contains three integers \n    a_i\n, \n    b_i\n, \n    c_i\n\n(\n    1 \n    \u2264 a_i, b_i, c_i \n    \u2264 n\n, \n    a\n, \n    b\n, \n    c\n are distinct),\nsignifying that node \n    b_i\n cannot lie on the simple path between nodes\n\n    a_i\n and \n    c_i\n. It is guaranteed that the sum of \n    n\n across all\ntest cases will not exceed \n    10^5\n. Output For each test case, output\n\n    n-1\n lines representing the \n    n-1\n edges in the tree. On each line,\noutput two integers \n    u\n and \n    v\n (\n    1 \n    \u2264 u, v \n    \u2264 n\n, \n    u\n    \n    \u2260 v\n) signifying that there is an edge between nodes \n    u\n and\n\n    v\n. Given edges have to form a tree that satisfies Omkar's restrictions.\nExample Input 2 7 4 1 2 3 3 4 5 5 6 7 6 5 4 5 3 1 2 3 2 3 4 3 4 5 Output 1 2 1\n3 3 5 3 4 2 7 7 6 5 1 1 3 3 2 2 4 Note The output of the first sample case\ncorresponds to the following tree: For the first restriction, the simple path\nbetween \n    1\n and \n    3\n is \n    1, 3\n, which doesn't contain \n    2\n. The\nsimple path between \n    3\n and \n    5\n is \n    3, 5\n, which doesn't contain\n\n    4\n. The simple path between \n    5\n and \n    7\n is \n    5, 3, 1, 2, 7\n,\nwhich doesn't contain \n    6\n. The simple path between \n    6\n and \n    4\n is\n\n    6, 7, 2, 1, 3, 4\n, which doesn't contain \n    5\n. Thus, this tree meets\nall of the restrictions.The output of the second sample case corresponds to\nthe following tree:\n\n",
        "cf_contest_id": 1583,
        "cf_index": "B",
        "cf_rating": 1200,
        "difficulty": 0,
        "cf_tags": [
            "constructive algorithms",
            "trees"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "2\r\n7 4\r\n1 2 3\r\n3 4 5\r\n5 6 7\r\n6 5 4\r\n5 3\r\n1 2 3\r\n2 3 4\r\n3 4 5\r\n",
                "7 1\r\n7 2\r\n7 3\r\n7 4\r\n7 5\r\n7 6\r\n5 1\r\n5 2\r\n5 3\r\n5 4\r\n"
            ]
        ],
        "private_cases": []
    }
]