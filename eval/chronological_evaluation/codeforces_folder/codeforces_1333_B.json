[
    {
        "name": "Kind Anton",
        "description": "Once again, Boris needs the help of Anton in creating a task. This time Anton\nneeds to solve the following problem: There are two arrays of integers \n    a\n\nand \n    b\n of length \n    n\n. It turned out that array \n    a\n contains only\nelements from the set \n    -1, 0, 1\n. Anton can perform the\nfollowing sequence of operations any number of times: Choose any pair of\nindexes \n    (i, j)\n such that \n    1 \n    \u2264 i < j \n    \u2264 n\n. It is possible to\nchoose the same pair \n    (i, j)\n more than once. Add \n    a_i\n to \n    a_j\n.\nIn other words, \n    j\n-th element of the array becomes equal to \n    a_i +\n    a_j\n. For example, if you are given array \n    [1, -1, 0]\n, you can\ntransform it only to \n    [1, -1, -1]\n, \n    [1, 0, 0]\n and \n    [1, -1, 1]\n\nby one operation. Anton wants to predict if it is possible to apply some\nnumber (zero or more) of these operations to the array \n    a\n so that it\nbecomes equal to array \n    b\n. Can you help him? Input Each test contains\nmultiple test cases. The first line contains the number of test cases \n    t\n\n(\n    1 \n    \u2264 t \n    \u2264 10000\n). The description of the test cases follows. The\nfirst line of each test case contains a single integer \n    n\n (\n    1 \n    \u2264 n\n    \n    \u2264 10^5\n) \u2014 the length of arrays. The second line of each test case\ncontains \n    n\n integers \n    a_1, a_2, \n    \u2026, a_n\n (\n    -1 \n    \u2264 a_i \n    \u2264\n    1\n) \u2014 elements of array \n    a\n. There can be duplicates among elements. The\nthird line of each test case contains \n    n\n integers \n    b_1, b_2, \n    \u2026,\n    b_n\n (\n    -10^9 \n    \u2264 b_i \n    \u2264 10^9\n) \u2014 elements of array \n    b\n. There\ncan be duplicates among elements. It is guaranteed that the sum of \n    n\n\nover all test cases doesn't exceed \n    10^5\n. Output For each test case,\noutput one line containing \"YES\" if it's possible to make arrays \n    a\n and\n\n    b\n equal by performing the described operations, or \"NO\" if it's\nimpossible. You can print each letter in any case (upper or lower). Example\nInput 5 3 1 -1 0 1 1 -2 3 0 1 1 0 2 2 2 1 0 1 41 2 -1 0 -1 -41 5 0 1 -1 1 -1 1\n1 -1 1 -1 Output YES NO YES YES NO Note In the first test-case we can choose\n\n    (i, j)=(2, 3)\n twice and after that choose \n    (i, j)=(1, 2)\n twice too.\nThese operations will transform \n    [1, -1, 0] \n    \u2192 [1, -1, -2] \n    \u2192 [1, 1,\n    -2]\n In the second test case we can't make equal numbers on the second\nposition. In the third test case we can choose \n    (i, j)=(1, 2)\n \n    41\n\ntimes. The same about the fourth test case. In the last lest case, it is\nimpossible to make array \n    a\n equal to the array \n    b\n.\n\n",
        "cf_contest_id": 1333,
        "cf_index": "B",
        "cf_rating": 1100,
        "difficulty": 0,
        "cf_tags": [
            "greedy",
            "implementation"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "5\r\n3\r\n1 -1 0\r\n1 1 -2\r\n3\r\n0 1 1\r\n0 2 2\r\n2\r\n1 0\r\n1 41\r\n2\r\n-1 0\r\n-1 -41\r\n5\r\n0 1 -1 1 -1\r\n1 1 -1 1 -1\r\n",
                "yes\r\nno\r\nyes\r\nyes\r\nno\r\n"
            ]
        ],
        "private_cases": []
    }
]