[
    {
        "name": "Search in Parallel",
        "description": "Suppose you have \n    n\n boxes. The \n    i\n-th box contains infinitely many\nballs of color \n    i\n. Sometimes you need to get a ball with some specific\ncolor; but you're too lazy to do it yourself. You have bought two robots to\nretrieve the balls for you. Now you have to program them. In order to program\nthe robots, you have to construct two lists \n    [a_1, a_2, \n    \u2026, a_k]\n and\n\n    [b_1, b_2, \n    \u2026, b_n-k]\n, where the list \n    a\n represents the\nboxes assigned to the first robot, and the list \n    b\n represents the boxes\nassigned to the second robot. Every integer from \n    1\n to \n    n\n must be\npresent in exactly one of these lists. When you request a ball with color\n\n    x\n, the robots work as follows. Each robot looks through the boxes that\nwere assigned to that robot, in the order they appear in the list. The first\nrobot spends \n    s_1\n seconds analyzing the contents of a box; the second\nrobot spends \n    s_2\n. As soon as one of the robots finds the box with balls\nof color \n    x\n (and analyzes its contents), the search ends. The search time\nis the number of seconds from the beginning of the search until one of the\nrobots finishes analyzing the contents of the \n    x\n-th box. If a robot\nanalyzes the contents of all boxes assigned to it, it stops searching. For\nexample, suppose \n    s_1 = 2\n, \n    s_2 = 3\n, \n    a = [4, 1, 5, 3, 7]\n, \n    b\n    = [2, 6]\n. If you request a ball with color \n    3\n, the following happens:\ninitially, the first robot starts analyzing the box \n    4\n, and the second\nrobot starts analyzing the box \n    2\n; at the end of the \n    2\n-nd second,\nthe first robot finishes analyzing the box \n    4\n. It is not the box you\nneed, so the robot continues with the box \n    1\n; at the end of the\n\n    3\n-rd second, the second robot finishes analyzing the box \n    2\n. It is\nnot the box you need, so the robot continues with the box \n    6\n; at the end\nof the \n    4\n-th second, the first robot finishes analyzing the box \n    1\n.\nIt is not the box you need, so the robot continues with the box \n    5\n; at\nthe end of the \n    6\n-th second, the first robot finishes analyzing the box\n\n    5\n. It is not the box you need, so the robot continues with the box\n\n    3\n. At the same time, the second robot finishes analyzing the box\n\n    6\n. It is not the box you need, and the second robot has analyzed all the\nboxes in its list, so that robot stops searching; at the end of the \n    8\n-th\nsecond, the first robot finishes analyzing the box \n    3\n. It is the box you\nneed, so the search ends; so, the search time is \n    8\n seconds. You know\nthat you are going to request a ball of color \n    1\n \n    r_1\n times, a ball\nof color \n    2\n \n    r_2\n times, and so on. You want to construct the lists\n\n    a\n and \n    b\n for the robots in such a way that the total search time\nover all requests is the minimum possible. Input The first line contains one\ninteger \n    t\n (\n    1 \n    \u2264 t \n    \u2264 10^4\n) \u2014 the number of test cases. Each\ntest case consists of two lines: the first line contains three integers\n\n    n\n, \n    s_1\n, \n    s_2\n (\n    2 \n    \u2264 n \n    \u2264 2 \n    \u00b7 10^5\n; \n    1\n    \n    \u2264 s_1, s_2 \n    \u2264 10\n); the second line contains \n    n\n integers \n    r_1,\n    r_2, \n    \u2026, r_n\n (\n    1 \n    \u2264 r_i \n    \u2264 10^6\n). Additional constraint on\nthe input: the sum of \n    n\n over all test cases does not exceed \n    2 \n    \u00b7\n    10^5\n. Output For each test case, print two lines. The first line should\ncontain the list \n    a\n, the second line \u2014 the list \n    b\n. Each list has to\nbe printed as follows: first, print the number of elements in it, and then the\nelements themselves. If there are multiple answers, you may print any of them.\nExample Input 3 7 3 1 8 6 4 4 4 1 7 5 1 10 1 1 1 1 1 8 1 1 4 5 6 8 1 7 3 2\nOutput 2 5 6 5 1 7 2 4 3 5 4 3 5 2 1 0 4 4 2 7 5 4 6 3 1 8\n\n",
        "cf_contest_id": 1814,
        "cf_index": "C",
        "cf_rating": 1500,
        "difficulty": 0,
        "cf_tags": [
            "constructive algorithms",
            "greedy",
            "sortings"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 512.0,
        "public_cases": [
            [
                "3\r\n7 3 1\r\n8 6 4 4 4 1 7\r\n5 1 10\r\n1 1 1 1 1\r\n8 1 1\r\n4 5 6 8 1 7 3 2\r\n",
                "1 3\r\n6 1 7 2 4 5 6\r\n5 1 2 3 4 5\r\n0\r\n4 6 2 7 5\r\n4 4 3 1 8\r\n"
            ]
        ],
        "private_cases": []
    }
]