[
    {
        "name": "Strange Sort",
        "description": "You have a permutation: an array \n    a = [a_1, a_2, \n    \u2026, a_n]\n of\ndistinct integers from \n    1\n to \n    n\n. The length of the permutation\n\n    n\n is odd. Consider the following algorithm of sorting the permutation in\nincreasing order. A helper procedure of the algorithm, \n    f(i)\n, takes a\nsingle argument \n    i\n (\n    1 \n    \u2264 i \n    \u2264 n-1\n) and does the following. If\n\n    a_i > a_i+1\n, the values of \n    a_i\n and \n    a_i+1\n are exchanged.\nOtherwise, the permutation doesn't change. The algorithm consists of\niterations, numbered with consecutive integers starting with \n    1\n. On the\n\n    i\n-th iteration, the algorithm does the following: if \n    i\n is odd,\ncall \n    f(1), f(3), \n    \u2026, f(n - 2)\n; if \n    i\n is even, call \n    f(2),\n    f(4), \n    \u2026, f(n - 1)\n. It can be proven that after a finite number of\niterations the permutation will be sorted in increasing order. After how many\niterations will this happen for the first time? Input Each test contains\nmultiple test cases. The first line contains the number of test cases \n    t\n\n(\n    1 \n    \u2264 t \n    \u2264 10^4\n). Description of the test cases follows. The first\nline of each test case contains a single integer \n    n\n (\n    3 \n    \u2264 n \n    \u2264 2\n    \n    \u00b7 10^5 - 1\n; \n    n\n is odd) \u2014 the length of the permutation. The\nsecond line contains \n    n\n distinct integers \n    a_1, a_2, \n    \u2026, a_n\n\n(\n    1 \n    \u2264 a_i \n    \u2264 n\n) \u2014 the permutation itself. It is guaranteed that\nthe sum of \n    n\n over all test cases does not exceed \n    2 \n    \u00b7 10^5 -\n    1\n. Output For each test case print the number of iterations after which the\npermutation will become sorted in increasing order for the first time. If the\ngiven permutation is already sorted, print \n    0\n. Example Input 3 3 3 2 1 7\n4 5 7 1 3 2 6 5 1 2 3 4 5 Output 3 5 0 Note In the first test case, the\npermutation will be changing as follows: after the \n    1\n-st iteration:\n\n    [2, 3, 1]\n; after the \n    2\n-nd iteration: \n    [2, 1, 3]\n; after the\n\n    3\n-rd iteration: \n    [1, 2, 3]\n. In the second test case, the\npermutation will be changing as follows: after the \n    1\n-st iteration:\n\n    [4, 5, 1, 7, 2, 3, 6]\n; after the \n    2\n-nd iteration: \n    [4, 1, 5, 2,\n    7, 3, 6]\n; after the \n    3\n-rd iteration: \n    [1, 4, 2, 5, 3, 7, 6]\n;\nafter the \n    4\n-th iteration: \n    [1, 2, 4, 3, 5, 6, 7]\n; after the\n\n    5\n-th iteration: \n    [1, 2, 3, 4, 5, 6, 7]\n. In the third test case, the\npermutation is already sorted and the answer is \n    0\n.\n\n",
        "cf_contest_id": 1558,
        "cf_index": "F",
        "cf_rating": 3300,
        "difficulty": 0,
        "cf_tags": [
            "data structures",
            "sortings"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 512.0,
        "public_cases": [
            [
                "3\r\n3\r\n3 2 1\r\n7\r\n4 5 7 1 3 2 6\r\n5\r\n1 2 3 4 5\r\n",
                "3\r\n5\r\n0\r\n"
            ]
        ],
        "private_cases": []
    }
]