[
    {
        "name": "Decryption",
        "description": "An agent called Cypher is decrypting a message, that contains a composite\nnumber \n    n\n. All divisors of \n    n\n, which are greater than \n    1\n, are\nplaced in a circle. Cypher can choose the initial order of numbers in the\ncircle. In one move Cypher can choose two adjacent numbers in a circle and\ninsert their least common multiple between them. He can do that move as many\ntimes as needed. A message is decrypted, if every two adjacent numbers are not\ncoprime. Note that for such constraints it's always possible to decrypt the\nmessage. Find the minimal number of moves that Cypher should do to decrypt the\nmessage, and show the initial order of numbers in the circle for that. Input\nThe first line contains an integer \n    t\n \n    (1 \n    \u2264 t \n    \u2264 100)\n \u2014 the\nnumber of test cases. Next \n    t\n lines describe each test case. In a single\nline of each test case description, there is a single composite number \n    n\n\n\n    (4 \n    \u2264 n \n    \u2264 10^9)\n \u2014 the number from the message. It's guaranteed\nthat the total number of divisors of \n    n\n for all test cases does not\nexceed \n    2 \n    \u00b7 10^5\n. Output For each test case in the first line\noutput the initial order of divisors, which are greater than \n    1\n, in the\ncircle. In the second line output, the minimal number of moves needed to\ndecrypt the message. If there are different possible orders with a correct\nanswer, print any of them. Example Input 3 6 4 30 Output 2 3 6 1 2 4 0 2 30 6\n3 15 5 10 0 Note In the first test case \n    6\n has three divisors, which are\ngreater than \n    1\n: \n    2, 3, 6\n. Regardless of the initial order, numbers\n\n    2\n and \n    3\n are adjacent, so it's needed to place their least common\nmultiple between them. After that the circle becomes \n    2, 6, 3, 6\n, and\nevery two adjacent numbers are not coprime. In the second test case \n    4\n\nhas two divisors greater than \n    1\n: \n    2, 4\n, and they are not coprime,\nso any initial order is correct, and it's not needed to place any least common\nmultiples. In the third test case all divisors of \n    30\n greater than\n\n    1\n can be placed in some order so that there are no two adjacent numbers\nthat are coprime.\n\n",
        "cf_contest_id": 1419,
        "cf_index": "E",
        "cf_rating": 2100,
        "difficulty": 0,
        "cf_tags": [
            "constructive algorithms",
            "implementation",
            "math",
            "number theory"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "3\r\n6\r\n4\r\n30\r\n",
                "2 6 3 \r\n1\r\n4 2 \r\n0\r\n30 2 6 3 15 5 10 \r\n0\r\n"
            ]
        ],
        "private_cases": [
            [
                "1\r\n18\r\n",
                "18 2 6 3 9 \r\n0\r\n"
            ]
        ]
    }
]