[
    {
        "name": "Flying Sort (Hard Version)",
        "description": "This is a hard version of the problem. In this version, the given array can\ncontain equal elements and the constraints on \n    n\n are greater than in the\neasy version of the problem. You are given an array \n    a\n of \n    n\n\nintegers (the given array can contain equal elements). You can perform the\nfollowing operations on array elements: choose any index \n    i\n (\n    1 \n    \u2264 i\n    \n    \u2264 n\n) and move the element \n    a[i]\n to the begin of the array; choose\nany index \n    i\n (\n    1 \n    \u2264 i \n    \u2264 n\n) and move the element \n    a[i]\n to\nthe end of the array. For example, if \n    n = 5\n, \n    a = [4, 7, 2, 2, 9]\n,\nthen the following sequence of operations can be performed: after performing\nthe operation of the first type to the second element, the array \n    a\n will\nbecome \n    [7, 4, 2, 2, 9]\n; after performing the operation of the second\ntype to the second element, the array \n    a\n will become \n    [7, 2, 2, 9,\n    4]\n. You can perform operations of any type any number of times in any\norder. Find the minimum total number of operations of the first and second\ntype that will make the \n    a\n array sorted in non-decreasing order. In other\nwords, what is the minimum number of operations must be performed so the array\nsatisfies the inequalities \n    a[1] \n    \u2264 a[2] \n    \u2264\n    \u2026\n    \u2264 a[n]\n.\nInput The first line contains a single integer \n    t\n (\n    1 \n    \u2264 t \n    \u2264\n    10^4\n) \u2014 the number of test cases in the test. Then \n    t\n test cases\nfollow. Each test case starts with a line containing an integer \n    n\n (\n    1\n    \n    \u2264 n \n    \u2264 2 \n    \u00b7 10^5\n) \u2014 the size of the array \n    a\n. Then follow\n\n    n\n integers \n    a_1, a_2, \n    \u2026, a_n\n (\n    0 \n    \u2264 a_i \n    \u2264 10^9\n)\n\u2014 an array that needs to be sorted by the given operations. The given array\ncan contain equal elements. The sum of \n    n\n for all test cases in one test\ndoes not exceed \n    2 \n    \u00b7 10^5\n. Output For each test case output one\ninteger \u2014 the minimum total number of operations of the first and second type,\nwhich will make the array sorted in non-decreasing order. Example Input 9 5 4\n7 2 2 9 5 3 5 8 1 7 5 1 2 2 4 5 2 0 1 3 0 1 0 4 0 1 0 0 4 0 1 0 1 4 0 1 0 2 20\n16 15 1 10 0 14 0 10 3 9 2 5 4 5 17 9 10 20 0 9 Output 2 2 0 0 1 1 1 1 16 Note\nIn the first test case, you first need to move two 2, to the beginning of the\narray. Therefore, the desired sequence of operations: \n    [4, 7, 2, 2, 9]\n    \n    \u2192 [2, 4, 7, 2, 9] \n    \u2192 [2, 2, 4, 7, 9]\n. In the second\ntest case, you need to move the 1 to the beginning of the array, and the 8 \u2014\nto the end. Therefore, the desired sequence of operations: \n    [3, 5, 8, 1, 7]\n    \n    \u2192 [1, 3, 5, 8, 7] \n    \u2192 [1, 3, 5, 7, 8]\n. In the third\ntest case, the array is already sorted.\n\n",
        "cf_contest_id": 1367,
        "cf_index": "F2",
        "cf_rating": 2400,
        "difficulty": 0,
        "cf_tags": [
            "binary search",
            "data structures",
            "dp",
            "greedy",
            "sortings",
            "two pointers"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "9\r\n5\r\n4 7 2 2 9\r\n5\r\n3 5 8 1 7\r\n5\r\n1 2 2 4 5\r\n2\r\n0 1\r\n3\r\n0 1 0\r\n4\r\n0 1 0 0\r\n4\r\n0 1 0 1\r\n4\r\n0 1 0 2\r\n20\r\n16 15 1 10 0 14 0 10 3 9 2 5 4 5 17 9 10 20 0 9\r\n",
                "2\r\n2\r\n0\r\n0\r\n1\r\n1\r\n1\r\n1\r\n16\r\n"
            ]
        ],
        "private_cases": []
    }
]