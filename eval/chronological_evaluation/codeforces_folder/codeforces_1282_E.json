[
    {
        "name": "The Cake Is a Lie",
        "description": "We are committed to the well being of all participants. Therefore, instead of\nthe problem, we suggest you enjoy a piece of cake. Uh oh. Somebody cut the\ncake. We told them to wait for you, but they did it anyway. There is still\nsome left, though, if you hurry back. Of course, before you taste the cake,\nyou thought about how the cake was cut. It is known that the cake was\noriginally a regular \n    n\n-sided polygon, each vertex of which had a unique\nnumber from \n    1\n to \n    n\n. The vertices were numbered in random order.\nEach piece of the cake is a triangle. The cake was cut into \n    n - 2\n pieces\nas follows: each time one cut was made with a knife (from one vertex to\nanother) such that exactly one triangular piece was separated from the current\ncake, and the rest continued to be a convex polygon. In other words, each time\nthree consecutive vertices of the polygon were selected and the corresponding\ntriangle was cut off. A possible process of cutting the cake is presented in\nthe picture below. Example of 6-sided cake slicing. You are given a set of\n\n    n-2\n triangular pieces in random order. The vertices of each piece are\ngiven in random order \u2014 clockwise or counterclockwise. Each piece is defined\nby three numbers \u2014 the numbers of the corresponding \n    n\n-sided cake\nvertices. For example, for the situation in the picture above, you could be\ngiven a set of pieces: \n    [3, 6, 5], [5, 2, 4], [5, 4, 6], [6, 3, 1]\n. You\nare interested in two questions. What was the enumeration of the \n    n\n-sided\ncake vertices? In what order were the pieces cut? Formally, you have to find\ntwo permutations \n    p_1, p_2, \n    \u2026, p_n\n (\n    1 \n    \u2264 p_i \n    \u2264 n\n) and\n\n    q_1, q_2, \n    \u2026, q_n - 2\n (\n    1 \n    \u2264 q_i \n    \u2264 n - 2\n) such that\nif the cake vertices are numbered with the numbers \n    p_1, p_2, \n    \u2026,\n    p_n\n in order clockwise or counterclockwise, then when cutting pieces of the\ncake in the order \n    q_1, q_2, \n    \u2026, q_n - 2\n always cuts off a\ntriangular piece so that the remaining part forms one convex polygon. For\nexample, in the picture above the answer permutations could be: \n    p=[2, 4, 6,\n    1, 3, 5]\n (or any of its cyclic shifts, or its reversal and after that any\ncyclic shift) and \n    q=[2, 4, 1, 3]\n. Write a program that, based on the\ngiven triangular pieces, finds any suitable permutations \n    p\n and \n    q\n.\nInput The first line contains a single integer \n    t\n (\n    1 \n    \u2264 t \n    \u2264\n    1000\n) \u2014 the number of test cases. Then there are \n    t\n independent sets\nof input data. The first line of each set consists of a single integer \n    n\n\n(\n    3 \n    \u2264 n \n    \u2264 10^5\n) \u2014 the number of vertices in the cake. The\nfollowing \n    n - 2\n lines describe the numbers of the pieces vertices: each\nline consists of three different integers \n    a, b, c\n (\n    1 \n    \u2264 a, b, c\n    \n    \u2264 n\n) \u2014 the numbers of the pieces vertices of cake given in random\norder. The pieces are given in random order. It is guaranteed that the answer\nto each of the tests exists. It is also guaranteed that the sum of \n    n\n for\nall test cases does not exceed \n    10^5\n. Output Print \n    2t\n lines \u2014\nanswers to given \n    t\n test cases in the order in which they are written in\nthe input. Each answer should consist of \n    2\n lines. In the first line of\nan answer on a test case print \n    n\n distinct numbers \n    p_1, p_2, \n    \u2026,\n    p_n\n(\n    1 \n    \u2264 p_i \n    \u2264 n\n) \u2014 the numbers of the cake vertices in\nclockwise or counterclockwise order. In the second line of an answer on a test\ncase print \n    n - 2\n distinct numbers \n    q_1, q_2, \n    \u2026, q_n -\n    2\n(\n    1 \n    \u2264 q_i \n    \u2264 n - 2\n) \u2014 the order of cutting pieces of the\ncake. The number of a piece of the cake corresponds to its number in the\ninput. If there are several answers, print any. It is guaranteed that the\nanswer to each of the tests exists. Example Input 3 6 3 6 5 5 2 4 5 4 6 6 3 1\n6 2 5 6 2 5 1 4 1 2 1 3 5 3 1 2 3 Output 1 6 4 2 5 3 4 2 3 1 1 4 2 6 5 3 3 4 2\n1 1 3 2 1\n\n",
        "cf_contest_id": 1282,
        "cf_index": "E",
        "cf_rating": 2400,
        "difficulty": 0,
        "cf_tags": [
            "constructive algorithms",
            "data structures",
            "dfs and similar",
            "graphs"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "3\r\n6\r\n3 6 5\r\n5 2 4\r\n5 4 6\r\n6 3 1\r\n6\r\n2 5 6\r\n2 5 1\r\n4 1 2\r\n1 3 5\r\n3\r\n1 2 3\r\n",
                "4 6 1 3 5 2 \r\n4 2 3 1 \r\n5 6 2 4 1 3 \r\n3 4 2 1 \r\n2 3 1 \r\n1 \r\n"
            ]
        ],
        "private_cases": []
    }
]