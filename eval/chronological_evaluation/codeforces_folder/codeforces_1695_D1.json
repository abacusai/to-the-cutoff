[
    {
        "name": "Tree Queries (Easy Version)",
        "description": "The only difference between this problem and D2 is the bound on the size of\nthe tree. You are given an unrooted tree with \n    n\n vertices. There is some\nhidden vertex \n    x\n in that tree that you are trying to find. To do this,\nyou may ask \n    k\n queries \n    v_1, v_2, \n    \u2026, v_k\n where the \n    v_i\n\nare vertices in the tree. After you are finished asking all of the queries,\nyou are given \n    k\n numbers \n    d_1, d_2, \n    \u2026, d_k\n, where \n    d_i\n\nis the number of edges on the shortest path between \n    v_i\n and \n    x\n.\nNote that you know which distance corresponds to which query. What is the\nminimum \n    k\n such that there exists some queries \n    v_1, v_2, \n    \u2026,\n    v_k\n that let you always uniquely identify \n    x\n (no matter what \n    x\n\nis). Note that you don't actually need to output these queries. Input Each\ntest contains multiple test cases. The first line contains the number of test\ncases \n    t\n (\n    1 \n    \u2264 t \n    \u2264 100\n). Description of the test cases\nfollows. The first line of each test case contains a single integer \n    n\n\n(\n    1 \n    \u2264 n \n    \u2264 2000\n) \u2014 the number of vertices in the tree. Each of the\nnext \n    n-1\n lines contains two integers \n    x\n and \n    y\n (\n    1 \n    \u2264 x,\n    y \n    \u2264 n\n), meaning there is an edges between vertices \n    x\n and \n    y\n\nin the tree. It is guaranteed that the given edges form a tree. It is\nguaranteed that the sum of \n    n\n over all test cases does not exceed\n\n    2000\n. Output For each test case print a single nonnegative integer, the\nminimum number of queries you need, on its own line. Example Input 3 1 2 1 2\n10 2 4 2 1 5 7 3 10 8 6 6 1 1 3 4 7 9 6 Output 0 1 2 Note In the first test\ncase, there is only one vertex, so you don't need any queries. In the second\ntest case, you can ask a single query about the node \n    1\n. Then, if \n    x =\n    1\n, you will get \n    0\n, otherwise you will get \n    1\n.\n\n",
        "cf_contest_id": 1695,
        "cf_index": "D1",
        "cf_rating": 2200,
        "difficulty": 0,
        "cf_tags": [
            "brute force",
            "constructive algorithms",
            "dfs and similar",
            "dp",
            "greedy",
            "trees"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "3\r\n1\r\n2\r\n1 2\r\n10\r\n2 4\r\n2 1\r\n5 7\r\n3 10\r\n8 6\r\n6 1\r\n1 3\r\n4 7\r\n9 6\r\n",
                "0\r\n1\r\n2\r\n"
            ]
        ],
        "private_cases": []
    }
]