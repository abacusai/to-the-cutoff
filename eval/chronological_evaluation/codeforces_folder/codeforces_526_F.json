[
    {
        "name": "Pudding Monsters",
        "description": "In this problem you will meet the simplified model of game Pudding Monsters.\nAn important process in developing any game is creating levels. A game field\nin Pudding Monsters is an n \u00d7 n rectangular grid, n of its cells contain\nmonsters and some other cells contain game objects. The gameplay is about\nmoving the monsters around the field. When two monsters are touching each\nother, they glue together into a single big one (as they are from pudding,\nremember?). Statistics showed that the most interesting maps appear if\ninitially each row and each column contains exactly one monster and the rest\nof map specifics is set up by the correct positioning of the other game\nobjects. A technique that's widely used to make the development process more\nefficient is reusing the available resources. For example, if there is a large\nn \u00d7 n map, you can choose in it a smaller k \u00d7 k square part, containing\nexactly k monsters and suggest it as a simplified version of the original map.\nYou wonder how many ways there are to choose in the initial map a k \u00d7 k (1 \u2264 k\n\u2264 n) square fragment, containing exactly k pudding monsters. Calculate this\nnumber. Input The first line contains a single integer n (1 \u2264 n \u2264 3 \u00d7 10^5) \u2014\nthe size of the initial field. Next n lines contain the coordinates of the\ncells initially containing monsters. The i-th of the next lines contains two\nnumbers ri, ci (1 \u2264 ri, ci \u2264 n) \u2014 the row number and the column number of the\ncell that initially contains the i-th monster. It is guaranteed that all ri\nare distinct numbers and all ci are distinct numbers. Output Print the number\nof distinct square fragments of the original field that can form a new map.\nExamples Input 5 1 1 4 3 3 2 2 4 5 5 Output 10\n\n",
        "cf_contest_id": 526,
        "cf_index": "F",
        "cf_rating": 3000,
        "difficulty": 0,
        "cf_tags": [
            "data structures",
            "divide and conquer"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "5\r\n1 1\r\n4 3\r\n3 2\r\n2 4\r\n5 5\r\n",
                "10\r\n"
            ]
        ],
        "private_cases": [
            [
                "7\r\n1 4\r\n2 3\r\n3 1\r\n4 6\r\n5 2\r\n6 5\r\n7 7\r\n",
                "10\r\n"
            ],
            [
                "10\r\n1 1\r\n2 2\r\n3 3\r\n4 6\r\n5 4\r\n6 5\r\n7 9\r\n8 7\r\n9 8\r\n10 10\r\n",
                "29\r\n"
            ],
            [
                "10\r\n1 4\r\n2 2\r\n3 9\r\n4 1\r\n5 5\r\n6 3\r\n7 7\r\n8 8\r\n9 6\r\n10 10\r\n",
                "14\r\n"
            ],
            [
                "23\r\n1 9\r\n2 17\r\n3 18\r\n4 8\r\n5 19\r\n6 5\r\n7 6\r\n8 20\r\n9 15\r\n10 21\r\n11 2\r\n12 16\r\n13 11\r\n14 22\r\n15 7\r\n16 3\r\n17 12\r\n18 13\r\n19 1\r\n20 14\r\n21 10\r\n22 23\r\n23 4\r\n",
                "27\r\n"
            ],
            [
                "10\r\n1 4\r\n2 9\r\n3 5\r\n4 1\r\n5 7\r\n6 8\r\n7 10\r\n8 2\r\n9 6\r\n10 3\r\n",
                "12\r\n"
            ]
        ]
    }
]