[
    {
        "name": "Elimination of a Ring",
        "description": "Define a cyclic sequence of size \n    n\n as an array \n    s\n of length\n\n    n\n, in which \n    s_n\n is adjacent to \n    s_1\n. Muxii has a ring\nrepresented by a cyclic sequence \n    a\n of size \n    n\n. However, the ring\nitself hates equal adjacent elements. So if two adjacent elements in the\nsequence are equal at any time, one of them will be erased immediately. The\nsequence doesn't contain equal adjacent elements initially. Muxii can perform\nthe following operation until the sequence becomes empty: Choose an element in\n\n    a\n and erase it. For example, if ring is \n    [1, 2, 4, 2, 3, 2]\n, and\nMuxii erases element \n    4\n, then ring would erase one of the elements equal\nto \n    2\n, and the ring will become \n    [1, 2, 3, 2]\n. Muxii wants to find\nthe maximum number of operations he could perform. Note that in a ring of size\n\n    1\n, its only element isn't considered adjacent to itself (so it's not\nimmediately erased). Input Each test contains multiple test cases. The first\nline contains a single integer \n    t\n (\n    1\n    \u2264 t\n    \u2264 100\n) \u2014 the\nnumber of test cases. The description of test cases follows. The first line of\neach test case contains a single integer \n    n\n (\n    1\n    \u2264 n\n    \u2264 100\n) \u2014\nthe size of the cyclic sequence. The second line of each test case contains\n\n    n\n integers \n    a_1,a_2,\n    \u2026,a_n\n (\n    1\n    \u2264 a_i\n    \u2264 n\n) \u2014 the\nsequence itself. It's guaranteed that \n    a_i\n     a_i+1\n for \n    1\n    \u2264\n    i1\n. Output For each test case, output a single integer \u2014 the maximum number\nof operations Muxii can perform. Example Input 3 4 1 2 3 2 4 1 2 1 2 1 1\nOutput 4 3 1 Note In the first test case, you can erase the second element\nfirst, then erase the remaining elements one by one in any order. In total,\nyou can perform the operation \n    4\n times. Note that if you erase the first\nelement first, then the sequence will be turned into \n    [2,3,2]\n and then\nimmediately become \n    [2,3]\n. In the second test case, you can erase the\nfirst element first, then the sequence becomes \n    [2,1]\n. Then you can erase\nall remaining elements one by one in any order.\n\n",
        "cf_contest_id": 1761,
        "cf_index": "B",
        "cf_rating": 1000,
        "difficulty": 0,
        "cf_tags": [
            "constructive algorithms",
            "greedy",
            "implementation"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "3\r\n4\r\n1 2 3 2\r\n4\r\n1 2 1 2\r\n1\r\n1\r\n",
                "4\r\n3\r\n1\r\n"
            ]
        ],
        "private_cases": [
            [
                "1\r\n100\r\n60 76 89 77 41 81 42 49 39 37 48 56 26 38 85 50 40 13 20 24 79 21 22 9 92 11 45 58 55 62 69 82 97 67 18 32 88 84 19 96 7 36 83 95 52 98 44 53 12 75 90 87 28 3 1 6 15 65 68 94 30 99 78 63 46 86 47 73 72 66 74 80 35 70 51 33 16 93 34 10 23 71 17 5 2 64 43 100 29 8 27 31 14 25 59 54 4 57 61 91\r\n",
                "100\r\n"
            ],
            [
                "1\r\n10\r\n1 2 1 2 1 3 1 3 1 3\r\n",
                "10\r\n"
            ],
            [
                "1\r\n7\r\n3 1 2 1 2 1 2\r\n",
                "7\r\n"
            ],
            [
                "1\r\n100\r\n1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 100\r\n",
                "100\r\n"
            ]
        ]
    }
]