[
    {
        "name": "Ehab and Path-etic MEXs",
        "description": "You are given a tree consisting of \n    n\n nodes. You want to write some\nlabels on the tree's edges such that the following conditions hold: Every\nlabel is an integer between \n    0\n and \n    n-2\n inclusive. All the written\nlabels are distinct. The largest value among \n    MEX(u,v)\n over all pairs of\nnodes \n    (u,v)\n is as small as possible. Here, \n    MEX(u,v)\n denotes the\nsmallest non-negative integer that isn't written on any edge on the unique\nsimple path from node \n    u\n to node \n    v\n. Input The first line contains\nthe integer \n    n\n (\n    2 \n    \u2264 n \n    \u2264 10^5\n) \u2014 the number of nodes in the\ntree. Each of the next \n    n-1\n lines contains two space-separated integers\n\n    u\n and \n    v\n (\n    1 \n    \u2264 u,v \n    \u2264 n\n) that mean there's an edge\nbetween nodes \n    u\n and \n    v\n. It's guaranteed that the given graph is a\ntree. Output Output \n    n-1\n integers. The \n    i^th\n of them will be the\nnumber written on the \n    i^th\n edge (in the input order). Examples Input 3\n1 2 1 3 Output 0 1 Input 6 1 2 1 3 2 4 2 5 5 6 Output 0 3 2 4 1 Note The tree\nfrom the second sample:\n\n",
        "cf_contest_id": 1325,
        "cf_index": "C",
        "cf_rating": 1500,
        "difficulty": 0,
        "cf_tags": [
            "constructive algorithms",
            "dfs and similar",
            "greedy",
            "trees"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "3\r\n1 2\r\n1 3\r\n",
                "0\r\n1\r\n"
            ],
            [
                "6\r\n1 2\r\n1 3\r\n2 4\r\n2 5\r\n5 6\r\n",
                "4\r\n0\r\n1\r\n3\r\n2\r\n"
            ]
        ],
        "private_cases": [
            [
                "7\r\n3 2\r\n5 7\r\n4 2\r\n7 6\r\n6 3\r\n1 6\r\n",
                "5\r\n0\r\n1\r\n4\r\n3\r\n2\r\n"
            ],
            [
                "7\r\n5 6\r\n2 6\r\n6 4\r\n6 1\r\n6 3\r\n6 7\r\n",
                "0\r\n1\r\n2\r\n3\r\n4\r\n5\r\n"
            ],
            [
                "7\r\n2 1\r\n4 7\r\n2 3\r\n6 4\r\n7 3\r\n1 5\r\n",
                "5\r\n4\r\n3\r\n0\r\n2\r\n1\r\n"
            ],
            [
                "7\r\n6 4\r\n3 7\r\n3 5\r\n1 3\r\n4 2\r\n7 4\r\n",
                "0\r\n5\r\n1\r\n2\r\n3\r\n4\r\n"
            ],
            [
                "4\r\n2 3\r\n2 4\r\n2 1\r\n",
                "0\r\n1\r\n2\r\n"
            ],
            [
                "5\r\n1 3\r\n4 3\r\n2 5\r\n3 2\r\n",
                "0\r\n1\r\n2\r\n3\r\n"
            ],
            [
                "2\r\n1 2\r\n",
                "0\r\n"
            ],
            [
                "2\r\n2 1\r\n",
                "0\r\n"
            ],
            [
                "6\r\n1 2\r\n2 3\r\n3 4\r\n3 5\r\n3 6\r\n",
                "0\r\n4\r\n1\r\n2\r\n3\r\n"
            ],
            [
                "13\r\n1 4\r\n2 4\r\n3 4\r\n4 5\r\n5 11\r\n11 12\r\n12 13\r\n13 6\r\n6 7\r\n7 8\r\n7 9\r\n7 10\r\n",
                "0\r\n1\r\n2\r\n11\r\n10\r\n9\r\n8\r\n7\r\n6\r\n3\r\n4\r\n5\r\n"
            ],
            [
                "11\r\n2 3\r\n3 4\r\n4 7\r\n7 8\r\n1 3\r\n3 5\r\n4 10\r\n4 11\r\n6 7\r\n7 9\r\n",
                "0\r\n9\r\n8\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n"
            ]
        ]
    }
]