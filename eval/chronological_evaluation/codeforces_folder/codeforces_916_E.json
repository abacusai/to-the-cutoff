[
    {
        "name": "Jamie and Tree",
        "description": "To your surprise, Jamie is the final boss! Ehehehe. Jamie has given you a tree\nwith n vertices, numbered from 1 to n. Initially, the root of the tree is the\nvertex with number 1. Also, each vertex has a value on it. Jamie also gives\nyou three types of queries on the tree: 1 v \u2014 Change the tree's root to vertex\nwith number v. 2 u v x \u2014 For each vertex in the subtree of smallest size that\ncontains u and v, add x to its value. 3 v \u2014 Find sum of values of vertices in\nthe subtree of vertex with number v. A subtree of vertex v is a set of\nvertices such that v lies on shortest path from this vertex to root of the\ntree. Pay attention that subtree of a vertex can change after changing the\ntree's root. Show your strength in programming to Jamie by performing the\nqueries accurately! Input The first line of input contains two space-separated\nintegers n and q (1 \u2264 n \u2264 10^5, 1 \u2264 q \u2264 10^5) \u2014 the number of vertices in the\ntree and the number of queries to process respectively. The second line\ncontains n space-separated integers a1, a2, ..., an ( - 10^8 \u2264 ai \u2264 10^8) \u2014\ninitial values of the vertices. Next n - 1 lines contains two space-separated\nintegers ui, vi (1 \u2264 ui, vi \u2264 n) describing edge between vertices ui and vi in\nthe tree. The following q lines describe the queries. Each query has one of\nfollowing formats depending on its type: 1 v (1 \u2264 v \u2264 n) for queries of the\nfirst type. 2 u v x (1 \u2264 u, v \u2264 n, - 10^8 \u2264 x \u2264 10^8) for queries of the\nsecond type. 3 v (1 \u2264 v \u2264 n) for queries of the third type. All numbers in\nqueries' descriptions are integers. The queries must be carried out in the\ngiven order. It is guaranteed that the tree is valid. Output For each query of\nthe third type, output the required answer. It is guaranteed that at least one\nquery of the third type is given by Jamie. Examples Input 6 7 1 4 2 8 5 7 1 2\n3 1 4 3 4 5 3 6 3 1 2 4 6 3 3 4 1 6 2 2 4 -5 1 4 3 3 Output 27 19 5 Input 4 6\n4 3 5 6 1 2 2 3 3 4 3 1 1 3 2 2 4 3 1 1 2 2 4 -3 3 1 Output 18 21 Note The\nfollowing picture shows how the tree varies after the queries in the first\nsample.\n\n",
        "cf_contest_id": 916,
        "cf_index": "E",
        "cf_rating": 2400,
        "difficulty": 0,
        "cf_tags": [
            "data structures",
            "trees"
        ],
        "time_limit_seconds": 2.5,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "6 7\r\n1 4 2 8 5 7\r\n1 2\r\n3 1\r\n4 3\r\n4 5\r\n3 6\r\n3 1\r\n2 4 6 3\r\n3 4\r\n1 6\r\n2 2 4 -5\r\n1 4\r\n3 3\r\n",
                "27\r\n19\r\n5\r\n"
            ],
            [
                "4 6\r\n4 3 5 6\r\n1 2\r\n2 3\r\n3 4\r\n3 1\r\n1 3\r\n2 2 4 3\r\n1 1\r\n2 2 4 -3\r\n3 1\r\n",
                "18\r\n21\r\n"
            ]
        ],
        "private_cases": [
            [
                "20 20\r\n-139 -129 -800 -61 -150 340 545 533 -399 -620 829 -686 -826 623 -83 265 214 629 683 -455\r\n6 11\r\n15 16\r\n12 13\r\n1 10\r\n3 18\r\n1 15\r\n8 14\r\n1 18\r\n15 2\r\n8 1\r\n8 5\r\n20 4\r\n11 19\r\n10 17\r\n9 18\r\n1 11\r\n8 20\r\n7 17\r\n5 13\r\n1 12\r\n1 8\r\n1 2\r\n1 10\r\n1 11\r\n3 9\r\n2 12 10 980\r\n1 1\r\n2 11 9 38\r\n2 1 16 -899\r\n1 3\r\n1 5\r\n1 10\r\n2 18 7 959\r\n1 18\r\n1 9\r\n2 11 20 -345\r\n3 1\r\n3 11\r\n3 7\r\n",
                "-399\r\n10404\r\n1111\r\n1278\r\n"
            ]
        ]
    }
]