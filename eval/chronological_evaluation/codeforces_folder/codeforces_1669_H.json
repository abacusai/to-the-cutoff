[
    {
        "name": "Maximal AND",
        "description": "Let \n    \ud835\udda0\ud835\uddad\ud835\udda3\n denote the bitwise AND operation, and\n\n    \ud835\uddae\ud835\uddb1\n denote the bitwise OR operation. You are given an array\n\n    a\n of length \n    n\n and a non-negative integer \n    k\n. You can perform\nat most \n    k\n operations on the array of the following type: Select an index\n\n    i\n (\n    1 \n    \u2264 i \n    \u2264 n\n) and replace \n    a_i\n with \n    a_i\n\n\n    \ud835\uddae\ud835\uddb1\n \n    2^j\n where \n    j\n is any integer between \n    0\n and\n\n    30\n inclusive. In other words, in an operation you can choose an index\n\n    i\n (\n    1 \n    \u2264 i \n    \u2264 n\n) and set the \n    j\n-th bit of \n    a_i\n to\n\n    1\n (\n    0 \n    \u2264 j \n    \u2264 30\n). Output the maximum possible value of\n\n    a_1\n \n    \ud835\udda0\ud835\uddad\ud835\udda3\n \n    a_2\n \n    \ud835\udda0\ud835\uddad\ud835\udda3\n \n    \u2026\n\n\n    \ud835\udda0\ud835\uddad\ud835\udda3\n \n    a_n\n after performing at most \n    k\n operations.\nInput The first line of the input contains a single integer \n    t\n (\n    1\n    \n    \u2264 t \n    \u2264 100\n) \u2014 the number of test cases. The description of test\ncases follows. The first line of each test case contains the integers \n    n\n\nand \n    k\n (\n    1 \n    \u2264 n \n    \u2264 2 \n    \u00b7 10^5\n, \n    0 \n    \u2264 k \n    \u2264\n    10^9\n). Then a single line follows, containing \n    n\n integers describing\nthe arrays \n    a\n (\n    0 \n    \u2264 a_i < 2^31\n). It is guaranteed that the\nsum of \n    n\n over all test cases does not exceed \n    2 \n    \u00b7 10^5\n.\nOutput For each test case, output a single line containing the maximum\npossible \n    \ud835\udda0\ud835\uddad\ud835\udda3\n value of \n    a_1\n \n    \ud835\udda0\ud835\uddad\ud835\udda3\n\n\n    a_2\n \n    \ud835\udda0\ud835\uddad\ud835\udda3\n \n    \u2026\n \n    \ud835\udda0\ud835\uddad\ud835\udda3\n \n    a_n\n\nafter performing at most \n    k\n operations. Example Input 4 3 2 2 1 1 7 0 4 6\n6 28 6 6 12 1 30 0 4 4 3 1 3 1 Output 2 4 2147483646 1073741825 Note For the\nfirst test case, we can set the bit \n    1\n (\n    2^1\n) of the last \n    2\n\nelements using the \n    2\n operations, thus obtaining the array [\n    2\n,\n\n    3\n, \n    3\n], which has \n    \ud835\udda0\ud835\uddad\ud835\udda3\n value equal to \n    2\n. For\nthe second test case, we can't perform any operations so the answer is just\nthe \n    \ud835\udda0\ud835\uddad\ud835\udda3\n of the whole array which is \n    4\n.\n\n",
        "cf_contest_id": 1669,
        "cf_index": "H",
        "cf_rating": 1300,
        "difficulty": 0,
        "cf_tags": [
            "bitmasks",
            "greedy",
            "math"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "4\r\n3 2\r\n2 1 1\r\n7 0\r\n4 6 6 28 6 6 12\r\n1 30\r\n0\r\n4 4\r\n3 1 3 1\r\n",
                "2\r\n4\r\n2147483646\r\n1073741825\r\n"
            ]
        ],
        "private_cases": []
    }
]