[
    {
        "name": "Find a Gift",
        "description": "This is an interactive problem. Don't forget to flush output after printing\nqueries using cout.flush() or fflush(stdout) in C++ or similar functions in\nother programming languages. There are \n    n\n gift boxes in a row, numbered\nfrom \n    1\n to \n    n\n from left to right. It's known that exactly \n    k\n of\nthem contain valuable gifts \u2014 other boxes contain just lucky stones. All boxes\nlook the same and differ only in weight. All boxes with stones have the same\nweight and are strictly heavier than boxes with valuable items. But valuable\ngifts may be different, so the boxes with valuable items may have different\nweights. You can ask no more than \n    50\n queries (printing an answer doesn't\ncount). By each query you can compare total weights of two non-intersecting\nsubsets of boxes \n    a_1, a_2, \n    \u2026, a_k_a\n and \n    b_1, b_2, \n    \u2026,\n    b_k_b\n. In return you'll get one of four results: FIRST, if subset \n    a_1,\n    a_2, \n    \u2026, a_k_a\n is strictly heavier; SECOND, if subset \n    b_1, b_2,\n    \n    \u2026, b_k_b\n is strictly heavier; EQUAL, if subsets have equal total\nweights; WASTED, if the query is incorrect or the limit of queries is\nexceeded. Using such queries (or, maybe, intuition) find the box with a\nvaluable gift with the minimum index. Input The input consists of several\ncases. In the beginning, you receive the integer \n    T\n (\n    1 \n    \u2264 T \n    \u2264\n    500\n) \u2014 the number of test cases. At the beginning of each test case, you\nreceive two integers \n    n\n and \n    k\n (\n    2 \n    \u2264 n \n    \u2264 1000\n, \n    1\n    \n    \u2264 k \n    \u2264\n    n/2\n) \u2014 the number of boxes in a row and the number\nof boxes with valuable gifts. It's guaranteed that the order of boxes is fixed\nbeforehand and that the sum of \n    n\n in one test doesn't exceed \n    1000\n.\nOutput For each test case print the minimum index among all boxes with a\nvaluable gift in the following format: \"! \n    x\n\" where \n    x\n (\n    1 \n    \u2264 x\n    \n    \u2264 n\n) \u2014 the index of the box. Interaction Print each query in three\nlines. In the first line print the sizes of subset in the following format: \"?\n\n    k_a\n \n    k_b\n\" where \n    k_a\n and \n    k_b\n (\n    1 \n    \u2264 k_a, k_b \n    \u2264\n    n\n; \n    k_a + k_b \n    \u2264 n\n) \u2014 the corresponding sizes. In the second line\nprint \n    k_a\n integers \n    a_1, a_2, \n    \u2026, a_k_a\n (\n    1 \n    \u2264 a_i\n    \n    \u2264 n\n; \n    a_i \n    \u2260 a_j\n if \n    i \n    \u2260 j\n) \u2014 indexes of boxes in\nthe first subset. In the third line print \n    k_b\n integers \n    b_1, b_2,\n    \n    \u2026, b_k_b\n (\n    1 \n    \u2264 b_i \n    \u2264 n\n; \n    b_i \n    \u2260 b_j\n if \n    i\n    \n    \u2260 j\n) \u2014 indexes of boxes in the second subset. The subsets shouldn't\nintersect, i. e. \n    a_i \n    \u2260 b_j\n for all \n    i\n and \n    j\n. You'll\nreceive one of four responses described above. In the case of WASTED stop your\nprogram to avoid getting random verdict instead of Wrong Answer. Example Input\n2 2 1 \u00ad \u00ad \u00ad FIRST \u00ad 5 2 \u00ad \u00ad \u00ad FIRST \u00ad \u00ad \u00ad SECOND \u00ad \u00ad \u00ad EQUAL \u00ad\nOutput \u00ad \u00ad ? 1 1 1 2 \u00ad ! 2 \u00ad ? 1 1 1 2 \u00ad ? 2 3 4 2 1 3 5 \u00ad ? 1 1 4 5 \u00ad\n! 1 Note Additional separators \"\u2013\" in the sample are used only to increase the\nreadability of the sample. Don't print any unnecessary symbols or line breaks\nin your solution when you send it to the system. Hacks are forbidden in this\ntask.\n\n",
        "cf_contest_id": 1354,
        "cf_index": "G",
        "cf_rating": 2600,
        "difficulty": 0,
        "cf_tags": [
            "binary search",
            "interactive",
            "probabilities"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "2\r\n2 1\r\n100 1\r\n5 2\r\n99 98 100 100 100\r\n",
                "2\r\n1\r\n"
            ]
        ],
        "private_cases": []
    }
]