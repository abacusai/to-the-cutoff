[
    {
        "name": "Bugaboo",
        "description": "A transformation of an array of positive integers \n    a_1,a_2,\n    \u2026,a_n\n is\ndefined by replacing \n    a\n with the array \n    b_1,b_2,\n    \u2026,b_n\n given by\n\n    b_i=a_i\n    \u2295 a_(i\n     n)+1\n, where \n    \u2295\n denotes the\nbitwise XOR operation. You are given integers \n    n\n, \n    t\n, and \n    w\n.\nWe consider an array \n    c_1,c_2,\n    \u2026,c_n\n (\n    0 \n    \u2264 c_i \n    \u2264 2^w-1\n)\nto be bugaboo if and only if there exists an array \n    a_1,a_2,\n    \u2026,a_n\n\nsuch that after transforming \n    a\n for \n    t\n times, \n    a\n becomes\n\n    c\n. For example, when \n    n=6\n, \n    t=2\n, \n    w=2\n, then the array\n\n    [3,2,1,0,2,2]\n is bugaboo because it can be given by transforming the\narray \n    [2,3,1,1,0,1]\n for \n    2\n times: \n    \n\n    [2,3,1,1,0,1]\n    \u2192\n    [2\n    \u2295 3,3\n    \u2295 1,1\n    \u2295 1,1\n    \u2295 0,0\n    \u2295 1,1\n    \u2295\n    2]=[1,2,0,1,1,3]; \n    \n    \n     [1,2,0,1,1,3]\n    \u2192 [1\n    \u2295 2,2\n    \u2295\n    0,0\n    \u2295 1,1\n    \u2295 1,1\n    \u2295 3,3\n    \u2295 1]=[3,2,1,0,2,2].\n\n    \n And\nthe array \n    [4,4,4,4,0,0]\n is not bugaboo because \n    4 > 2^2 - 1\n. The\narray \n    [2,3,3,3,3,3]\n is also not bugaboo because it can't be given by\ntransforming one array for \n    2\n times. You are given an array \n    c\n with\nsome positions lost (only \n    m\n positions are known at first and the\nremaining positions are lost). And there are \n    q\n modifications, where each\nmodification is changing a position of \n    c\n. A modification can possibly\nchange whether the position is lost or known, and it can possibly redefine a\nposition that is already given. You need to calculate how many possible arrays\n\n    c\n (with arbitrary elements on the lost positions) are bugaboos after\neach modification. Output the \n    i\n-th answer modulo \n    p_i\n (\n    p_i\n is\na given array consisting of \n    q\n elements). Input The first line contains\nfour integers \n    n\n, \n    m\n, \n    t\n and \n    w\n (\n    2\n    \u2264 n\n    \u2264 10^7\n,\n\n    0\n    \u2264 m\n    \u2264\n    min(n, 10^5)\n, \n    1\n    \u2264 t\n    \u2264 10^9\n, \n    1\n    \u2264\n    w\n    \u2264 30\n). The \n    i\n-th line of the following \n    m\n lines contains two\nintegers \n    d_i\n and \n    e_i\n (\n    1\n    \u2264 d_i\n    \u2264 n\n, \n    0\n    \u2264 e_i<\n    2^w\n). It means the position \n    d_i\n of the array \n    c\n is given and\n\n    c_d_i=e_i\n. It is guaranteed that \n    1\n    \u2264 d_1<d_2<\n    \u2026<d_m\n    \u2264\n    n\n. The next line contains only one number \n    q\n (\n    1\n    \u2264 q\n    \u2264\n    10^5\n) \u2014 the number of modifications. The \n    i\n-th line of the following\n\n    q\n lines contains three integers \n    f_i\n, \n    g_i\n, \n    p_i\n\n(\n    1\n    \u2264 f_i\n    \u2264 n\n, \n    -1\n    \u2264 g_i< 2^w\n, \n    11\n    \u2264 p_i\n    \u2264\n    10^9+7\n). The value \n    g_i=-1\n means changing the position \n    f_i\n of\nthe array \n    c\n to a lost position, otherwise it means changing the position\n\n    f_i\n of the array \n    c\n to a known position, and \n    c_f_i=g_i\n. The\nvalue \n    p_i\n means you need to output the \n    i\n-th answer modulo\n\n    p_i\n. Output The output contains \n    q\n lines, denoting your answers.\nExamples Input 3 2 1 1 1 1 3 1 4 2 0 123456789 2 1 111111111 1 -1 987654321 3\n-1 555555555 Output 1 0 1 2 Input 24 8 5 4 4 4 6 12 8 12 15 11 16 7 20 2 21 9\n22 12 13 2 13 11 3 15 12 5 7 13 9 3 14 10 5 15 11 15 16 13 14 17 14 1 18 18 9\n19 19 6 20 23 10 21 24 8 22 21 13 23 Output 1 4 9 2 1 0 1 10 11 16 16 0 16\nNote In the first example, \n    n=3\n, \n    t=1\n, and \n    w=1\n. Let \n    ?\n\ndenote a lost position of \n    c\n. In the first query, \n    c=[1,0,1]\n. The\nonly possible array \n    [1,0,1]\n is bugaboo because it can be given by\ntransforming \n    [0,1,1]\n once. So the answer is \n    1\n    \n    123\n     456\n     789 = 1\n. In the second query, \n    c=[1,1,1]\n. The only\npossible array \n    [1,1,1]\n is not bugaboo. So the answer is \n    0\n    \n    111\n     111\n     111 = 0\n. In the third query, \n    c=[?,1,1]\n. There are two\npossible arrays \n    [1,1,1]\n and \n    [0,1,1]\n. Only \n    [0,1,1]\n is bugaboo\nbecause it can be given by transforming \n    [1,1,0]\n once. So the answer is\n\n    1\n     987\n     654\n     321=1\n. In the fourth query, \n    c=[?,1,?]\n.\nThere are four possible arrays. \n    [0,1,1]\n and \n    [1,1,0]\n are bugaboos.\n\n    [1,1,0]\n can be given by performing \n    [1,0,1]\n once. So the answer is\n\n    2\n     555\n     555\n     555=2\n.\n\n",
        "cf_contest_id": 1707,
        "cf_index": "F",
        "cf_rating": 3500,
        "difficulty": 0,
        "cf_tags": [
            "bitmasks",
            "constructive algorithms",
            "dp",
            "number theory"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 1024.0,
        "public_cases": [
            [
                "3 2 1 1\r\n1 1\r\n3 1\r\n4\r\n2 0 123456789\r\n2 1 111111111\r\n1 -1 987654321\r\n3 -1 555555555\r\n",
                "1\r\n0\r\n1\r\n2\r\n"
            ],
            [
                "24 8 5 4\r\n4 4\r\n6 12\r\n8 12\r\n15 11\r\n16 7\r\n20 2\r\n21 9\r\n22 12\r\n13\r\n2 13 11\r\n3 15 12\r\n5 7 13\r\n9 3 14\r\n10 5 15\r\n11 15 16\r\n13 14 17\r\n14 1 18\r\n18 9 19\r\n19 6 20\r\n23 10 21\r\n24 8 22\r\n21 13 23\r\n",
                "1\r\n4\r\n9\r\n2\r\n1\r\n0\r\n1\r\n10\r\n11\r\n16\r\n16\r\n0\r\n16\r\n"
            ]
        ],
        "private_cases": []
    }
]