[
    {
        "name": "Prefixes and Suffixes",
        "description": "You have two strings \n    s_1\n and \n    s_2\n of length \n    n\n, consisting of\nlowercase English letters. You can perform the following operation any\n(possibly zero) number of times: Choose a positive integer \n    1 \n    \u2264 k\n    \n    \u2264 n\n. Swap the prefix of the string \n    s_1\n and the suffix of the\nstring \n    s_2\n of length \n    k\n. Is it possible to make these two strings\nequal by doing described operations? Input The first line contains a single\ninteger \n    t\n (\n    1 \n    \u2264 t \n    \u2264 10^4\n) \u2014 the number of test cases. Then\nthe test cases follow. Each test case consists of three lines. The first line\ncontains a single integer \n    n\n (\n    1 \n    \u2264 n \n    \u2264 10^5\n) \u2014 the length of\nthe strings \n    s_1\n and \n    s_2\n. The second line contains the string\n\n    s_1\n of length \n    n\n, consisting of lowercase English letters. The\nthird line contains the string \n    s_2\n of length \n    n\n, consisting of\nlowercase English letters. It is guaranteed that the sum of \n    n\n for all\ntest cases does not exceed \n    2 \n    \u00b7 10^5\n. Output For each test case,\nprint \"YES\" if it is possible to make the strings equal, and \"NO\" otherwise.\nExample Input 7 3 cbc aba 5 abcaa cbabb 5 abcaa cbabz 1 a a 1 a b 6 abadaa\nadaaba 8 abcabdaa adabcaba Output YES YES NO YES NO NO YES Note In the first\ntest case: Initially \n    s_1 = \n    \ud835\ude8c\ud835\ude8b\ud835\ude8c\n, \n    s_2 = \n    \ud835\ude8a\ud835\ude8b\ud835\ude8a\n.\nOperation with \n    k = 1\n, after the operation \n    s_1 = \n    \ud835\ude8a\ud835\ude8b\ud835\ude8c\n,\n\n    s_2 = \n    \ud835\ude8a\ud835\ude8b\ud835\ude8c\n. In the second test case: Initially \n    s_1 =\n    \n    \ud835\ude8a\ud835\ude8b\ud835\ude8c\ud835\ude8a\ud835\ude8a\n, \n    s_2 = \n    \ud835\ude8c\ud835\ude8b\ud835\ude8a\ud835\ude8b\ud835\ude8b\n. Operation with \n    k = 2\n,\nafter the operation \n    s_1 = \n    \ud835\ude8b\ud835\ude8b\ud835\ude8c\ud835\ude8a\ud835\ude8a\n, \n    s_2 =\n    \n    \ud835\ude8c\ud835\ude8b\ud835\ude8a\ud835\ude8a\ud835\ude8b\n. Operation with \n    k = 3\n, after the operation \n    s_1 =\n    \n    \ud835\ude8a\ud835\ude8a\ud835\ude8b\ud835\ude8a\ud835\ude8a\n, \n    s_2 = \n    \ud835\ude8c\ud835\ude8b\ud835\ude8b\ud835\ude8b\ud835\ude8c\n. Operation with \n    k = 1\n,\nafter the operation \n    s_1 = \n    \ud835\ude8c\ud835\ude8a\ud835\ude8b\ud835\ude8a\ud835\ude8a\n, \n    s_2 =\n    \n    \ud835\ude8c\ud835\ude8b\ud835\ude8b\ud835\ude8b\ud835\ude8a\n. Operation with \n    k = 2\n, after the operation \n    s_1 =\n    \n    \ud835\ude8b\ud835\ude8a\ud835\ude8b\ud835\ude8a\ud835\ude8a\n, \n    s_2 = \n    \ud835\ude8c\ud835\ude8b\ud835\ude8b\ud835\ude8c\ud835\ude8a\n. Operation with \n    k = 1\n,\nafter the operation \n    s_1 = \n    \ud835\ude8a\ud835\ude8a\ud835\ude8b\ud835\ude8a\ud835\ude8a\n, \n    s_2 =\n    \n    \ud835\ude8c\ud835\ude8b\ud835\ude8b\ud835\ude8c\ud835\ude8b\n. Operation with \n    k = 2\n, after the operation \n    s_1 =\n    \n    \ud835\ude8c\ud835\ude8b\ud835\ude8b\ud835\ude8a\ud835\ude8a\n, \n    s_2 = \n    \ud835\ude8c\ud835\ude8b\ud835\ude8b\ud835\ude8a\ud835\ude8a\n. In the third test case,\nit's impossible to make strings equal.\n\n",
        "cf_contest_id": 1730,
        "cf_index": "D",
        "cf_rating": 2200,
        "difficulty": 0,
        "cf_tags": [
            "constructive algorithms",
            "strings",
            "two pointers"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "7\r\n3\r\ncbc\r\naba\r\n5\r\nabcaa\r\ncbabb\r\n5\r\nabcaa\r\ncbabz\r\n1\r\na\r\na\r\n1\r\na\r\nb\r\n6\r\nabadaa\r\nadaaba\r\n8\r\nabcabdaa\r\nadabcaba\r\n",
                "YES\r\nYES\r\nNO\r\nYES\r\nNO\r\nNO\r\nYES\r\n"
            ]
        ],
        "private_cases": []
    }
]