[
    {
        "name": "Hidden Permutations",
        "description": "This is an interactive problem. The jury has a permutation \n    p\n of length\n\n    n\n and wants you to guess it. For this, the jury created another\npermutation \n    q\n of length \n    n\n. Initially, \n    q\n is an identity\npermutation (\n    q_i = i\n for all \n    i\n). You can ask queries to get\n\n    q_i\n for any \n    i\n you want. After each query, the jury will change\n\n    q\n in the following way: At first, the jury will create a new permutation\n\n    q'\n of length \n    n\n such that \n    q'_i = q_p_i\n for all \n    i\n.\nThen the jury will replace permutation \n    q\n with pemutation \n    q'\n. You\ncan make no more than \n    2n\n queries in order to quess \n    p\n. Input The\nfirst line of input contains a single integer \n    t\n (\n    1 \n    \u2264 t \n    \u2264\n    1000\n) \u2014 the number of test cases. Interaction Interaction in each test case\nstarts after reading the single integer \n    n\n (\n    1 \n    \u2264 n \n    \u2264 10^4\n)\n\u2014 the length of permutations \n    p\n and \n    q\n. To get the value of\n\n    q_i\n, output the query in the format \n    ?\n \n    i\n (\n    1 \n    \u2264 i\n    \n    \u2264 n\n). After that you will receive the value of \n    q_i\n. You can make\nat most \n    2n\n queries. After the incorrect query you will receive \n    0\n\nand you should exit immediately to get Wrong answer verdict. When you will be\nready to determine \n    p\n, output \n    p\n in format \n    !\n \n    p_1\n\n\n    p_2\n \n    \u2026\n \n    p_n\n. After this you should go to the next test\ncase or exit if it was the last test case. Printing the permutation is not\ncounted as one of \n    2n\n queries. After printing a query do not forget to\noutput end of line and flush the output. Otherwise, you will get Idleness\nlimit exceeded. To do this, use: fflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java; flush(output) in Pascal; stdout.flush() in Python;\nsee documentation for other languages. It is guaranteed that the sum of\n\n    n\n over all test cases doesn't exceed \n    10^4\n. The interactor is not\nadaptive in this problem. Hacks: To hack, use the following format: The first\nline contains the single integer \n    t\n \u2014 the number of test cases. The first\nline of each test case contains the single integer \n    n\n \u2014 the length of the\npermutations \n    p\n and \n    q\n. The second line of each test case contains\n\n    n\n integers \n    p_1, p_2, \n    \u2026, p_n\n \u2014 the hidden permutation for\nthis test case. Example Input 2 4 3 2 1 4 2 4 4 Output ? 3 ? 2 ? 4 ! 4 2 1 3 ?\n2 ? 3 ? 2 ! 1 3 4 2 Note In the first test case the hidden permutation \n    p =\n    [4, 2, 1, 3]\n. Before the first query \n    q = [1, 2, 3, 4]\n so answer for\nthe query will be \n    q_3 = 3\n. Before the second query \n    q = [4, 2, 1,\n    3]\n so answer for the query will be \n    q_2 = 2\n. Before the third query\n\n    q = [3, 2, 4, 1]\n so answer for the query will be \n    q_4 = 1\n. In the\nsecond test case the hidden permutation \n    p = [1, 3, 4, 2]\n. Empty strings\nare given only for better readability. There will be no empty lines in the\ntesting system.\n\n",
        "cf_contest_id": 1621,
        "cf_index": "C",
        "cf_rating": 1700,
        "difficulty": 0,
        "cf_tags": [
            "dfs and similar",
            "interactive",
            "math"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "2\r\n4\r\n4 2 1 3\r\n4\r\n1 3 4 2\r\n",
                "4 2 1 3 \r\n1 3 4 2 \r\n"
            ]
        ],
        "private_cases": []
    }
]