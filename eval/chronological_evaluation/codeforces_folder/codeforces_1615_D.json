[
    {
        "name": "X(or)-mas Tree",
        "description": "'Twas the night before Christmas, and Santa's frantically setting up his new\nChristmas tree! There are \n    n\n nodes in the tree, connected by \n    n-1\n\nedges. On each edge of the tree, there's a set of Christmas lights, which can\nbe represented by an integer in binary representation. He has \n    m\n elves\ncome over and admire his tree. Each elf is assigned two nodes, \n    a\n and\n\n    b\n, and that elf looks at all lights on the simple path between the two\nnodes. After this, the elf's favorite number becomes the bitwise XOR of the\nvalues of the lights on the edges in that path. However, the North Pole has\nbeen recovering from a nasty bout of flu. Because of this, Santa forgot some\nof the configurations of lights he had put on the tree, and he has already\nleft the North Pole! Fortunately, the elves came to the rescue, and each one\ntold Santa what pair of nodes he was assigned \n    (a_i, b_i)\n, as well as the\nparity of the number of set bits in his favorite number. In other words, he\nremembers whether the number of \n    1\n's when his favorite number is written\nin binary is odd or even. Help Santa determine if it's possible that the\nmemories are consistent, and if it is, remember what his tree looked like, and\nmaybe you'll go down in history! Input The first line contains one integer\n\n    t\n (\n    1 \n    \u2264 t \n    \u2264 2 \n    \u00b7 10^4\n) \u2014 the number of test cases.\nThen \n    t\n cases follow. The first line of each test case contains two\nintegers, \n    n\n and \n    m\n (\n    2 \n    \u2264 n \n    \u2264 2 \n    \u00b7 10^5\n; \n    1\n    \n    \u2264 m \n    \u2264 2 \n    \u00b7 10^5\n) \u2014 the size of tree and the number of elves\nrespectively. The next \n    n-1\n lines of each test case each contains three\nintegers, \n    x\n, \n    y\n, and \n    v\n (\n    1 \n    \u2264 x, y \n    \u2264 n\n; \n    -1\n    \n    \u2264 v < 2^30\n) \u2014 meaning that there's an edge between nodes \n    x\n and\n\n    y\n. If \n    v = -1\n: Santa doesn't remember what the set of lights were\non for this edge. \n    v \n    \u2265 0\n: The set of lights on the edge is \n    v\n.\nThe next \n    m\n lines of each test case each contains three integers,\n\n    a\n, \n    b\n, and \n    p\n (\n    1 \n    \u2264 a, b \n    \u2264 n\n; \n    a \n    \u2260 b\n;\n\n    0 \n    \u2264 p \n    \u2264 1\n) \u2014 the nodes that the elf was assigned to, and the\nparity of the number of set bits in the elf's favorite number. It is\nguaranteed that the sum of all \n    n\n and the sum of all \n    m\n don't exceed\n\n    2 \n    \u00b7 10^5\n each. It is guaranteed that the given edges form a tree.\nOutput For each test case, first print either YES or NO (in any case), whether\nthere's a tree consistent with Santa's memory or not. If the answer is YES,\nprint \n    n-1\n lines each containing three integers: \n    x\n, \n    y\n, and\n\n    v\n (\n    1 \n    \u2264 x, y \n    \u2264 n\n; \n    0 \n    \u2264 v < 2^30\n) \u2014 the edge and\nthe integer on that edge. The set of edges must be the same as in the input,\nand if the value of some edge was specified earlier, it can not change. You\ncan print the edges in any order. If there are multiple answers, print any.\nExample Input 4 6 5 1 2 -1 1 3 1 4 2 7 6 3 0 2 5 -1 2 3 1 2 5 0 5 6 1 6 1 1 4\n5 1 5 3 1 2 -1 1 3 -1 1 4 1 4 5 -1 2 4 0 3 4 1 2 3 1 3 3 1 2 -1 1 3 -1 1 2 0 1\n3 1 2 3 0 2 1 1 2 1 1 2 0 Output YES 1 2 0 1 3 1 2 4 7 3 6 0 2 5 0 YES 1 2 1 1\n3 0 1 4 1 4 5 1 NO NO Note The first test case is the image in the statement.\nOne possible answer is assigning the value of the edge \n    (1, 2)\n to\n\n    5\n, and the value of the edge \n    (2, 5)\n to \n    3\n. This is correct\nbecause: The first elf goes from node \n    2\n to node \n    3\n. This elf's\nfavorite number is \n    4\n, so he remembers the value \n    1\n (as \n    4\n has\nan odd number of \n    1\n bits in its binary representation). The second elf\ngoes from node \n    2\n to node \n    5\n. This elf's favorite number is \n    3\n,\nso he remembers the value \n    0\n (as \n    3\n has an even number of \n    1\n\nbits in its binary representation). The third elf goes from node \n    5\n to\nnode \n    6\n. This elf's favorite number is \n    7\n, so he remembers the value\n\n    1\n (as \n    7\n has an odd number of \n    1\n bits in its binary\nrepresentation). The fourth elf goes from node \n    6\n to node \n    1\n. This\nelf's favorite number is \n    1\n, so he remembers the value \n    1\n (as\n\n    1\n has an odd number of \n    1\n bits in its binary representation). The\nfifth elf goes from node \n    4\n to node \n    5\n. This elf's favorite number\nis \n    4\n, so he remembers the number \n    1\n (as \n    4\n has an odd number\nof \n    1\n bits in its binary representation). Note that there are other\npossible answers.\n\n",
        "cf_contest_id": 1615,
        "cf_index": "D",
        "cf_rating": 2200,
        "difficulty": 0,
        "cf_tags": [
            "bitmasks",
            "dfs and similar",
            "dsu",
            "graphs",
            "trees"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "4\r\n6 5\r\n1 2 -1\r\n1 3 1\r\n4 2 7\r\n6 3 0\r\n2 5 -1\r\n2 3 1\r\n2 5 0\r\n5 6 1\r\n6 1 1\r\n4 5 1\r\n5 3\r\n1 2 -1\r\n1 3 -1\r\n1 4 1\r\n4 5 -1\r\n2 4 0\r\n3 4 1\r\n2 3 1\r\n3 3\r\n1 2 -1\r\n1 3 -1\r\n1 2 0\r\n1 3 1\r\n2 3 0\r\n2 1\r\n1 2 1\r\n1 2 0\r\n",
                "YES\r\n1 2 0\r\n1 3 1\r\n4 2 7\r\n6 3 0\r\n2 5 0\r\nYES\r\n1 2 1\r\n1 3 0\r\n1 4 1\r\n4 5 0\r\nNO\r\nNO\r\n"
            ]
        ],
        "private_cases": []
    }
]