[
    {
        "name": "Most Similar Words",
        "description": "You are given \n    n\n words of equal length \n    m\n, consisting of lowercase\nLatin alphabet letters. The \n    i\n-th word is denoted \n    s_i\n. In one move\nyou can choose any position in any single word and change the letter at that\nposition to the previous or next letter in alphabetical order. For example:\nyou can change 'e' to 'd' or to 'f'; 'a' can only be changed to 'b'; 'z' can\nonly be changed to 'y'. The difference between two words is the minimum number\nof moves required to make them equal. For example, the difference between\n\"best\" and \"cost\" is \n    1 + 10 + 0 + 0 = 11\n. Find the minimum difference of\n\n    s_i\n and \n    s_j\n such that \n    (i < j)\n. In other words, find the\nminimum difference over all possible pairs of the \n    n\n words. Input The\nfirst line of the input contains a single integer \n    t\n (\n    1 \n    \u2264 t \n    \u2264\n    100\n) \u2014 the number of test cases. The description of test cases follows. The\nfirst line of each test case contains \n    2\n integers \n    n\n and \n    m\n\n(\n    2 \n    \u2264 n \n    \u2264 50\n, \n    1 \n    \u2264 m \n    \u2264 8\n) \u2014 the number of\nstrings and their length respectively. Then follows \n    n\n lines, the\n\n    i\n-th of which containing a single string \n    s_i\n of length \n    m\n,\nconsisting of lowercase Latin letters. Output For each test case, print a\nsingle integer \u2014 the minimum difference over all possible pairs of the given\nstrings. Example Input 6 2 4 best cost 6 3 abb zba bef cdu ooo zzz 2 7 aaabbbc\nbbaezfe 3 2 ab ab ab 2 8 aaaaaaaa zzzzzzzz 3 1 a u y Output 11 8 35 0 200 4\nNote For the second test case, one can show that the best pair is\n(\"abb\",\"bef\"), which has difference equal to \n    8\n, which can be obtained in\nthe following way: change the first character of the first string to 'b' in\none move, change the second character of the second string to 'b' in \n    3\n\nmoves and change the third character of the second string to 'b' in \n    4\n\nmoves, thus making in total \n    1 + 3 + 4 = 8\n moves. For the third test\ncase, there is only one possible pair and it can be shown that the minimum\namount of moves necessary to make the strings equal is \n    35\n. For the\nfourth test case, there is a pair of strings which is already equal, so the\nanswer is \n    0\n.\n\n",
        "cf_contest_id": 1676,
        "cf_index": "C",
        "cf_rating": 800,
        "difficulty": 0,
        "cf_tags": [
            "brute force",
            "greedy",
            "implementation",
            "implementation",
            "math",
            "strings"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "6\r\n2 4\r\nbest\r\ncost\r\n6 3\r\nabb\r\nzba\r\nbef\r\ncdu\r\nooo\r\nzzz\r\n2 7\r\naaabbbc\r\nbbaezfe\r\n3 2\r\nab\r\nab\r\nab\r\n2 8\r\naaaaaaaa\r\nzzzzzzzz\r\n3 1\r\na\r\nu\r\ny\r\n",
                "11\r\n8\r\n35\r\n0\r\n200\r\n4\r\n"
            ]
        ],
        "private_cases": [
            [
                "1\r\n2 7\r\nabcdefg\r\naaaaaaa\r\n",
                "21\r\n"
            ]
        ]
    }
]