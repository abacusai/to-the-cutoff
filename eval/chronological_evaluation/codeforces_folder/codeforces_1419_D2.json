[
    {
        "name": "Sage's Birthday (hard version)",
        "description": "This is the hard version of the problem. The difference between the versions\nis that in the easy version all prices \n    a_i\n are different. You can make\nhacks if and only if you solved both versions of the problem. Today is Sage's\nbirthday, and she will go shopping to buy ice spheres. All \n    n\n ice spheres\nare placed in a row and they are numbered from \n    1\n to \n    n\n from left to\nright. Each ice sphere has a positive integer price. In this version, some\nprices can be equal. An ice sphere is cheap if it costs strictly less than two\nneighboring ice spheres: the nearest to the left and the nearest to the right.\nThe leftmost and the rightmost ice spheres are not cheap. Sage will choose all\ncheap ice spheres and then buy only them. You can visit the shop before Sage\nand reorder the ice spheres as you wish. Find out the maximum number of ice\nspheres that Sage can buy, and show how the ice spheres should be reordered.\nInput The first line contains a single integer \n    n\n \n    (1 \n    \u2264 n \n    \u2264\n    10^5)\n \u2014 the number of ice spheres in the shop. The second line contains\n\n    n\n integers \n    a_1, a_2, \n    \u2026, a_n\n \n    (1 \n    \u2264 a_i \n    \u2264 10^9)\n \u2014\nthe prices of ice spheres. Output In the first line print the maximum number\nof ice spheres that Sage can buy. In the second line print the prices of ice\nspheres in the optimal order. If there are several correct answers, you can\nprint any of them. Example Input 7 1 3 2 2 4 5 4 Output 3 3 1 4 2 4 2 5 Note\nIn the sample it's not possible to place the ice spheres in any order so that\nSage would buy \n    4\n of them. If the spheres are placed in the order \n    (3,\n    1, 4, 2, 4, 2, 5)\n, then Sage will buy one sphere for \n    1\n and two\nspheres for \n    2\n each.\n\n",
        "cf_contest_id": 1419,
        "cf_index": "D2",
        "cf_rating": 1500,
        "difficulty": 0,
        "cf_tags": [
            "binary search",
            "brute force",
            "constructive algorithms",
            "greedy",
            "sortings",
            "two pointers"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "7\r\n1 3 2 2 4 5 4\r\n",
                "3 3 1 4 2 4 2 5\r\n"
            ]
        ],
        "private_cases": [
            [
                "1\r\n1\r\n",
                "0 1\r\n"
            ],
            [
                "2\r\n1000000000 1000000000\r\n",
                "0 1000000000 1000000000\r\n"
            ],
            [
                "5\r\n1 2 2 4 5\r\n",
                "2 2 1 4 2 5\r\n"
            ],
            [
                "4\r\n1 1 2 4\r\n",
                "1 2 1 4 1\r\n"
            ],
            [
                "10\r\n1 2 3 3 3 3 3 3 4 5\r\n",
                "3 3 1 3 2 3 3 4 3 5 3\r\n"
            ]
        ]
    }
]