[
    {
        "name": "Binary String Sorting",
        "description": "You are given a binary string \n    s\n consisting of only characters 0 and/or\n1. You can perform several operations on this string (possibly zero). There\nare two types of operations: choose two consecutive elements and swap them. In\norder to perform this operation, you pay \n    10^12\n coins; choose any\nelement from the string and remove it. In order to perform this operation, you\npay \n    10^12+1\n coins. Your task is to calculate the minimum number of\ncoins required to sort the string \n    s\n in non-decreasing order (i. e.\ntransform \n    s\n so that \n    s_1 \n    \u2264 s_2 \n    \u2264\n    \u2026\n    \u2264 s_m\n, where\n\n    m\n is the length of the string after applying all operations). An empty\nstring is also considered sorted in non-decreasing order. Input The first line\ncontains a single integer \n    t\n (\n    1 \n    \u2264 t \n    \u2264 10^4\n) \u2014 the number of\ntest cases. The only line of each test case contains the string \n    s\n (\n    1\n    \n    \u2264 |s| \n    \u2264 3 \n    \u00b7 10^5\n), consisting of only characters 0 and/or 1.\nThe sum of lengths of all given strings doesn't exceed \n    3 \n    \u00b7 10^5\n.\nOutput For each test case, print a single integer \u2014 the minimum number of\ncoins required to sort the string \n    s\n in non-decreasing order. Example\nInput 6 100 0 0101 00101101 1001101 11111 Output 1000000000001 0 1000000000000\n2000000000001 2000000000002 0 Note In the first example, you have to remove\nthe \n    1\n-st element, so the string becomes equal to 00. In the second\nexample, the string is already sorted. In the third example, you have to swap\nthe \n    2\n-nd and the \n    3\n-rd elements, so the string becomes equal to\n0011. In the fourth example, you have to swap the \n    3\n-rd and the\n\n    4\n-th elements, so the string becomes equal to 00011101, and then remove\nthe \n    7\n-th element, so the string becomes equal to 0001111. In the fifth\nexample, you have to remove the \n    1\n-st element, so the string becomes\nequal to 001101, and then remove the \n    5\n-th element, so the string becomes\nequal to 00111. In the sixth example, the string is already sorted.\n\n",
        "cf_contest_id": 1809,
        "cf_index": "D",
        "cf_rating": 1800,
        "difficulty": 0,
        "cf_tags": [
            "constructive algorithms",
            "greedy"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "6\r\n100\r\n0\r\n0101\r\n00101101\r\n1001101\r\n11111\r\n",
                "1000000000001\r\n0\r\n1000000000000\r\n2000000000001\r\n2000000000002\r\n0\r\n"
            ]
        ],
        "private_cases": []
    }
]