[
    {
        "name": "Minimum Binary Number",
        "description": "String can be called correct if it consists of characters \"0\" and \"1\" and\nthere are no redundant leading zeroes. Here are some examples: \"0\", \"10\",\n\"1001\". You are given a correct string s. You can perform two different\noperations on this string: swap any pair of adjacent characters (for example,\n\"101\" \"110\"); replace \"11\" with \"1\" (for example, \"110\" \"10\"). Let val(s) be\nsuch a number that s is its binary representation. Correct string a is less\nthan some other correct string b iff val(a) < val(b). Your task is to find the\nminimum correct string that you can obtain from the given one using the\noperations described above. You can use these operations any number of times\nin any order (or even use no operations at all). Input The first line contains\ninteger number n (1 \u2264 n \u2264 100) \u2014 the length of string s. The second line\ncontains the string s consisting of characters \"0\" and \"1\". It is guaranteed\nthat the string s is correct. Output Print one string \u2014 the minimum correct\nstring that you can obtain from the given one. Examples Input 4 1001 Output\n100 Input 1 1 Output 1 Note In the first example you can obtain the answer by\nthe following sequence of operations: \"1001\" \"1010\" \"1100\" \"100\". In the\nsecond example you can't obtain smaller answer no matter what operations you\nuse.\n\n",
        "cf_contest_id": 976,
        "cf_index": "A",
        "cf_rating": 800,
        "difficulty": 0,
        "cf_tags": [
            "implementation"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "4\r\n1001\r\n",
                "100\r\n"
            ],
            [
                "1\r\n1\r\n",
                "1\r\n"
            ]
        ],
        "private_cases": [
            [
                "100\r\n1110111100001111011111111010110011111111011110000111101101011100110110001011000000101010110101011100\r\n",
                "1000000000000000000000000000000000000000\r\n"
            ],
            [
                "100\r\n1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\r\n",
                "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\r\n"
            ],
            [
                "100\r\n1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111\r\n",
                "1\r\n"
            ],
            [
                "100\r\n1111111111111111111111111111111111111111111111111111111110111111111111111111111111111111111111111111\r\n",
                "10\r\n"
            ],
            [
                "1\r\n0\r\n",
                "0\r\n"
            ],
            [
                "8\r\n10101010\r\n",
                "10000\r\n"
            ],
            [
                "2\r\n10\r\n",
                "10\r\n"
            ],
            [
                "3\r\n111\r\n",
                "1\r\n"
            ],
            [
                "5\r\n11100\r\n",
                "100\r\n"
            ],
            [
                "2\r\n11\r\n",
                "1\r\n"
            ],
            [
                "3\r\n110\r\n",
                "10\r\n"
            ],
            [
                "50\r\n10010010000000000000000000000000000000001000000000\r\n",
                "10000000000000000000000000000000000000000000000\r\n"
            ]
        ]
    }
]