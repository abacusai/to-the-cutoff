[
    {
        "name": "Shave Beaver!",
        "description": "The Smart Beaver has recently designed and built an innovative nanotechnologic\nall-purpose beaver mass shaving machine, \"Beavershave 5000\". Beavershave 5000\ncan shave beavers by families! How does it work? Very easily! There are n\nbeavers, each of them has a unique id from 1 to n. Consider a permutation a1,\na2, ..., an of n these beavers. Beavershave 5000 needs one session to shave\nbeavers with ids from x to y (inclusive) if and only if there are such indices\ni1 < i2 < ... < ik, that ai1 = x, ai2 = x + 1, ..., aik - 1 = y - 1, aik = y.\nAnd that is really convenient. For example, it needs one session to shave a\npermutation of beavers 1, 2, 3, ..., n. If we can't shave beavers from x to y\nin one session, then we can split these beavers into groups [x, p1], [p1 + 1,\np2], ..., [pm + 1, y] (x \u2264 p1 < p2 < ... < pm < y), in such a way that the\nmachine can shave beavers in each group in one session. But then Beavershave\n5000 needs m + 1 working sessions to shave beavers from x to y. All beavers\nare restless and they keep trying to swap. So if we consider the problem more\nformally, we can consider queries of two types: what is the minimum number of\nsessions that Beavershave 5000 needs to shave beavers with ids from x to y,\ninclusive? two beavers on positions x and y (the beavers ax and ay) swapped.\nYou can assume that any beaver can be shaved any number of times. Input The\nfirst line contains integer n \u2014 the total number of beavers, 2 \u2264 n. The second\nline contains n space-separated integers \u2014 the initial beaver permutation. The\nthird line contains integer q \u2014 the number of queries, 1 \u2264 q \u2264 10^5. The next\nq lines contain the queries. Each query i looks as pi xi yi, where pi is the\nquery type (1 is to shave beavers from xi to yi, inclusive, 2 is to swap\nbeavers on positions xi and yi). All queries meet the condition: 1 \u2264 xi < yi \u2264\nn. to get 30 points, you need to solve the problem with constraints: n \u2264 100\n(subproblem B1); to get 100 points, you need to solve the problem with\nconstraints: n \u2264 3\u00b710^5 (subproblems B1+B2). Note that the number of queries q\nis limited 1 \u2264 q \u2264 10^5 in both subproblem B1 and subproblem B2. Output For\neach query with pi = 1, print the minimum number of Beavershave 5000 sessions.\nExamples Input 5 1 3 4 2 5 6 1 1 5 1 3 4 2 2 3 1 1 5 2 1 5 1 1 5 Output 2 1 3\n5\n\n",
        "cf_contest_id": 331,
        "cf_index": "B2",
        "cf_rating": 1900,
        "difficulty": 0,
        "cf_tags": [
            "data structures"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "5\r\n1 3 4 2 5\r\n6\r\n1 1 5\r\n1 3 4\r\n2 2 3\r\n1 1 5\r\n2 1 5\r\n1 1 5\r\n",
                "2\r\n1\r\n3\r\n5\r\n"
            ]
        ],
        "private_cases": []
    }
]