[
    {
        "name": "Johnny and Ancient Computer",
        "description": "Johnny has recently found an ancient, broken computer. The machine has only\none register, which allows one to put in there one variable. Then in one\noperation, you can shift its bits left or right by at most three positions.\nThe right shift is forbidden if it cuts off some ones. So, in fact, in one\noperation, you can multiply or divide your number by \n    2\n, \n    4\n or\n\n    8\n, and division is only allowed if the number is divisible by the chosen\ndivisor. Formally, if the register contains a positive integer \n    x\n, in one\noperation it can be replaced by one of the following: \n    x \n    \u00b7 2\n \n    x\n    \n    \u00b7 4\n \n    x \n    \u00b7 8\n \n    x / 2\n, if \n    x\n is divisible by \n    2\n\n\n    x / 4\n, if \n    x\n is divisible by \n    4\n \n    x / 8\n, if \n    x\n is\ndivisible by \n    8\n For example, if \n    x = 6\n, in one operation it can be\nreplaced by \n    12\n, \n    24\n, \n    48\n or \n    3\n. Value \n    6\n isn't\ndivisible by \n    4\n or \n    8\n, so there're only four variants of\nreplacement. Now Johnny wonders how many operations he needs to perform if he\nputs \n    a\n in the register and wants to get \n    b\n at the end. Input The\ninput consists of multiple test cases. The first line contains an integer\n\n    t\n (\n    1 \n    \u2264 t \n    \u2264 1000\n) \u2014 the number of test cases. The\nfollowing \n    t\n lines contain a description of test cases. The first and\nonly line in each test case contains integers \n    a\n and \n    b\n (\n    1 \n    \u2264\n    a, b \n    \u2264 10^18\n) \u2014 the initial and target value of the variable,\nrespectively. Output Output \n    t\n lines, each line should contain one\ninteger denoting the minimum number of operations Johnny needs to perform. If\nJohnny cannot get \n    b\n at the end, then write \n    -1\n. Example Input 10 10\n5 11 44 17 21 1 1 96 3 2 128 1001 1100611139403776 1000000000000000000\n1000000000000000000 7 1 10 8 Output 1 1 -1 0 2 2 14 0 -1 -1 Note In the first\ntest case, Johnny can reach \n    5\n from \n    10\n by using the shift to the\nright by one (i.e. divide by \n    2\n). In the second test case, Johnny can\nreach \n    44\n from \n    11\n by using the shift to the left by two (i.e.\nmultiply by \n    4\n). In the third test case, it is impossible for Johnny to\nreach \n    21\n from \n    17\n. In the fourth test case, initial and target\nvalues are equal, so Johnny has to do \n    0\n operations. In the fifth test\ncase, Johnny can reach \n    3\n from \n    96\n by using two shifts to the right:\none by \n    2\n, and another by \n    3\n (i.e. divide by \n    4\n and by\n\n    8\n).\n\n",
        "cf_contest_id": 1362,
        "cf_index": "A",
        "cf_rating": 1000,
        "difficulty": 0,
        "cf_tags": [
            "implementation"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "10\r\n10 5\r\n11 44\r\n17 21\r\n1 1\r\n96 3\r\n2 128\r\n1001 1100611139403776\r\n1000000000000000000 1000000000000000000\r\n7 1\r\n10 8\r\n",
                "1 1 -1 0 2 2 14 0 -1 -1 "
            ]
        ],
        "private_cases": [
            [
                "1\r\n703687441776640 327680\r\n",
                "11 "
            ]
        ]
    }
]