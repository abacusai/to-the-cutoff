[
    {
        "name": "Intersecting Subtrees",
        "description": "You are playing a strange game with Li Chen. You have a tree with \n    n\n\nnodes drawn on a piece of paper. All nodes are unlabeled and distinguishable.\nEach of you independently labeled the vertices from \n    1\n to \n    n\n.\nNeither of you know the other's labelling of the tree. You and Li Chen each\nchose a subtree (i.e., a connected subgraph) in that tree. Your subtree\nconsists of the vertices labeled \n    x_1, x_2, \n    \u2026, x_k_1\n in your\nlabeling, Li Chen's subtree consists of the vertices labeled \n    y_1, y_2,\n    \n    \u2026, y_k_2\n in his labeling. The values of \n    x_1, x_2, \n    \u2026,\n    x_k_1\n and \n    y_1, y_2, \n    \u2026, y_k_2\n are known to both of you. The\npicture shows two labelings of a possible tree: yours on the left and Li\nChen's on the right. The selected trees are highlighted. There are two common\nnodes. You want to determine whether your subtrees have at least one common\nvertex. Luckily, your friend Andrew knows both labelings of the tree. You can\nask Andrew at most \n    5\n questions, each of which is in one of the following\ntwo forms: A x: Andrew will look at vertex \n    x\n in your labeling and tell\nyou the number of this vertex in Li Chen's labeling. B y: Andrew will look at\nvertex \n    y\n in Li Chen's labeling and tell you the number of this vertex in\nyour labeling. Determine whether the two subtrees have at least one common\nvertex after asking some questions. If there is at least one common vertex,\ndetermine one of your labels for any of the common vertices. Interaction Each\ntest consists of several test cases. The first line of input contains a single\ninteger \n    t\n (\n    1 \n    \u2264 t \n    \u2264 100\n) \u2014 the number of test cases. For\neach testcase, your program should interact in the following format. The first\nline contains a single integer \n    n\n (\n    1 \n    \u2264 n \n    \u2264 1\n     000\n) \u2014\nthe number of nodes in the tree. Each of the next \n    n-1\n lines contains two\nintegers \n    a_i\n and \n    b_i\n (\n    1\n    \u2264 a_i, b_i\n    \u2264 n\n) \u2014 the edges\nof the tree, indicating an edge between node \n    a_i\n and \n    b_i\n according\nto your labeling of the nodes. The next line contains a single integer\n\n    k_1\n (\n    1 \n    \u2264 k_1 \n    \u2264 n\n) \u2014 the number of nodes in your subtree.\nThe next line contains \n    k_1\n distinct integers\n\n    x_1,x_2,\n    \u2026,x_k_1\n (\n    1 \n    \u2264 x_i \n    \u2264 n\n) \u2014 the indices of\nthe nodes in your subtree, according to your labeling. It is guaranteed that\nthese vertices form a subtree. The next line contains a single integer\n\n    k_2\n (\n    1 \n    \u2264 k_2 \n    \u2264 n\n) \u2014 the number of nodes in Li Chen's\nsubtree. The next line contains \n    k_2\n distinct integers \n    y_1, y_2,\n    \n    \u2026, y_k_2\n (\n    1 \n    \u2264 y_i \n    \u2264 n\n) \u2014 the indices (according to\nLi Chen's labeling) of the nodes in Li Chen's subtree. It is guaranteed that\nthese vertices form a subtree according to Li Chen's labelling of the tree's\nnodes. Test cases will be provided one by one, so you must complete\ninteracting with the previous test (i.e. by printing out a common node or\n\n    -1\n if there is not such node) to start receiving the next one. You can\nask the Andrew two different types of questions. You can print \"A x\" (\n    1\n    \n    \u2264 x \n    \u2264 n\n). Andrew will look at vertex \n    x\n in your labeling and\nrespond to you with the number of this vertex in Li Chen's labeling. You can\nprint \"B y\" (\n    1 \n    \u2264 y \n    \u2264 n\n). Andrew will look at vertex \n    y\n in\nLi Chen's labeling and respond to you with the number of this vertex in your\nlabeling. You may only ask at most \n    5\n questions per tree. When you are\nready to answer, print \"C s\", where \n    s\n is your label of a vertex that is\ncommon to both subtrees, or \n    -1\n, if no such vertex exists. Printing the\nanswer does not count as a question. Remember to flush your answer to start\nreceiving the next test case. After printing a question do not forget to print\nend of line and flush the output. Otherwise, you will get Idleness limit\nexceeded. To do this, use: fflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java; flush(output) in Pascal; stdout.flush() in Python;\nsee documentation for other languages. If the judge responds with \n    -1\n, it\nmeans that you asked more queries than allowed, or asked an invalid query.\nYour program should immediately terminate (for example, by calling exit(0)).\nYou will receive Wrong Answer; it means that you asked more queries than\nallowed, or asked an invalid query. If you ignore this, you can get other\nverdicts since your program will continue to read from a closed stream. Hack\nFormat To hack, use the following format. Note that you can only hack with one\ntest case. The first line should contain a single integer \n    t\n (\n    t=1\n).\nThe second line should contain a single integer \n    n\n (\n    1 \n    \u2264 n \n    \u2264\n    1\n     000\n). The third line should contain \n    n\n integers \n    p_1, p_2,\n    \n    \u2026, p_n\n (\n    1\n    \u2264 p_i\n    \u2264 n\n) \u2014 a permutation of \n    1\n to\n\n    n\n. This encodes the labels that Li Chen chose for his tree. In\nparticular, Li Chen chose label \n    p_i\n for the node you labeled \n    i\n.\nEach of the next \n    n-1\n lines should contain two integers \n    a_i\n and\n\n    b_i\n (\n    1\n    \u2264 a_i, b_i\n    \u2264 n\n). These edges should form a tree.\nThe next line should contain a single integer \n    k_1\n (\n    1 \n    \u2264 k_1\n    \n    \u2264 n\n). The next line should contain \n    k_1\n distinct integers\n\n    x_1,x_2,\n    \u2026,x_k_1\n (\n    1 \n    \u2264 x_i \n    \u2264 n\n). These vertices\nshould form a subtree. The next line should contain a single integer \n    k_2\n\n(\n    1 \n    \u2264 k_2 \n    \u2264 n\n). The next line should contain \n    k_2\n distinct\nintegers \n    y_1, y_2, \n    \u2026, y_k_2\n (\n    1 \n    \u2264 y_i \n    \u2264 n\n).\nThese vertices should form a subtree in Li Chen's tree according to the\npermutation above. Examples Input 1 3 1 2 2 3 1 1 1 2 2 1 Output A 1 B 2 C 1\nInput 2 6 1 2 1 3 1 4 4 5 4 6 4 1 3 4 5 3 3 5 2 3 6 1 2 1 3 1 4 4 5 4 6 3 1 2\n3 3 4 1 6 5 Output B 2 C 1 A 1 C -1 Note For the first sample, Li Chen's\nhidden permutation is \n    [2, 3, 1]\n, and for the second, his hidden\npermutation is \n    [5, 3, 2, 4, 1, 6]\n for both cases. In the first sample,\nthere is a tree with three nodes in a line. On the top, is how you labeled the\ntree and the subtree you chose, and the bottom is how Li Chen labeled the tree\nand the subtree he chose: In the first question, you ask Andrew to look at\nnode \n    1\n in your labelling and tell you the label of it in Li Chen's\nlabelling. Andrew responds with \n    2\n. At this point, you know that both of\nyour subtrees contain the same node (i.e. node \n    1\n according to your\nlabeling), so you can output \"C 1\" and finish. However, you can also ask\nAndrew to look at node \n    2\n in Li Chen's labelling and tell you the label\nof it in your labelling. Andrew responds with \n    1\n (this step was given\nwith the only reason \u2014 to show you how to ask questions). For the second\nsample, there are two test cases. The first looks is the one from the\nstatement: We first ask \"B 2\", and Andrew will tell us \n    3\n. In this case,\nwe know \n    3\n is a common vertex, and moreover, any subtree with size\n\n    3\n that contains node \n    3\n must contain node \n    1\n as well, so we\ncan output either \"C 1\" or \"C 3\" as our answer. In the second case in the\nsecond sample, the situation looks as follows: In this case, you know that the\nonly subtree of size \n    3\n that doesn't contain node \n    1\n is subtree\n\n    4,5,6\n. You ask Andrew for the label of node \n    1\n in Li Chen's\nlabelling and Andrew says \n    5\n. In this case, you know that Li Chen's\nsubtree doesn't contain node \n    1\n, so his subtree must be consist of the\nnodes \n    4,5,6\n (in your labelling), thus the two subtrees have no common\nnodes.\n\n",
        "cf_contest_id": 1044,
        "cf_index": "B",
        "cf_rating": 1900,
        "difficulty": 0,
        "cf_tags": [
            "dfs and similar",
            "interactive",
            "trees"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "1\r\n3\r\n2 3 1\r\n1 2\r\n2 3\r\n1\r\n1\r\n1\r\n2\r\n",
                "1\r\n"
            ],
            [
                "2\r\n6\r\n5 3 2 4 1 6\r\n1 2\r\n1 3\r\n1 4\r\n4 5\r\n4 6\r\n4\r\n1 3 4 5\r\n3\r\n3 5 2\r\n6\r\n5 3 2 4 1 6\r\n1 2\r\n1 3\r\n1 4\r\n4 5\r\n4 6\r\n3\r\n1 2 3\r\n3\r\n4 1 6\r\n",
                "3\r\n-1\r\n"
            ]
        ],
        "private_cases": [
            [
                "1\r\n1\r\n1\r\n1\r\n1\r\n1\r\n1\r\n",
                "1\r\n"
            ]
        ]
    }
]