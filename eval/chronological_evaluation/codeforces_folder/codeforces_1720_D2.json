[
    {
        "name": "Xor-Subsequence (hard version)",
        "description": "It is the hard version of the problem. The only difference is that in this\nversion \n    a_i \n    \u2264 10^9\n. You are given an array of \n    n\n integers\n\n    a_0, a_1, a_2, \n    \u2026 a_n - 1\n. Bryap wants to find the longest\nbeautiful subsequence in the array. An array \n    b = [b_0, b_1, \n    \u2026,\n    b_m-1]\n, where \n    0 \n    \u2264 b_0 < b_1 < \n    \u2026 < b_m - 1 < n\n, is a\nsubsequence of length \n    m\n of the array \n    a\n. Subsequence \n    b = [b_0,\n    b_1, \n    \u2026, b_m-1]\n of length \n    m\n is called beautiful, if the\nfollowing condition holds: For any \n    p\n (\n    0 \n    \u2264 p < m - 1\n) holds:\n\n    a_b_p\n    \u2295 b_p+1 < a_b_p+1\n    \u2295 b_p\n. Here \n    a \n    \u2295\n    b\n denotes the bitwise XOR of \n    a\n and \n    b\n. For example, \n    2\n    \n    \u2295 4 = 6\n and \n    3 \n    \u2295 1=2\n. Bryap is a simple person so he\nonly wants to know the length of the longest such subsequence. Help Bryap and\nfind the answer to his question. Input The first line contains a single\ninteger \n    t\n (\n    1 \n    \u2264 t \n    \u2264 10^5\n) \u2014 the number of test cases. The\ndescription of the test cases follows. The first line of each test case\ncontains a single integer \n    n\n (\n    2 \n    \u2264 n \n    \u2264 3 \n    \u00b7 10^5\n) \u2014\nthe length of the array. The second line of each test case contains \n    n\n\nintegers \n    a_0,a_1,...,a_n-1\n (\n    0 \n    \u2264 a_i \n    \u2264 10^9\n) \u2014 the\nelements of the array. It is guaranteed that the sum of \n    n\n over all test\ncases does not exceed \n    3 \n    \u00b7 10^5\n. Output For each test case print a\nsingle integer \u2014 the length of the longest beautiful subsequence. Example\nInput 3 2 1 2 5 5 2 4 3 1 10 3 8 8 2 9 1 6 2 8 3 Output 2 3 6 Note In the\nfirst test case, we can pick the whole array as a beautiful subsequence\nbecause \n    1 \n    \u2295 1 < 2 \n    \u2295 0\n. In the second test case, we can\npick elements with indexes \n    1\n, \n    2\n and \n    4\n (in \n    0\n\nindexation). For this elements holds: \n    2 \n    \u2295 2 < 4 \n    \u2295 1\n and\n\n    4 \n    \u2295 4 < 1 \n    \u2295 2\n.\n\n",
        "cf_contest_id": 1720,
        "cf_index": "D2",
        "cf_rating": 2400,
        "difficulty": 0,
        "cf_tags": [
            "bitmasks",
            "data structures",
            "dp",
            "strings",
            "trees"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 512.0,
        "public_cases": [
            [
                "3\r\n2\r\n1 2\r\n5\r\n5 2 4 3 1\r\n10\r\n3 8 8 2 9 1 6 2 8 3\r\n",
                "2\n3\n6\n"
            ]
        ],
        "private_cases": []
    }
]