[
    {
        "name": "Recover the Tree",
        "description": "Rhodoks has a tree with \n    n\n vertices, but he doesn't remember its\nstructure. The vertices are indexed from \n    1\n to \n    n\n. A segment\n\n    [l,r]\n (\n    1 \n    \u2264 l \n    \u2264 r \n    \u2264 n\n) is good if the vertices with\nindices \n    l\n, \n    l + 1\n, ..., \n    r\n form a connected component in\nRhodoks' tree. Otherwise, it is bad. For example, if the tree is the one in\nthe picture, then only the segment \n    [3,4]\n is bad while all the other\nsegments are good. For each of the \n    n(n+1)/2\n segments, Rhodoks\nremembers whether it is good or bad. Can you help him recover the tree? If\nthere are multiple solutions, print any. It is guaranteed that the there is at\nleast one tree satisfying Rhodoks' description. Input Each test contains\nmultiple test cases. The first line contains the number of test cases \n    t\n\n(\n    1 \n    \u2264 t \n    \u2264 1000\n). The description of the test cases follows. The\nfirst line of each test case contains an integer \n    n\n (\n    1 \n    \u2264 n \n    \u2264\n    2000\n) \u2014 the number of vertices in the tree. Then \n    n\n lines follow. The\n\n    i\n-th of these lines contains a string \n    good_i\n of length \n    n+1-i\n\nconsisting of 0 and 1. If the segment \n    [i,i+j-1]\n is good then the\n\n    j\n-th character of \n    good_i\n is 1, otherwise \n    j\n-th character of\n\n    good_i\n is 0. It is guaranteed that the there is at least one tree\nconsistent with the given data. It is guaranteed that the sum of \n    n\n over\nall test cases does not exceed \n    2000\n. Output For each test case, print\n\n    n-1\n lines describing the tree you recover. The \n    i\n-th line should\ncontain two integers \n    u_i\n and \n    v_i\n (\n    1 \n    \u2264 u_i,v_i \n    \u2264\n    n\n), denoting an edge between vertices \n    u_i\n and \n    v_i\n. If there are\nmultiple solutions, print any. Example Input 3 4 1111 111 10 1 6 111111 11111\n1111 111 11 1 12 100100000001 11100000001 1000000000 100000000 10010001\n1110000 100000 10000 1001 111 10 1 Output 1 2 2 3 2 4 1 2 2 3 3 4 4 5 5 6 2 3\n6 7 10 11 2 4 6 8 10 12 1 4 5 8 9 12 5 12 2 12 Note The first test case is\nexplained in the statement. In the second test case, one possible tree is as\nfollows: In the third test case, one possible tree is as follows:\n\n",
        "cf_contest_id": 1710,
        "cf_index": "D",
        "cf_rating": 3400,
        "difficulty": 0,
        "cf_tags": [
            "constructive algorithms",
            "trees"
        ],
        "time_limit_seconds": 3.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "3\r\n4\r\n1111\r\n111\r\n10\r\n1\r\n6\r\n111111\r\n11111\r\n1111\r\n111\r\n11\r\n1\r\n12\r\n100100000001\r\n11100000001\r\n1000000000\r\n100000000\r\n10010001\r\n1110000\r\n100000\r\n10000\r\n1001\r\n111\r\n10\r\n1\r\n",
                "1 2\r\n2 3\r\n2 4\r\n1 2\r\n2 3\r\n3 4\r\n4 5\r\n5 6\r\n2 3\r\n6 7\r\n10 11\r\n2 4\r\n6 8\r\n10 12\r\n1 4\r\n5 8\r\n9 12\r\n5 12\r\n2 12\r\n"
            ]
        ],
        "private_cases": []
    }
]