[
    {
        "name": "Chip Move",
        "description": "There is a chip on the coordinate line. Initially, the chip is located at the\npoint \n    0\n. You can perform any number of moves; each move increases the\ncoordinate of the chip by some positive integer (which is called the length of\nthe move). The length of the first move you make should be divisible by\n\n    k\n, the length of the second move \u2014 by \n    k+1\n, the third \u2014 by\n\n    k+2\n, and so on. For example, if \n    k=2\n, then the sequence of moves\nmay look like this: \n    0 \n    \u2192 4 \n    \u2192 7 \n    \u2192 19\n    \n    \u2192 44\n, because \n    4 - 0 = 4\n is divisible by \n    2 = k\n, \n    7\n    - 4 = 3\n is divisible by \n    3 = k + 1\n, \n    19 - 7 = 12\n is divisible by\n\n    4 = k + 2\n, \n    44 - 19 = 25\n is divisible by \n    5 = k + 3\n. You are\ngiven two positive integers \n    n\n and \n    k\n. Your task is to count the\nnumber of ways to reach the point \n    x\n, starting from \n    0\n, for every\n\n    x \n    \u2208 [1, n]\n. The number of ways can be very large, so print it modulo\n\n    998244353\n. Two ways are considered different if they differ as sets of\nvisited positions. Input The first (and only) line of the input contains two\nintegers \n    n\n and \n    k\n (\n    1 \n    \u2264 k \n    \u2264 n \n    \u2264 2 \n    \u00b7 10^5\n).\nOutput Print \n    n\n integers \u2014 the number of ways to reach the point \n    x\n,\nstarting from \n    0\n, for every \n    x \n    \u2208 [1, n]\n, taken modulo\n\n    998244353\n. Examples Input 8 1 Output 1 1 2 2 3 4 5 6 Input 10 2 Output 0\n1 0 1 1 1 1 2 2 2 Note Let's look at the first example: Ways to reach the\npoint \n    1\n: \n    [0, 1]\n; Ways to reach the point \n    2\n: \n    [0, 2]\n;\nWays to reach the point \n    3\n: \n    [0, 1, 3]\n, \n    [0, 3]\n; Ways to reach\nthe point \n    4\n: \n    [0, 2, 4]\n, \n    [0, 4]\n; Ways to reach the point\n\n    5\n: \n    [0, 1, 5]\n, \n    [0, 3, 5]\n, \n    [0, 5]\n; Ways to reach the\npoint \n    6\n: \n    [0, 1, 3, 6]\n, \n    [0, 2, 6]\n, \n    [0, 4, 6]\n, \n    [0,\n    6]\n; Ways to reach the point \n    7\n: \n    [0, 2, 4, 7]\n, \n    [0, 1, 7]\n,\n\n    [0, 3, 7]\n, \n    [0, 5, 7]\n, \n    [0, 7]\n; Ways to reach the point\n\n    8\n: \n    [0, 3, 5, 8]\n, \n    [0, 1, 5, 8]\n, \n    [0, 2, 8]\n, \n    [0, 4,\n    8]\n, \n    [0, 6, 8]\n, \n    [0, 8]\n.\n\n",
        "cf_contest_id": 1716,
        "cf_index": "D",
        "cf_rating": 2000,
        "difficulty": 0,
        "cf_tags": [
            "brute force",
            "dp",
            "math"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "8 1\r\n",
                "1 1 2 2 3 4 5 6\r\n"
            ],
            [
                "10 2\r\n",
                "0 1 0 1 1 1 1 2 2 2\r\n"
            ]
        ],
        "private_cases": []
    }
]