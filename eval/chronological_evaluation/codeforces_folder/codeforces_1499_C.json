[
    {
        "name": "Minimum Grid Path",
        "description": "Let's say you are standing on the \n    XY\n-plane at point \n    (0, 0)\n and you\nwant to reach point \n    (n, n)\n. You can move only in two directions: to the\nright, i. e. horizontally and in the direction that increase your \n    x\n\ncoordinate, or up, i. e. vertically and in the direction that increase your\n\n    y\n coordinate. In other words, your path will have the following\nstructure: initially, you choose to go to the right or up; then you go some\npositive integer distance in the chosen direction (distances can be chosen\nindependently); after that you change your direction (from right to up, or\nfrom up to right) and repeat the process. You don't like to change your\ndirection too much, so you will make no more than \n    n - 1\n direction\nchanges. As a result, your path will be a polygonal chain from \n    (0, 0)\n to\n\n    (n, n)\n, consisting of at most \n    n\n line segments where each segment\nhas positive integer length and vertical and horizontal segments alternate.\nNot all paths are equal. You have \n    n\n integers \n    c_1, c_2, \n    \u2026,\n    c_n\n where \n    c_i\n is the cost of the \n    i\n-th segment. Using these\ncosts we can define the cost of the path as the sum of lengths of the segments\nof this path multiplied by their cost, i. e. if the path consists of \n    k\n\nsegments (\n    k \n    \u2264 n\n), then the cost of the path is equal to\n\n    \u2211\n    _i=1^kc_i \n    \u00b7 length_i\n (segments are numbered\nfrom \n    1\n to \n    k\n in the order they are in the path). Find the path of\nthe minimum cost and print its cost. Input The first line contains the single\ninteger \n    t\n (\n    1 \n    \u2264 t \n    \u2264 1000\n) \u2014 the number of test cases. The\nfirst line of each test case contains the single integer \n    n\n (\n    2 \n    \u2264 n\n    \n    \u2264 10^5\n). The second line of each test case contains \n    n\n integers\n\n    c_1, c_2, \n    \u2026, c_n\n (\n    1 \n    \u2264 c_i \n    \u2264 10^9\n) \u2014 the costs of\neach segment. It's guaranteed that the total sum of \n    n\n doesn't exceed\n\n    10^5\n. Output For each test case, print the minimum possible cost of the\npath from \n    (0, 0)\n to \n    (n, n)\n consisting of at most \n    n\n\nalternating segments. Example Input 3 2 13 88 3 2 3 1 5 4 3 2 1 4 Output 202\n13 19 Note In the first test case, to reach \n    (2, 2)\n you need to make at\nleast one turn, so your path will consist of exactly \n    2\n segments: one\nhorizontal of length \n    2\n and one vertical of length \n    2\n. The cost of\nthe path will be equal to \n    2 \n    \u00b7 c_1 + 2 \n    \u00b7 c_2 = 26 + 176 =\n    202\n. In the second test case, one of the optimal paths consists of \n    3\n\nsegments: the first segment of length \n    1\n, the second segment of length\n\n    3\n and the third segment of length \n    2\n. The cost of the path is \n    1\n    \n    \u00b7 2 + 3 \n    \u00b7 3 + 2 \n    \u00b7 1 = 13\n. In the third test case, one of\nthe optimal paths consists of \n    4\n segments: the first segment of length\n\n    1\n, the second one \u2014 \n    1\n, the third one \u2014 \n    4\n, the fourth one \u2014\n\n    4\n. The cost of the path is \n    1 \n    \u00b7 4 + 1 \n    \u00b7 3 + 4 \n    \u00b7 2 +\n    4 \n    \u00b7 1 = 19\n.\n\n",
        "cf_contest_id": 1499,
        "cf_index": "C",
        "cf_rating": 1500,
        "difficulty": 0,
        "cf_tags": [
            "brute force",
            "data structures",
            "greedy",
            "math"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "3\r\n2\r\n13 88\r\n3\r\n2 3 1\r\n5\r\n4 3 2 1 4\r\n",
                "202\r\n13\r\n19\r\n"
            ]
        ],
        "private_cases": []
    }
]