[
    {
        "name": "Negative Time Summation",
        "description": "Everyone knows that computers become faster and faster. Recently Berland\nscientists have built a machine that can move itself back in time! More\nspecifically, it works as follows. It has an infinite grid and a robot which\nstands on one of the cells. Each cell of the grid can either be empty or\ncontain 0 or 1. The machine also has a program which consists of instructions,\nwhich are being handled one by one. Each instruction is represented by exactly\none symbol (letter or digit) and takes exactly one unit of time (say, second)\nto be performed, except the last type of operation (it's described below).\nHere they are: 0 or 1: the robot places this number into the cell he is\ncurrently at. If this cell wasn't empty before the operation, its previous\nnumber is replaced anyway. e: the robot erases the number into the cell he is\nat. l, r, u or d: the robot goes one cell to the left/right/up/down. s: the\nrobot stays where he is for a unit of time. t: let \n    x\n be \n    0\n, if the\ncell with the robot is empty, otherwise let \n    x\n be one more than the digit\nin this cell (that is, \n    x = 1\n if the digit in this cell is \n    0\n, and\n\n    x = 2\n if the digit is \n    1\n). Then the machine travels \n    x\n seconds\nback in time. Note that this doesn't change the instructions order, but it\nchanges the position of the robot and the numbers in the grid as they were\n\n    x\n units of time ago. You can consider this instruction to be equivalent\nto a Ctrl-Z pressed \n    x\n times. For example, let the board be completely\nempty, and the program be sr1t0. Let the robot initially be at \n    (0, 0)\n.\n[now is the moment \n    0\n, the command is s]: we do nothing. [now is the\nmoment \n    1\n, the command is r]: we are now at \n    (1, 0)\n. [now is the\nmoment \n    2\n, the command is 1]: we are at \n    (1, 0)\n, and this cell\ncontains \n    1\n. [now is the moment \n    3\n, the command is t]: we travel\n\n    1 + 1 = 2\n moments back, that is, to the moment \n    1\n. [now is the\nmoment \n    1\n, the command is 0]: we are again at \n    (0, 0)\n, and the board\nis clear again, but after we follow this instruction, this cell has \n    0\n in\nit. We've just rewritten the history. The consequences of the third\ninstruction have never happened. Now Berland scientists want to use their\nmachine in practice. For example, they want to be able to add two integers.\nAssume that the initial state of the machine is as follows: One positive\ninteger is written in binary on the grid in such a way that its right bit is\nat the cell \n    (0, 1)\n, from left to right from the highest bit to the\nlowest bit. The other positive integer is written in binary on the grid in\nsuch a way that its right bit is at the cell \n    (0, 0)\n, from left to right\nfrom the highest bit to the lowest bit. All the other cells are empty. The\nrobot is at \n    (0, 0)\n. We consider this state to be always in the past;\nthat is, if you manage to travel to any negative moment, the board was always\nas described above, and the robot was at \n    (0, 0)\n for eternity. You are\nasked to write a program after which The robot stands on a non-empty cell, If\nwe read the number starting from the cell with the robot and moving to the\nright until the first empty cell, this will be \n    a + b\n in binary, from the\nhighest bit to the lowest bit. Note that there are no restrictions on other\ncells. In particular, there may be a digit just to the left to the robot after\nall instructions. In each test you are given up to \n    1000\n pairs \n    (a,\n    b)\n, and your program must work for all these pairs. Also since the\nmachine's memory is not very big, your program must consist of no more than\n\n    10^5\n instructions. Input The first line contains the only integer\n\n    t\n (\n    1\n    \u2264 t\n    \u2264 1000\n) standing for the number of testcases. Each\nof the next \n    t\n lines consists of two positive integers \n    a\n and\n\n    b\n (\n    1\n    \u2264 a, b < 2^30\n) in decimal. Output Output the only line\nconsisting of no more than \n    10^5\n symbols from 01eslrudt standing for your\nprogram. Note that formally you may output different programs for different\ntests. Example Input 2 123456789 987654321 555555555 555555555 Output\n0l1l1l0l0l0l1l1l1l0l1l0l1l1l0l0l0l1l0l1l1l1l0l0l0l1l0l0l0l0l1l0lr\n\n",
        "cf_contest_id": 1078,
        "cf_index": "E",
        "cf_rating": 3400,
        "difficulty": 0,
        "cf_tags": [
            "constructive algorithms"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "2\r\n123456789 987654321\r\n555555555 555555555\r\n",
                "dd0usut0dtld0usut0dtld0usut0dtld0usut0dtld0usut0dtld0usut0dtld0usut0dtld0usut0dtld0usut0dtld0usut0dtld0usut0dtld0usut0dtld0usut0dtld0usut0dtld0usut0dtld0usut0dtld0usut0dtld0usut0dtld0usut0dtld0usut0dtld0usut0dtld0usut0dtld0usut0dtld0usut0dtld0usut0dtld0usut0dtld0usut0dtld0usut0dtld0usut0dtld0usut0dtld0usut0dtluuuru0dsdt0utru0dsdt0utru0dsdt0utru0dsdt0utru0dsdt0utru0dsdt0utru0dsdt0utru0dsdt0utru0dsdt0utru0dsdt0utru0dsdt0utru0dsdt0utru0dsdt0utru0dsdt0utru0dsdt0utru0dsdt0utru0dsdt0utru0dsdt0utru0dsdt0utru0dsdt..."
            ]
        ],
        "private_cases": []
    }
]