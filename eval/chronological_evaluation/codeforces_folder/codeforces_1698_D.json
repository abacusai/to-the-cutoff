[
    {
        "name": "Fixed Point Guessing",
        "description": "This is an interactive problem. Initially, there is an array \n    a = [1, 2,\n    \n    \u2026, n]\n, where \n    n\n is an odd positive integer. The jury has\nselected \n    n-1/2\n disjoint pairs of elements, and then the\nelements in those pairs are swapped. For example, if \n    a=[1,2,3,4,5]\n, and\nthe pairs \n    1 \n    \u2194 4\n and \n    3 \n    \u2194 5\n are\nswapped, then the resulting array is \n    [4, 2, 5, 1, 3]\n. As a result of\nthese swaps, exactly one element will not change position. You need to find\nthis element. To do this, you can ask several queries. In each query, you can\npick two integers \n    l\n and \n    r\n (\n    1 \n    \u2264 l \n    \u2264 r \n    \u2264 n\n). In\nreturn, you will be given the elements of the subarray \n    [a_l, a_l + 1,\n    \n    \u2026, a_r]\n sorted in increasing order. Find the element which did not\nchange position. You can make at most \n    15\n queries. The array\n\n    a\n is fixed before the interaction and does not change after your\nqueries. Recall that an array \n    b\n is a subarray of the array \n    a\n if\n\n    b\n can be obtained from \n    a\n by deletion of several (possibly, zero or\nall) elements from the beginning and several (possibly, zero or all) elements\nfrom the end. Input Each test contains multiple test cases. The first line\ncontains an integer \n    t\n (\n    1 \n    \u2264 t \n    \u2264 500\n) \u2014 the number of test\ncases. The description of the test cases follows. The first line of each test\ncase contains an integer \n    n\n (\n    3 \n    \u2264 n < 10^4\n; \n    n\n is odd) \u2014\nthe length of the array \n    a\n. After reading the first line of each test\ncase, you should begin the interaction. It is guaranteed that the sum of\n\n    n\n over all test cases does not exceed \n    10^4\n. Interaction For each\ntest case, begin the interaction by reading the integer \n    n\n. To make a\nquery, output \"\n    l\n     r\n\" (\n    1 \n    \u2264 l \n    \u2264 r \n    \u2264\n    n\n) without quotes. Afterwards, you should read in \n    r-l+1\n integers \u2014\nthe integers \n    a_l, a_l + 1, \n    \u2026, a_r\n, in increasing order. You can\nmake at most \n    15\n such queries in a single test case. If you receive the\ninteger \n    -1\n instead of an answer or the integer \n    n\n, it means your\nprogram has made an invalid query, has exceed the limit of queries, or has\ngiven incorrect answer on the previous test case. Your program must terminate\nimmediately to receive a Wrong Answer verdict. Otherwise you can get an\narbitrary verdict because your solution will continue to read from a closed\nstream. When you are ready to give the final answer, output\n\"\n    x\n\" (\n    1 \n    \u2264 x \n    \u2264 n\n) without quotes \u2014 the\nelement that did not change position. Giving this answer does not count\ntowards the limit of \n    15\n queries. Afterwards, your program must continue\nto solve the remaining test cases, or exit if all test cases have been solved.\nAfter printing a query do not forget to output end of line and flush the\noutput. Otherwise, you will get Idleness limit exceeded. To do this, use:\nfflush(stdout) or cout.flush() in C++; System.out.flush() in Java;\nflush(output) in Pascal; stdout.flush() in Python; see documentation for other\nlanguages. Hacks To make a hack, use the following format. The first line must\ncontain an integer \n    t\n (\n    1 \n    \u2264 t \n    \u2264 500\n) \u2014 the number of test\ncases. The description of the test cases follows. The first line of each test\ncase must contain an integer \n    n\n (\n    3 \n    \u2264 n < 10^4\n; \n    n\n is odd)\n\u2014 the length of the array \n    a\n. The second line of each test case must\ncontain \n    n\n space-separated integers \n    a_1, a_2, \n    \u2026, a_n\n (\n    1\n    \n    \u2264 a_i \n    \u2264 n\n) \u2014 the elements of \n    a\n. The array \n    a\n should be\nthe result of \n    n-1/2\n disjoint swaps on the array\n\n    [1,2,\n    \u2026,n]\n. Example Input 2 5 1 2 4 5 1 3 5 3 1 Output ? 1 4 ? 3 5\n! 2 ? 1 1 ! 1 Note In the first test, the interaction proceeds as follows.\nSolutionJuryExplanation\n    \nThere are 2 test\ncases.\n    \nIn the first test case, the hidden array is\n\n    [4,2,5,1,3]\n, with length \n    5\n.\n    \n\n    \nThe solution requests the subarray \n    [4,2,5,1]\n in increasing order,\nand the jury responds with \n    [1,2,4,5]\n.\n    \n\n    \nThe solution requests the subarray \n    [5,1,3]\n in\nincreasing order, and the jury responds with \n    [1,3,5]\n.\n    \nThe solution has somehow determined that \n    a_2=2\n, and outputs it.\nSince the output is correct, the jury continues to the next test\ncase.\n    \nIn the second test case, the hidden array is\n\n    [1,3,2]\n, with length \n    3\n.\n    \n\n    \nThe\nsolution requests the number \n    [1]\n only, and the jury responds with\n\n    [1]\n.\n    \nThe solution has determined that \n    a_1=1\n,\nand outputs it. Since the output is correct and there are no more test cases,\nthe jury and the solution exit. Note that the line breaks in the example input\nand output are for the sake of clarity, and do not occur in the real\ninteraction.\n\n",
        "cf_contest_id": 1698,
        "cf_index": "D",
        "cf_rating": 1600,
        "difficulty": 0,
        "cf_tags": [
            "binary search",
            "constructive algorithms",
            "interactive"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "2\r\n5\r\n4 2 5 1 3\r\n3\r\n1 3 2\r\n",
                "2\r\n1\r\n"
            ]
        ],
        "private_cases": []
    }
]