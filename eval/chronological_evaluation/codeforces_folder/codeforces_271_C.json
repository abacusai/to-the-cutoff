[
    {
        "name": "Secret",
        "description": "The Greatest Secret Ever consists of n words, indexed by positive integers\nfrom 1 to n. The secret needs dividing between k Keepers (let's index them by\npositive integers from 1 to k), the i-th Keeper gets a non-empty set of words\nwith numbers from the set Ui = (ui, 1, ui, 2, ..., ui, |Ui|). Here and below\nwe'll presuppose that the set elements are written in the increasing order.\nWe'll say that the secret is safe if the following conditions are hold: for\nany two indexes i, j (1 \u2264 i < j \u2264 k) the intersection of sets Ui and Uj is an\nempty set; the union of sets U1, U2, ..., Uk is set (1, 2, ..., n); in each\nset Ui, its elements ui, 1, ui, 2, ..., ui, |Ui| do not form an arithmetic\nprogression (in particular, |Ui| \u2265 3 should hold). Let us remind you that the\nelements of set (u1, u2, ..., us) form an arithmetic progression if there is\nsuch number d, that for all i (1 \u2264 i < s) fulfills ui + d = ui + 1. For\nexample, the elements of sets (5), (1, 10) and (1, 5, 9) form arithmetic\nprogressions and the elements of sets (1, 2, 4) and (3, 6, 8) don't. Your task\nis to find any partition of the set of words into subsets U1, U2, ..., Uk so\nthat the secret is safe. Otherwise indicate that there's no such partition.\nInput The input consists of a single line which contains two integers n and k\n(2 \u2264 k \u2264 n \u2264 10^6) \u2014 the number of words in the secret and the number of the\nKeepers. The numbers are separated by a single space. Output If there is no\nway to keep the secret safe, print a single integer \"-1\" (without the quotes).\nOtherwise, print n integers, the i-th of them representing the number of the\nKeeper who's got the i-th word of the secret. If there are multiple solutions,\nprint any of them. Examples Input 11 3 Output 3 1 2 1 1 2 3 2 2 3 1 Input 5 2\nOutput -1\n\n",
        "cf_contest_id": 271,
        "cf_index": "C",
        "cf_rating": 1500,
        "difficulty": 0,
        "cf_tags": [
            "constructive algorithms",
            "implementation"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "11 3\r\n",
                "3 2 3 2 1 1 3 2 3 2 1 "
            ],
            [
                "5 2\r\n",
                "-1"
            ]
        ],
        "private_cases": [
            [
                "2 2\r\n",
                "-1"
            ],
            [
                "3 2\r\n",
                "-1"
            ],
            [
                "6 2\r\n",
                "2 1 1 2 2 1 "
            ],
            [
                "999999 333334\r\n",
                "-1"
            ],
            [
                "9 3\r\n",
                "3 2 1 1 3 2 3 2 1 "
            ],
            [
                "365561 143151\r\n",
                "-1"
            ],
            [
                "950059 419028\r\n",
                "-1"
            ],
            [
                "20354 8642\r\n",
                "-1"
            ],
            [
                "18 6\r\n",
                "6 5 4 3 2 1 1 6 5 4 3 2 6 5 4 3 2 1 "
            ],
            [
                "10 2\r\n",
                "2 1 1 2 2 1 1 2 2 1 "
            ]
        ]
    }
]