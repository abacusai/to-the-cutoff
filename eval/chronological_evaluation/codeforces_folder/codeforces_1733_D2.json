[
    {
        "name": "Zero-One (Hard Version)",
        "description": "This is the hard version of this problem. In this version, \n    n \n    \u2264 5000\n\nholds, and this version has no restriction between \n    x\n and \n    y\n. You\ncan make hacks only if both versions of the problem are solved. You are given\ntwo binary strings \n    a\n and \n    b\n, both of length \n    n\n. You can do the\nfollowing operation any number of times (possibly zero). Select two indices\n\n    l\n and \n    r\n (\n    l < r\n). Change \n    a_l\n to \n    (1 - a_l)\n, and\n\n    a_r\n to \n    (1 - a_r)\n. If \n    l + 1 = r\n, the cost of the operation is\n\n    x\n. Otherwise, the cost is \n    y\n. You have to find the minimum cost\nneeded to make \n    a\n equal to \n    b\n or say there is no way to do so. Input\nThe first line contains one integer \n    t\n (\n    1 \n    \u2264 t \n    \u2264 1000\n) \u2014 the\nnumber of test cases. Each test case consists of three lines. The first line\nof each test case contains three integers \n    n\n, \n    x\n, and \n    y\n (\n    5\n    \n    \u2264 n \n    \u2264 5000\n, \n    1 \n    \u2264 x, y \n    \u2264 10^9\n) \u2014 the length of the\nstrings, and the costs per operation. The second line of each test case\ncontains the string \n    a\n of length \n    n\n. The string only consists of\ndigits \n    0\n and \n    1\n. The third line of each test case contains the\nstring \n    b\n of length \n    n\n. The string only consists of digits \n    0\n\nand \n    1\n. It is guaranteed that the sum of \n    n\n over all test cases\ndoesn't exceed \n    5000\n. Output For each test case, if there is no way to\nmake \n    a\n equal to \n    b\n, print \n    -1\n. Otherwise, print the minimum\ncost needed to make \n    a\n equal to \n    b\n. Example Input 6 5 8 9 01001\n00101 6 2 11 000001 100000 5 7 2 01000 11011 7 8 3 0111001 0100001 6 3 4\n010001 101000 5 10 1 01100 01100 Output 8 10 -1 6 7 0 Note In the first test\ncase, selecting indices \n    2\n and \n    3\n costs \n    8\n, which is the\nminimum. In the second test case, we can perform the following operations.\nSelect indices \n    1\n and \n    2\n. It costs \n    2\n, and \n    a\n is 110001\nnow. Select indices \n    2\n and \n    3\n. It costs \n    2\n, and \n    a\n is\n101001 now. Select indices \n    3\n and \n    4\n. It costs \n    2\n, and \n    a\n\nis 100101 now. Select indices \n    4\n and \n    5\n. It costs \n    2\n, and\n\n    a\n is 100011 now. Select indices \n    5\n and \n    6\n. It costs \n    2\n,\nand \n    a\n is 100000 now. The total cost is \n    10\n. In the third test case,\nwe cannot make \n    a\n equal to \n    b\n using any number of operations. In the\nfourth test case, we can perform the following operations. Select indices\n\n    3\n and \n    6\n. It costs \n    3\n, and \n    a\n is 0101011 now. Select\nindices \n    4\n and \n    6\n. It costs \n    3\n, and \n    a\n is 0100001 now. The\ntotal cost is \n    6\n. In the fifth test case, we can perform the following\noperations. Select indices \n    1\n and \n    6\n. It costs \n    4\n, and \n    a\n\nis 110000 now. Select indices \n    2\n and \n    3\n. It costs \n    3\n, and\n\n    a\n is 101000 now. The total cost is \n    7\n. In the sixth test case, we\ndon't have to perform any operation.\n\n",
        "cf_contest_id": 1733,
        "cf_index": "D2",
        "cf_rating": 2000,
        "difficulty": 0,
        "cf_tags": [
            "dp",
            "greedy"
        ],
        "time_limit_seconds": 3.0,
        "memory_limit_bytes": 512.0,
        "public_cases": [
            [
                "6\r\n5 8 9\r\n01001\r\n00101\r\n6 2 11\r\n000001\r\n100000\r\n5 7 2\r\n01000\r\n11011\r\n7 8 3\r\n0111001\r\n0100001\r\n6 3 4\r\n010001\r\n101000\r\n5 10 1\r\n01100\r\n01100\r\n",
                "8\r\n10\r\n-1\r\n6\r\n7\r\n0\r\n"
            ]
        ],
        "private_cases": []
    }
]