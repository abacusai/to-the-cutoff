[
    {
        "name": "Promising String (easy version)",
        "description": "This is the easy version of Problem F. The only difference between the easy\nversion and the hard version is the constraints. We will call a non-empty\nstring balanced if it contains the same number of plus and minus signs. For\nexample: strings \"+\u2013+\" and \"++-+\u2013\" are balanced, and strings \"+\u2013\", \"\u2013\" and\n\"\" are not balanced. We will call a string promising if the string can be made\nbalanced by several (possibly zero) uses of the following operation: replace\ntwo adjacent minus signs with one plus sign. In particular, every balanced\nstring is promising. However, the converse is not true: not every promising\nstring is balanced. For example, the string \"-+\u2014\" is promising, because you\ncan replace two adjacent minuses with plus and get a balanced string \"-++-\",\nor get another balanced string \"-+-+\". How many non-empty substrings of the\ngiven string \n    s\n are promising? Each non-empty promising substring must be\ncounted in the answer as many times as it occurs in string \n    s\n. Recall\nthat a substring is a sequence of consecutive characters of the string. For\nexample, for string \"+-+\" its substring are: \"+-\", \"-+\", \"+\", \"+-+\" (the\nstring is a substring of itself) and some others. But the following strings\nare not its substring: \"\u2013\", \"++\", \"-++\". Input The first line of the input\ncontains an integer \n    t\n (\n    1 \n    \u2264 t \n    \u2264 500\n) \u2014the number of test\ncases in the test. Then the descriptions of test cases follow. Each test case\nof input data consists of two lines. The first line consists of the number\n\n    n\n (\n    1 \n    \u2264 n \n    \u2264 3000\n): the length of \n    s\n. The second line\nof the test case contains the string \n    s\n of length \n    n\n, consisting\nonly of characters \"+\" and \"-\". It is guaranteed that the sum of values\n\n    n\n over all test cases does not exceed \n    3000\n. Output For each test\ncase, print a single number: the number of the promising non-empty substrings\nof string \n    s\n. Each non-empty promising substring must be counted in the\nanswer as many times as it occurs in string \n    s\n. Example Input 5 3 +-+ 5\n-+\u2014 4 \u00ad\u2014 7 \u00ad-+\u2014+ 6 +++\u2014 Output 2 4 2 7 4 Note The following are the\npromising substrings for the first three test cases in the example: \n    s[1\n    \n    \u2026 2]\n=\"+-\", \n    s[2 \n    \u2026 3]\n=\"-+\"; \n    s[1 \n    \u2026 2]\n=\"-+\",\n\n    s[2 \n    \u2026 3]\n=\"+-\", \n    s[1 \n    \u2026 5]\n=\"-+\u2014\", \n    s[3 \n    \u2026\n    5]\n=\"\u2014\"; \n    s[1 \n    \u2026 3]\n=\"\u2014\", \n    s[2 \n    \u2026 4]\n=\"\u2014\".\n\n",
        "cf_contest_id": 1660,
        "cf_index": "F1",
        "cf_rating": 1700,
        "difficulty": 0,
        "cf_tags": [
            "brute force",
            "implementation",
            "math",
            "strings"
        ],
        "time_limit_seconds": 3.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "5\r\n3\r\n+-+\r\n5\r\n-+---\r\n4\r\n----\r\n7\r\n--+---+\r\n6\r\n+++---\r\n",
                "2\r\n4\r\n2\r\n7\r\n4\r\n"
            ]
        ],
        "private_cases": []
    }
]