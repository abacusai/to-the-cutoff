[
    {
        "name": "MAX-MEX Cut",
        "description": "A binary string is a string that consists of characters \n    0\n and \n    1\n. A\nbi-table is a table that has exactly two rows of equal length, each being a\nbinary string. Let \n    MEX\n of a bi-table be the smallest\ndigit among \n    0\n, \n    1\n, or \n    2\n that does not occur in the bi-table.\nFor example, \n    MEX\n for \n    [ 0011; ; ; 1010;  ]\n is \n    2\n, because \n    0\n and \n    1\n occur in the\nbi-table at least once. \n    MEX\n for \n    [ 111; ; ; 111;  ]\n is \n    0\n, because \n    0\n and \n    2\n do\nnot occur in the bi-table, and \n    0 < 2\n. You are given a bi-table with\n\n    n\n columns. You should cut it into any number of bi-tables (each\nconsisting of consecutive columns) so that each column is in exactly one bi-\ntable. It is possible to cut the bi-table into a single bi-table \u2014 the whole\nbi-table. What is the maximal sum of \n    MEX\n of all\nresulting bi-tables can be? Input The input consists of multiple test cases.\nThe first line contains a single integer \n    t\n (\n    1 \n    \u2264 t \n    \u2264 10^4\n)\n\u2014 the number of test cases. Description of the test cases follows. The first\nline of the description of each test case contains a single integer \n    n\n\n(\n    1 \n    \u2264 n \n    \u2264 10^5\n) \u2014 the number of columns in the bi-table. Each of\nthe next two lines contains a binary string of length \n    n\n \u2014 the rows of\nthe bi-table. It's guaranteed that the sum of \n    n\n over all test cases does\nnot exceed \n    10^5\n. Output For each test case print a single integer \u2014 the\nmaximal sum of \n    MEX\n of all bi-tables that it is possible\nto get by cutting the given bi-table optimally. Example Input 4 7 0101000\n1101100 5 01100 10101 2 01 01 6 000000 111111 Output 8 8 2 12 Note In the\nfirst test case you can cut the bi-table as follows: \n    [ 0; ; ; 1;  ]\n, its \n    MEX\n is \n    2\n.\n\n    [ 10; ; ; 10;  ]\n, its\n\n    MEX\n is \n    2\n. \n    [ 1; ; ; 1;  ]\n, its \n    MEX\n is \n    0\n.\n\n    [ 0; ; ; 1;  ]\n, its\n\n    MEX\n is \n    2\n. \n    [ 0; ; ; 0;  ]\n, its \n    MEX\n is \n    1\n.\n\n    [ 0; ; ; 0;  ]\n, its\n\n    MEX\n is \n    1\n.The sum of \n    MEX\n is\n\n    8\n.\n\n",
        "cf_contest_id": 1566,
        "cf_index": "C",
        "cf_rating": 1000,
        "difficulty": 0,
        "cf_tags": [
            "bitmasks",
            "constructive algorithms",
            "dp",
            "greedy"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "4\r\n7\r\n0101000\r\n1101100\r\n5\r\n01100\r\n10101\r\n2\r\n01\r\n01\r\n6\r\n000000\r\n111111\r\n",
                "8\r\n8\r\n2\r\n12\r\n"
            ]
        ],
        "private_cases": []
    }
]