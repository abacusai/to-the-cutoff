[
    {
        "name": "Good Subarrays (Easy Version)",
        "description": "This is the easy version of this problem. In this version, we do not have\nqueries. Note that we have multiple test cases in this version. You can make\nhacks only if both versions of the problem are solved. An array \n    b\n of\nlength \n    m\n is good if for all \n    i\n the \n    i\n-th element is greater\nthan or equal to \n    i\n. In other words, \n    b\n is good if and only if\n\n    b_i \n    \u2265 i\n for all \n    i\n (\n    1 \n    \u2264 i \n    \u2264 m\n). You are given\nan array \n    a\n consisting of \n    n\n positive integers. Find the number of\npairs of indices \n    (l, r)\n, where \n    1 \n    \u2264 l \n    \u2264 r \n    \u2264 n\n, such\nthat the array \n    [a_l, a_l+1, \n    \u2026, a_r]\n is good. Input Each test\ncontains multiple test cases. The first line contains the number of test cases\n\n    t\n (\n    1 \n    \u2264 t \n    \u2264 2 \n    \u00b7 10^5\n). Description of the test\ncases follows. The first line of each test case contains an integer \n    n\n\n(\n    1 \n    \u2264 n \n    \u2264 2 \n    \u00b7 10^5\n), the length of the array \n    a\n. The\nsecond line of each test case contains \n    n\n space-separated integers\n\n    a_1,a_2,\n    \u2026,a_n\n (\n    1 \n    \u2264 a_i \n    \u2264 n\n), representing the\narray \n    a\n. It is guaranteed that the sum of \n    n\n over all test cases\ndoes not exceed \n    2 \n    \u00b7 10^5\n. Output For each test case, print the\nnumber of suitable pairs of indices. Example Input 3 3 1 2 3 3 1 1 1 4 2 1 4 3\nOutput 6 3 7 Note In the first test case, all subarrays of \n    a\n are good,\nso all pairs are suitable. In the second test case, the pairs \n    (1, 1)\n,\n\n    (2, 2)\n, and \n    (3, 3)\n are suitable. For example, when \n    (l, r) = (1,\n    2)\n, the array \n    b=[1,1]\n is not good because \n    b_2 < 2\n.\n\n",
        "cf_contest_id": 1736,
        "cf_index": "C1",
        "cf_rating": 1300,
        "difficulty": 0,
        "cf_tags": [
            "binary search",
            "data structures",
            "schedules",
            "two pointers"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "3\r\n3\r\n1 2 3\r\n3\r\n1 1 1\r\n4\r\n2 1 4 3\r\n",
                "6\r\n3\r\n7\r\n"
            ]
        ],
        "private_cases": []
    }
]