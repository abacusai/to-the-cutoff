[
    {
        "name": "Captain Flint and Treasure",
        "description": "Captain Fint is involved in another treasure hunt, but have found only one\nstrange problem. The problem may be connected to the treasure's location or\nmay not. That's why captain Flint decided to leave the solving the problem to\nhis crew and offered an absurdly high reward: one day off. The problem itself\nsounds like this... There are two arrays \n    a\n and \n    b\n of length\n\n    n\n. Initially, an \n    ans\n is equal to \n    0\n and the following\noperation is defined: Choose position \n    i\n (\n    1 \n    \u2264 i \n    \u2264 n\n); Add\n\n    a_i\n to \n    ans\n; If \n    b_i \n    \u2260 -1\n then add \n    a_i\n to\n\n    a_b_i\n. What is the maximum \n    ans\n you can get by performing the\noperation on each \n    i\n (\n    1 \n    \u2264 i \n    \u2264 n\n) exactly once? Uncle Bogdan\nis eager to get the reward, so he is asking your help to find the optimal\norder of positions to perform the operation on them. Input The first line\ncontains the integer \n    n\n (\n    1 \n    \u2264 n \n    \u2264 2 \n    \u00b7 10^5\n) \u2014 the\nlength of arrays \n    a\n and \n    b\n. The second line contains \n    n\n\nintegers \n    a_1, a_2, \n    \u2026, a_n\n (\n    \u221210^6 \n    \u2264 a_i \n    \u2264 10^6\n). The\nthird line contains \n    n\n integers \n    b_1, b_2, \n    \u2026, b_n\n (\n    1 \n    \u2264\n    b_i \n    \u2264 n\n or \n    b_i = -1\n). Additional constraint: it's guaranteed that\nfor any \n    i\n (\n    1 \n    \u2264 i \n    \u2264 n\n) the sequence \n    b_i, b_b_i,\n    b_b_b_i, \n    \u2026\n is not cyclic, in other words it will always end with\n\n    -1\n. Output In the first line, print the maximum \n    ans\n you can get.\nIn the second line, print the order of operations: \n    n\n different integers\n\n    p_1, p_2, \n    \u2026, p_n\n (\n    1 \n    \u2264 p_i \n    \u2264 n\n). The \n    p_i\n is\nthe position which should be chosen at the \n    i\n-th step. If there are\nmultiple orders, print any of them. Examples Input 3 1 2 3 2 3 -1 Output 10 1\n2 3 Input 2 -1 100 2 -1 Output 99 2 1 Input 10 -10 -1 2 2 5 -2 -3 -4 2 -6 -1\n-1 2 2 -1 5 5 7 7 9 Output -9 3 5 6 1 9 4 10 7 8 2\n\n",
        "cf_contest_id": 1388,
        "cf_index": "D",
        "cf_rating": 2000,
        "difficulty": 0,
        "cf_tags": [
            "data structures",
            "dfs and similar",
            "graphs",
            "greedy",
            "implementation",
            "trees"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "3\r\n1 2 3\r\n2 3 -1\r\n",
                "10\r\n1 2 3\r\n"
            ],
            [
                "2\r\n-1 100\r\n2 -1\r\n",
                "99\r\n2 1\r\n"
            ],
            [
                "10\r\n-10 -1 2 2 5 -2 -3 -4 2 -6\r\n-1 -1 2 2 -1 5 5 7 7 9\r\n",
                "-9\r\n3 4 2 9 5 7 10 8 6 1\r\n"
            ]
        ],
        "private_cases": []
    }
]