[
    {
        "name": "Zero-One (Easy Version)",
        "description": "This is the easy version of the problem. In this version, \n    n \n    \u2264 3000\n,\n\n    x \n    \u2265 y\n holds. You can make hacks only if both versions of the problem\nare solved. You are given two binary strings \n    a\n and \n    b\n, both of\nlength \n    n\n. You can do the following operation any number of times\n(possibly zero). Select two indices \n    l\n and \n    r\n (\n    l < r\n). Change\n\n    a_l\n to \n    (1 - a_l)\n, and \n    a_r\n to \n    (1 - a_r)\n. If \n    l + 1 =\n    r\n, the cost of the operation is \n    x\n. Otherwise, the cost is \n    y\n.\nYou have to find the minimum cost needed to make \n    a\n equal to \n    b\n or\nsay there is no way to do so. Input The first line contains one integer\n\n    t\n (\n    1 \n    \u2264 t \n    \u2264 600\n) \u2014 the number of test cases. Each test case\nconsists of three lines. The first line of each test case contains three\nintegers \n    n\n, \n    x\n, and \n    y\n (\n    5 \n    \u2264 n \n    \u2264 3000\n, \n    1 \n    \u2264\n    y \n    \u2264 x \n    \u2264 10^9\n) \u2014 the length of the strings, and the costs per\noperation. The second line of each test case contains the string \n    a\n of\nlength \n    n\n. The string only consists of digits \n    0\n and \n    1\n. The\nthird line of each test case contains the string \n    b\n of length \n    n\n.\nThe string only consists of digits \n    0\n and \n    1\n. It is guaranteed that\nthe sum of \n    n\n over all test cases doesn't exceed \n    3000\n. Output For\neach test case, if there is no way to make \n    a\n equal to \n    b\n, print\n\n    -1\n. Otherwise, print the minimum cost needed to make \n    a\n equal to\n\n    b\n. Example Input 4 5 8 7 01001 00101 5 7 2 01000 11011 7 8 3 0111001\n0100001 5 10 1 01100 01100 Output 8 -1 6 0 Note In the first test case,\nselecting indices \n    2\n and \n    3\n costs \n    8\n, which is the minimum\npossible cost. In the second test case, we cannot make \n    a\n equal to\n\n    b\n using any number of operations. In the third test case, we can perform\nthe following operations: Select indices \n    3\n and \n    6\n. It costs\n\n    3\n, and \n    a\n is 0101011 now. Select indices \n    4\n and \n    6\n. It\ncosts \n    3\n, and \n    a\n is 0100001 now. The total cost is \n    6\n. In the\nfourth test case, we don't have to perform any operations.\n\n",
        "cf_contest_id": 1733,
        "cf_index": "D1",
        "cf_rating": 1400,
        "difficulty": 0,
        "cf_tags": [
            "constructive algorithms",
            "greedy",
            "math"
        ],
        "time_limit_seconds": 3.0,
        "memory_limit_bytes": 512.0,
        "public_cases": [
            [
                "4\r\n5 8 7\r\n01001\r\n00101\r\n5 7 2\r\n01000\r\n11011\r\n7 8 3\r\n0111001\r\n0100001\r\n5 10 1\r\n01100\r\n01100\r\n",
                "8\r\n-1\r\n6\r\n0\r\n"
            ]
        ],
        "private_cases": []
    }
]