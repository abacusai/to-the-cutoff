[
    {
        "name": "Tree Diameter",
        "description": "There is a weighted tree with \n    n\n nodes and \n    n-1\n edges. The nodes are\nconveniently labeled from \n    1\n to \n    n\n. The weights are positive\nintegers at most \n    100\n. Define the distance between two nodes to be the\nsum of edges on the unique path between the nodes. You would like to find the\ndiameter of the tree. Diameter is the maximum distance between a pair of\nnodes. Unfortunately, the tree isn't given to you, but you can ask some\nquestions about it. In one question, you can specify two nonempty disjoint\nsets of nodes \n    p\n and \n    q\n, and the judge will return the maximum\ndistance between a node in \n    p\n and a node in \n    q\n. In the words,\nmaximum distance between \n    x\n and \n    y\n, where \n    x \n    \u2208 p\n and \n    y\n    \n    \u2208 q\n. After asking not more than \n    9\n questions, you must report the\nmaximum distance between any pair of nodes. Interaction Each test contains\nmultiple test cases. The first line contains the number of test cases \n    t\n\n(\n    1 \n    \u2264 t \n    \u2264 1\n     000\n). Description of the test cases follows. The\nfirst line of each test case contains an integer \n    n\n (\n    2 \n    \u2264 n \n    \u2264\n    100\n) \u2014 the number of nodes in the tree. To ask a question, print \"\n    k_1\n    k_2\n     a_1\n     a_2\n     \n    \u2026\n     a_k_1\n     b_1\n     b_2\n     \n    \u2026\n    b_k_2\n\" \n    (k_1, k_2 \n    \u2265 1\n and \n    k_1+k_2 \n    \u2264 n\n). These two\nsets must be nonempty and disjoint. The judge will respond with a single\ninteger \n    max_p,q dist(a_p, b_q)\n. If you ever get a result of\n\n    -1\n (because you printed an invalid query), exit immediately to avoid\ngetting other verdicts. After printing a query do not forget to output end of\nline and flush the output. Otherwise, you will get Idleness limit exceeded. To\ndo this, use: fflush(stdout) or cout.flush() in C++; System.out.flush() in\nJava; flush(output) in Pascal; stdout.flush() in Python; see documentation for\nother languages.When you are ready to answer, print \"\n    -1\n     d\n\", where\n\n    d\n is the maximum shortest distance over all pairs of nodes. You can only\nask at most \n    9\n questions per test case. Hack Format To hack, use the\nfollowing format. Note that you can only hack with one test case. The first\nline should contain a single integer \n    t\n (\n    t=1\n). The second line\nshould contain a single integer \n    n\n (\n    2 \n    \u2264 n \n    \u2264 100\n). Each of\nthe next \n    n-1\n lines should contain three integers \n    a_i, b_i, c_i\n\n(\n    1\n    \u2264 a_i, b_i\n    \u2264 n\n, \n    1 \n    \u2264 c_i \n    \u2264 100\n). This denotes\nan undirected edge between nodes \n    a_i\n and \n    b_i\n with weight\n\n    c_i\n. These edges must form a tree. Example Input 2 5 9 6 10 9 10 2 99\nOutput 1 4 1 2 3 4 5 1 4 2 3 4 5 1 1 4 3 4 5 1 2 1 4 4 5 1 2 3 1 4 5 1 2 3 4\n-1 10 1 1 1 2 -1 99 Note In the first example, the first tree looks as\nfollows: In the first question, we have \n    p = 1\n, and \n    q = 2, 3, 4,\n    5\n. The maximum distance between a node in \n    p\n and a node in \n    q\n is\n\n    9\n (the distance between nodes \n    1\n and \n    5\n). The second tree is a\ntree with two nodes with an edge with weight \n    99\n between them.\n\n",
        "cf_contest_id": 1146,
        "cf_index": "C",
        "cf_rating": 1700,
        "difficulty": 0,
        "cf_tags": [
            "bitmasks",
            "graphs",
            "interactive"
        ],
        "time_limit_seconds": 4.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "2\r\n5\r\n1 2 3\r\n2 3 4\r\n2 4 5\r\n4 5 1\r\n2\r\n1 2 99\r\n",
                "10\r\n99\r\n"
            ]
        ],
        "private_cases": []
    }
]