[
    {
        "name": "Beautiful Numbers",
        "description": "You are given a permutation \n    p=[p_1, p_2, \n    \u2026, p_n]\n of integers from\n\n    1\n to \n    n\n. Let's call the number \n    m\n (\n    1 \n    \u2264 m \n    \u2264 n\n)\nbeautiful, if there exists two indices \n    l, r\n (\n    1 \n    \u2264 l \n    \u2264 r \n    \u2264\n    n\n), such that the numbers \n    [p_l, p_l+1, \n    \u2026, p_r]\n is a\npermutation of numbers \n    1, 2, \n    \u2026, m\n. For example, let \n    p = [4, 5,\n    1, 3, 2, 6]\n. In this case, the numbers \n    1, 3, 5, 6\n are beautiful and\n\n    2, 4\n are not. It is because: if \n    l = 3\n and \n    r = 3\n we will have\na permutation \n    [1]\n for \n    m = 1\n; if \n    l = 3\n and \n    r = 5\n we\nwill have a permutation \n    [1, 3, 2]\n for \n    m = 3\n; if \n    l = 1\n and\n\n    r = 5\n we will have a permutation \n    [4, 5, 1, 3, 2]\n for \n    m = 5\n;\nif \n    l = 1\n and \n    r = 6\n we will have a permutation \n    [4, 5, 1, 3, 2,\n    6]\n for \n    m = 6\n; it is impossible to take some \n    l\n and \n    r\n, such\nthat \n    [p_l, p_l+1, \n    \u2026, p_r]\n is a permutation of numbers \n    1, 2,\n    \n    \u2026, m\n for \n    m = 2\n and for \n    m = 4\n. You are given a\npermutation \n    p=[p_1, p_2, \n    \u2026, p_n]\n. For all \n    m\n (\n    1 \n    \u2264 m\n    \n    \u2264 n\n) determine if it is a beautiful number or not. Input The first line\ncontains the only integer \n    t\n (\n    1 \n    \u2264 t \n    \u2264 1000\n) \u2014 the number of\ntest cases in the input. The next lines contain the description of test cases.\nThe first line of a test case contains a number \n    n\n (\n    1 \n    \u2264 n \n    \u2264 2\n    \n    \u00b7 10^5\n) \u2014 the length of the given permutation \n    p\n. The next line\ncontains \n    n\n integers \n    p_1, p_2, \n    \u2026, p_n\n (\n    1 \n    \u2264 p_i \n    \u2264\n    n\n, all \n    p_i\n are different) \u2014 the given permutation \n    p\n. It is\nguaranteed, that the sum of \n    n\n from all test cases in the input doesn't\nexceed \n    2 \n    \u00b7 10^5\n. Output Print \n    t\n lines \u2014 the answers to test\ncases in the order they are given in the input. The answer to a test case is\nthe string of length \n    n\n, there the \n    i\n-th character is equal to\n\n    1\n if \n    i\n is a beautiful number and is equal to \n    0\n if \n    i\n is\nnot a beautiful number. Example Input 3 6 4 5 1 3 2 6 5 5 3 1 2 4 4 1 4 3 2\nOutput 101011 11111 1001 Note The first test case is described in the problem\nstatement. In the second test case all numbers from \n    1\n to \n    5\n are\nbeautiful: if \n    l = 3\n and \n    r = 3\n we will have a permutation \n    [1]\n\nfor \n    m = 1\n; if \n    l = 3\n and \n    r = 4\n we will have a permutation\n\n    [1, 2]\n for \n    m = 2\n; if \n    l = 2\n and \n    r = 4\n we will have a\npermutation \n    [3, 1, 2]\n for \n    m = 3\n; if \n    l = 2\n and \n    r = 5\n we\nwill have a permutation \n    [3, 1, 2, 4]\n for \n    m = 4\n; if \n    l = 1\n and\n\n    r = 5\n we will have a permutation \n    [5, 3, 1, 2, 4]\n for \n    m = 5\n.\n\n",
        "cf_contest_id": 1265,
        "cf_index": "B",
        "cf_rating": 1300,
        "difficulty": 0,
        "cf_tags": [
            "data structures",
            "implementation",
            "math",
            "two pointers"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "3\r\n6\r\n4 5 1 3 2 6\r\n5\r\n5 3 1 2 4\r\n4\r\n1 4 3 2\r\n",
                "101011\r\n11111\r\n1001\r\n"
            ]
        ],
        "private_cases": []
    }
]