[
    {
        "name": "Anti-Fibonacci Permutation",
        "description": "Let's call a permutation \n    p\n of length \n    n\n anti-Fibonacci if the\ncondition \n    p_i-2 + p_i-1\n     p_i\n holds for all \n    i\n (\n    3 \n    \u2264\n    i \n    \u2264 n\n). Recall that the permutation is the array of length \n    n\n\nwhich contains each integer from \n    1\n to \n    n\n exactly once. Your task is\nfor a given number \n    n\n print \n    n\n distinct anti-Fibonacci permutations\nof length \n    n\n. Input The first line contains a single integer \n    t\n\n(\n    1 \n    \u2264 t \n    \u2264 48\n) \u2014 the number of test cases. The single line of each\ntest case contains a single integer \n    n\n (\n    3 \n    \u2264 n \n    \u2264 50\n). Output\nFor each test case, print \n    n\n lines. Each line should contain an anti-\nFibonacci permutation of length \n    n\n. In each test case, you cannot print\nany permutation more than once. If there are multiple answers, print any of\nthem. It can be shown that it is always possible to find \n    n\n different\nanti-Fibonacci permutations of size \n    n\n under the constraints of the\nproblem. Example Input 2 4 3 Output 4 1 3 2 1 2 4 3 3 4 1 2 2 4 1 3 3 2 1 1 3\n2 3 1 2\n\n",
        "cf_contest_id": 1644,
        "cf_index": "B",
        "cf_rating": 800,
        "difficulty": 0,
        "cf_tags": [
            "brute force",
            "constructive algorithms",
            "implementation"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "2\r\n4\r\n3\r\n",
                "1 4 3 2\r\n2 4 3 1\r\n3 4 2 1\r\n4 3 2 1\r\n1 3 2\r\n2 3 1\r\n3 2 1\r\n"
            ]
        ],
        "private_cases": []
    }
]