[
    {
        "name": "Blocking Chips",
        "description": "You are given a tree, consisting of \n    n\n vertices. There are \n    k\n chips,\nplaced in vertices \n    a_1, a_2, \n    \u2026, a_k\n. All \n    a_i\n are distinct.\nVertices \n    a_1, a_2, \n    \u2026, a_k\n are colored black initially. The\nremaining vertices are white. You are going to play a game where you perform\nsome moves (possibly, zero). On the \n    i\n-th move (\n    1\n-indexed) you are\ngoing to move the \n    ((i - 1) \n     k + 1)\n-st chip from its current\nvertex to an adjacent white vertex and color that vertex black. So, if\n\n    k=3\n, you move chip \n    1\n on move \n    1\n, chip \n    2\n on move\n\n    2\n, chip \n    3\n on move \n    3\n, chip \n    1\n on move \n    4\n, chip\n\n    2\n on move \n    5\n and so on. If there is no adjacent white vertex, then\nthe game ends. What's the maximum number of moves you can perform? Input The\nfirst line contains a single integer \n    t\n (\n    1 \n    \u2264 t \n    \u2264 10^4\n) \u2014\nthe number of testcases. The first line of each testcase contains a single\ninteger \n    n\n (\n    1 \n    \u2264 n \n    \u2264 2 \n    \u00b7 10^5\n) \u2014 the number of\nvertices of the tree. Each of the next \n    n - 1\n lines contains two integers\n\n    v\n and \n    u\n (\n    1 \n    \u2264 v, u \n    \u2264 n\n) \u2014 the descriptions of the\nedges. The given edges form a tree. The next line contains a single integer\n\n    k\n (\n    1 \n    \u2264 k \n    \u2264 n\n) \u2014 the number of chips. The next line\ncontains \n    k\n integers \n    a_1, a_2, \n    \u2026, a_k\n (\n    1 \n    \u2264 a_i \n    \u2264\n    n\n) \u2014 the vertices with the chips. All \n    a_i\n are distinct. The sum of\n\n    n\n over all testcases doesn't exceed \n    2 \n    \u00b7 10^5\n. Output For\neach testcase, print a single integer \u2014 the maximum number of moves you can\nperform. Example Input 5 5 1 2 2 3 3 4 4 5 1 3 5 1 2 2 3 3 4 4 5 2 1 2 5 1 2 2\n3 3 4 4 5 2 2 1 6 1 2 1 3 2 4 2 5 3 6 3 1 4 6 1 1 1 Output 2 0 1 2 0\n\n",
        "cf_contest_id": 1795,
        "cf_index": "F",
        "cf_rating": 2400,
        "difficulty": 0,
        "cf_tags": [
            "binary search",
            "constructive algorithms",
            "dfs and similar",
            "greedy",
            "trees"
        ],
        "time_limit_seconds": 3.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "5\r\n5\r\n1 2\r\n2 3\r\n3 4\r\n4 5\r\n1\r\n3\r\n5\r\n1 2\r\n2 3\r\n3 4\r\n4 5\r\n2\r\n1 2\r\n5\r\n1 2\r\n2 3\r\n3 4\r\n4 5\r\n2\r\n2 1\r\n6\r\n1 2\r\n1 3\r\n2 4\r\n2 5\r\n3 6\r\n3\r\n1 4 6\r\n1\r\n1\r\n1\r\n",
                "2\r\n0\r\n1\r\n2\r\n0\r\n"
            ]
        ],
        "private_cases": []
    }
]