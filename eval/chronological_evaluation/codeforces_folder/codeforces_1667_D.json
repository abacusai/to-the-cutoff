[
    {
        "name": "Edge Elimination",
        "description": "You are given a tree (connected, undirected, acyclic graph) with \n    n\n\nvertices. Two edges are adjacent if they share exactly one endpoint. In one\nmove you can remove an arbitrary edge, if that edge is adjacent to an even\nnumber of remaining edges. Remove all of the edges, or determine that it is\nimpossible. If there are multiple solutions, print any. Input The input\nconsists of multiple test cases. The first line contains a single integer\n\n    t\n (\n    1 \n    \u2264 t \n    \u2264 10^5\n) \u2014 the number of test cases. The\ndescription of the test cases follows. The first line of each test case\ncontains a single integer \n    n\n (\n    2 \n    \u2264 n \n    \u2264 2 \n    \u00b7 10^5\n) \u2014 the\nnumber of vertices in the tree. Then \n    n-1\n lines follow. The \n    i\n-th of\nthem contains two integers \n    u_i\n, \n    v_i\n (\n    1 \n    \u2264 u_i,v_i \n    \u2264\n    n\n) the endpoints of the \n    i\n-th edge. It is guaranteed that the given\ngraph is a tree. It is guaranteed that the sum of \n    n\n over all test cases\ndoes not exceed \n    2 \n    \u00b7 10^5\n. Output For each test case print \"NO\" if\nit is impossible to remove all the edges. Otherwise print \"YES\", and in the\nnext \n    n-1\n lines print a possible order of the removed edges. For each\nedge, print its endpoints in any order. Example Input 5 2 1 2 3 1 2 2 3 4 1 2\n2 3 3 4 5 1 2 2 3 3 4 3 5 7 1 2 1 3 2 4 2 5 3 6 3 7 Output YES 2 1 NO YES 2 3\n3 4 2 1 YES 3 5 2 3 2 1 4 3 NO Note Test case \n    1\n: it is possible to\nremove the edge, because it is not adjacent to any other edge. Test case\n\n    2\n: both edges are adjacent to exactly one edge, so it is impossible to\nremove any of them. So the answer is \"NO\". Test case \n    3\n: the edge\n\n    2-3\n is adjacent to two other edges. So it is possible to remove it.\nAfter that removal it is possible to remove the remaining edges too.\n\n",
        "cf_contest_id": 1667,
        "cf_index": "D",
        "cf_rating": 2900,
        "difficulty": 0,
        "cf_tags": [
            "constructive algorithms",
            "dfs and similar",
            "dp",
            "trees"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "5\r\n2\r\n1 2\r\n3\r\n1 2\r\n2 3\r\n4\r\n1 2\r\n2 3\r\n3 4\r\n5\r\n1 2\r\n2 3\r\n3 4\r\n3 5\r\n7\r\n1 2\r\n1 3\r\n2 4\r\n2 5\r\n3 6\r\n3 7\r\n",
                "YES\r\n2 1\r\nNO\r\nYES\r\n3 2\r\n4 3\r\n2 1\r\nYES\r\n5 3\r\n3 2\r\n4 3\r\n2 1\r\nNO\r\n"
            ]
        ],
        "private_cases": []
    }
]