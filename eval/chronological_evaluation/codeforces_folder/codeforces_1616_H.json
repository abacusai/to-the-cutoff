[
    {
        "name": "Keep XOR Low",
        "description": "You are given an array \n    a_1, a_2, \n    \u2026, a_n\n and an integer \n    x\n.\nFind the number of non-empty subsets of indices of this array \n    1 \n    \u2264 b_1\n    < b_2 < \n    \u2026 < b_k \n    \u2264 n\n, such that for all pairs \n    (i, j)\n where\n\n    1 \n    \u2264 i < j \n    \u2264 k\n, the inequality \n    a_b_i\n    \u2295 a_b_j\n    \u2264 x\n is held. Here, \n    \u2295\n denotes the bitwise XOR operation.\nAs the answer may be very large, output it modulo \n    998\n     244\n     353\n.\nInput The first line of the input contains two integers \n    n\n and \n    x\n\n(\n    1 \n    \u2264 n \n    \u2264 150\n     000\n, \n    0 \n    \u2264 x < 2^30\n). Here, \n    n\n\nis the size of the array. The next line contains \n    n\n integers \n    a_1, a_2,\n    \n    \u2026, a_n\n (\n    0 \n    \u2264 a_i < 2^30\n): the array itself. Output Print\none integer: the number of non-empty subsets such that the bitwise XOR of\nevery pair of elements is at most \n    x\n, modulo \n    998\n     244\n     353\n.\nExamples Input 4 2 0 1 2 3 Output 8 Input 3 6 4 2 2 Output 7 Input 4 0 1 1 2 2\nOutput 6\n\n",
        "cf_contest_id": 1616,
        "cf_index": "H",
        "cf_rating": 3000,
        "difficulty": 0,
        "cf_tags": [
            "bitmasks",
            "combinatorics",
            "data structures",
            "divide and conquer",
            "dp",
            "math"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "4 2\r\n0 1 2 3\r\n",
                "8\r\n"
            ],
            [
                "3 6\r\n4 2 2\r\n",
                "7\r\n"
            ],
            [
                "4 0\r\n1 1 2 2\r\n",
                "6\r\n"
            ]
        ],
        "private_cases": [
            [
                "2 1\r\n4 2\r\n",
                "2\r\n"
            ]
        ]
    }
]