[
    {
        "name": "Decent Division",
        "description": "A binary string is a string where every character is \n    \n or\n\n    \n. Call a binary string decent if it has an equal number of\n\n    \ns and \n    \ns. Initially, you have an infinite\nbinary string \n    t\n whose characters are all \n    \ns. You are\ngiven a sequence \n    a\n of \n    n\n updates, where \n    a_i\n indicates that\nthe character at index \n    a_i\n will be flipped (\n    \u2194\n). You need to keep and modify after each\nupdate a set \n    S\n of disjoint ranges such that: for each range \n    [l,r]\n,\nthe substring \n    t_l \n    \u2026 t_r\n is a decent binary string, and for all\nindices \n    i\n such that \n    t_i =\n, there exists \n    [l,r]\n\nin \n    S\n such that \n    l \n    \u2264 i \n    \u2264 r\n. You only need to output the\nranges that are added to or removed from \n    S\n after each update. You can\nonly add or remove ranges from \n    S\n at most \n    10^6\n times.\nMore formally, let \n    S_i\n be the set of ranges after the \n    i\n-th update,\nwhere \n    S_0 = \n    \u2205\n (the empty set). Define \n    X_i\n to be the\nset of ranges removed after update \n    i\n, and \n    Y_i\n to be the set of\nranges added after update \n    i\n. Then for \n    1 \n    \u2264 i \n    \u2264 n\n, \n    S_i\n    = (S_i - 1\n    \u2216 X_i) \n    \u222a Y_i\n. The following should hold for all\n\n    1 \n    \u2264 i \n    \u2264 n\n: \n    \u2200 a,b \n    \u2208 S_i, (a \n    \u2260 b)\n    \n    \u2192 (a \n    \u2229 b = \n    \u2205)\n; \n    X_i \n    \u2286 S_i -\n    1\n; \n    (S_i-1\n    \u2216 X_i) \n    \u2229 Y_i = \n    \u2205\n;\n\n    \u2211_i = 1^n (|X_i| + |Y_i|)\n    \u2264 10^6\n. Input The\nfirst line contains a single integer \n    n\n (\n    1 \n    \u2264 n \n    \u2264 2 \n    \u00b7\n    10^5\n) \u2014 the number of updates. The next \n    n\n lines each contain a single\ninteger \n    a_i\n (\n    1 \n    \u2264 a_i \n    \u2264 2 \n    \u00b7 10^5\n) \u2014 the index of\nthe \n    i\n-th update to the string. Output After the \n    i\n-th update, first\noutput a single integer \n    x_i\n \u2014 the number of ranges to be removed from\n\n    S\n after update \n    i\n. In the following \n    x_i\n lines, output two\nintegers \n    l\n and \n    r\n (\n    1 \n    \u2264 l < r \n    \u2264 10^6\n), which denotes\nthat the range \n    [l,r]\n should be removed from \n    S\n. Each of these\nranges should be distinct and be part of \n    S\n. In the next line, output a\nsingle integer \n    y_i\n \u2014 the number of ranges to be added to \n    S\n after\nupdate \n    i\n. In the following \n    y_i\n lines, output two integers \n    l\n\nand \n    r\n (\n    1 \n    \u2264 l < r \n    \u2264 10^6\n), which denotes that the range\n\n    [l,r]\n should be added to \n    S\n. Each of these ranges should be\ndistinct and not be part of \n    S\n. The total number of removals and\nadditions across all updates must not exceed \n    10^6\n. After\nprocessing the removals and additions for each update, all the ranges in\n\n    S\n should be disjoint and cover all ones. It can be proven that an answer\nalways exists under these constraints. Example Input 5 1 6 5 5 6 Output 0 1 1\n2 0 1 5 6 1 5 6 2 6 7 4 5 1 4 5 0 1 6 7 0 Note Line breaks are provided in the\nsample only for the sake of clarity, and you don't need to print them in your\noutput. After the first update, the set of indices where \n    a_i = 1\n is\n\n    1\n. The interval \n    [1, 2]\n is added, so \n    S_1 = \n    \n    [1,\n    2]\n, which has one \n    \n and one \n    \n. After\nthe second update, the set of indices where \n    a_i = 1\n is \n    1,\n    6\n. The interval \n    [5, 6]\n is added, so \n    S_2 = \n    \n    [1, 2], [5,\n    6]\n, each of which has one \n    \n and one\n\n    \n. After the third update, the set of indices where \n    a_i =\n    1\n is \n    1, 5, 6\n. The interval \n    [5, 6]\n is removed and the\nintervals \n    [4, 5]\n and \n    [6, 7]\n are added, so \n    S_3 = \n    \n    [1, 2],\n    [4, 5], [6, 7]\n, each of which has one \n    \n and one\n\n    \n. After the fourth update, the set of indices where \n    a_i =\n    1\n is \n    1, 6\n. The interval \n    [4, 5]\n is removed, so \n    S_4\n    = \n    \n    [1, 2], [6, 7]\n, each of which has one \n    \n and\none \n    \n. After the fifth update, the set of indices where\n\n    a_i = 1\n is \n    1\n. The interval \n    [6, 7]\n is removed, so\n\n    S_5 = \n    \n    [1, 2]\n, which has one \n    \n and one\n\n    \n.\n\n",
        "cf_contest_id": 1758,
        "cf_index": "F",
        "cf_rating": 3000,
        "difficulty": 0,
        "cf_tags": [
            "constructive algorithms",
            "data structures"
        ],
        "time_limit_seconds": 5.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "5\r\n1\r\n6\r\n5\r\n5\r\n6\r\n",
                "0\r\n1\r\n1 2\r\n\r\n0\r\n1\r\n6 7\r\n\r\n1\r\n6 7\r\n1\r\n5 8\r\n\r\n1\r\n5 8\r\n1\r\n6 7\r\n\r\n1\r\n6 7\r\n0\r\n\r\n"
            ]
        ],
        "private_cases": []
    }
]