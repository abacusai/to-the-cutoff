[
    {
        "name": "Gifts Fixing",
        "description": "You have \n    n\n gifts and you want to give all of them to children. Of\ncourse, you don't want to offend anyone, so all gifts should be equal between\neach other. The \n    i\n-th gift consists of \n    a_i\n candies and \n    b_i\n\noranges. During one move, you can choose some gift \n    1 \n    \u2264 i \n    \u2264 n\n and\ndo one of the following operations: eat exactly one candy from this gift\n(decrease \n    a_i\n by one); eat exactly one orange from this gift (decrease\n\n    b_i\n by one); eat exactly one candy and exactly one orange from this gift\n(decrease both \n    a_i\n and \n    b_i\n by one). Of course, you can not eat a\ncandy or orange if it's not present in the gift (so neither \n    a_i\n nor\n\n    b_i\n can become less than zero). As said above, all gifts should be\nequal. This means that after some sequence of moves the following two\nconditions should be satisfied: \n    a_1 = a_2 = \n    \u2026 = a_n\n and \n    b_1 =\n    b_2 = \n    \u2026 = b_n\n (and \n    a_i\n equals \n    b_i\n is not necessary). Your\ntask is to find the minimum number of moves required to equalize all the given\ngifts. You have to answer \n    t\n independent test cases. Input The first line\nof the input contains one integer \n    t\n (\n    1 \n    \u2264 t \n    \u2264 1000\n) \u2014 the\nnumber of test cases. Then \n    t\n test cases follow. The first line of the\ntest case contains one integer \n    n\n (\n    1 \n    \u2264 n \n    \u2264 50\n) \u2014 the number\nof gifts. The second line of the test case contains \n    n\n integers \n    a_1,\n    a_2, \n    \u2026, a_n\n (\n    1 \n    \u2264 a_i \n    \u2264 10^9\n), where \n    a_i\n is the\nnumber of candies in the \n    i\n-th gift. The third line of the test case\ncontains \n    n\n integers \n    b_1, b_2, \n    \u2026, b_n\n (\n    1 \n    \u2264 b_i \n    \u2264\n    10^9\n), where \n    b_i\n is the number of oranges in the \n    i\n-th gift.\nOutput For each test case, print one integer: the minimum number of moves\nrequired to equalize all the given gifts. Example Input 5 3 3 5 6 3 2 3 5 1 2\n3 4 5 5 4 3 2 1 3 1 1 1 2 2 2 6 1 1000000000 1000000000 1000000000 1000000000\n1000000000 1 1 1 1 1 1 3 10 12 8 7 5 4 Output 6 16 0 4999999995 7 Note In the\nfirst test case of the example, we can perform the following sequence of\nmoves: choose the first gift and eat one orange from it, so \n    a = [3, 5,\n    6]\n and \n    b = [2, 2, 3]\n; choose the second gift and eat one candy from\nit, so \n    a = [3, 4, 6]\n and \n    b = [2, 2, 3]\n; choose the second gift and\neat one candy from it, so \n    a = [3, 3, 6]\n and \n    b = [2, 2, 3]\n; choose\nthe third gift and eat one candy and one orange from it, so \n    a = [3, 3,\n    5]\n and \n    b = [2, 2, 2]\n; choose the third gift and eat one candy from\nit, so \n    a = [3, 3, 4]\n and \n    b = [2, 2, 2]\n; choose the third gift and\neat one candy from it, so \n    a = [3, 3, 3]\n and \n    b = [2, 2, 2]\n.\n\n",
        "cf_contest_id": 1399,
        "cf_index": "B",
        "cf_rating": 800,
        "difficulty": 0,
        "cf_tags": [
            "greedy"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "5\r\n3\r\n3 5 6\r\n3 2 3\r\n5\r\n1 2 3 4 5\r\n5 4 3 2 1\r\n3\r\n1 1 1\r\n2 2 2\r\n6\r\n1 1000000000 1000000000 1000000000 1000000000 1000000000\r\n1 1 1 1 1 1\r\n3\r\n10 12 8\r\n7 5 4\r\n",
                "6\r\n16\r\n0\r\n4999999995\r\n7\r\n"
            ]
        ],
        "private_cases": []
    }
]