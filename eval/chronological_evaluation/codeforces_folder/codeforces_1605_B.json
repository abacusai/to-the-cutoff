[
    {
        "name": "Reverse Sort",
        "description": "Ashish has a binary string \n    s\n of length \n    n\n that he wants to sort in\nnon-decreasing order. He can perform the following operation: Choose a\nsubsequence of any length such that its elements are in non-increasing order.\nFormally, choose any \n    k\n such that \n    1 \n    \u2264 k \n    \u2264 n\n and any\nsequence of \n    k\n indices \n    1 \n    \u2264 i_1 \n     i_2 \n    \n    \u2026\n     i_k\n    \n    \u2264 n\n such that \n    s_i_1\n    \u2265 s_i_2\n    \u2265\n    \u2026\n    \u2265 s_i_k\n.\nReverse this subsequence in-place. Formally, swap \n    s_i_1\n with\n\n    s_i_k\n, swap \n    s_i_2\n with \n    s_i_k-1\n, \n    \u2026\n and\nswap \n    s_i_\n    \u230a k/2 \n    \u230b\n with \n    s_i_\n    \u2308 k/2 \n    \u2309\n    + 1\n (Here \n    \u230a x \n    \u230b\n denotes the largest integer not\nexceeding \n    x\n, and \n    \u2308 x \n    \u2309\n denotes the smallest integer\nnot less than \n    x\n) Find the minimum number of operations required to sort\nthe string in non-decreasing order. It can be proven that it is always\npossible to sort the given binary string in at most \n    n\n operations. Input\nThe first line contains a single integer \n    t\n \n    (1 \n    \u2264 t \n    \u2264 1000)\n\n\u2014 the number of test cases. The description of the test cases follows. The\nfirst line of each test case contains an integer \n    n\n \n    (1 \n    \u2264 n \n    \u2264\n    1000)\n \u2014 the length of the binary string \n    s\n. The second line of each\ntest case contains a binary string \n    s\n of length \n    n\n containing only\n\n    0\ns and \n    1\ns. It is guaranteed that the sum of \n    n\n over all test\ncases does not exceed \n    1000\n. Output For each test case output the\nfollowing: The minimum number of operations \n    m\n in the first line (\n    0\n    \n    \u2264 m \n    \u2264 n\n). Each of the following \n    m\n lines should be of the\nform: \n    k\n \n    i_1\n \n    i_2\n ... \n    i_k\n, where \n    k\n is the length\nand \n    i_1 \n     i_2 \n     ... \n     i_k\n are the indices of the chosen\nsubsequence. For them the conditions from the statement must hold. Example\nInput 3 7 0011111 5 10100 6 001000 Output 0 1 4 1 3 4 5 1 3 3 5 6 Note In the\nfirst test case, the binary string is already sorted in non-decreasing order.\nIn the second test case, we can perform the following operation: \n    k = 4:\n\nchoose the indices \n    1, 3, 4, 5\n\n    1\n \n    0\n\n\n    1\n \n    0\n \n    0\n\n\n    \u2192\n \n    0\n \n    0\n \n    0\n\n\n    1\n \n    1\n In the third test case, we can\nperform the following operation: \n    k = 3:\n choose the indices \n    3, 5,\n    6\n\n    0\n \n    0\n \n    1\n \n    0\n \n    0\n\n\n    0\n \n    \u2192\n \n    0\n \n    0\n\n\n    0\n \n    0\n \n    0\n \n    1\n\n\n",
        "cf_contest_id": 1605,
        "cf_index": "B",
        "cf_rating": 1000,
        "difficulty": 0,
        "cf_tags": [
            "greedy",
            "sortings"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "3\r\n7\r\n0011111\r\n5\r\n10100\r\n6\r\n001000\r\n",
                "0\r\n1\r\n4 1 3 4 5\r\n1\r\n2 3 6\r\n"
            ]
        ],
        "private_cases": []
    }
]