[
    {
        "name": "I Might Be Wrong",
        "description": "You are given a binary string \n    S\n of length \n    n\n indexed from \n    1\n\nto \n    n\n. You can perform the following operation any number of times\n(possibly zero): Choose two integers \n    l\n and \n    r\n (\n    1 \n    \u2264 l \n    \u2264 r\n    \n    \u2264 n\n). Let \n    cnt_0\n be the number of times 0 occurs in \n    S[l\n    \n    \u2026 r]\n and \n    cnt_1\n be the number of times 1 occurs in \n    S[l\n    \n    \u2026 r]\n. You can pay \n    |cnt_0 - cnt_1| + 1\n coins and sort the\n\n    S[l \n    \u2026 r]\n. (by \n    S[l \n    \u2026 r]\n we mean the substring of\n\n    S\n starting at position \n    l\n and ending at position \n    r\n) For\nexample if \n    S =\n 11001, we can perform the operation on \n    S[2 \n    \u2026\n    4]\n, paying \n    |2 - 1| + 1 = 2\n coins, and obtain \n    S =\n 10011 as a\nnew string. Find the minimum total number of coins required to sort \n    S\n in\nincreasing order. Input The first line contains a single integer \n    t\n (\n    1\n    \n    \u2264 t \n    \u2264 1000\n) \u2014 the number of test cases. The description of test\ncases follows. The first line of each test case contains a single integer\n\n    n\n (\n    1 \n    \u2264 n \n    \u2264 2 \n    \u00b7 10^5\n) \u2014 the size of \n    S\n. The\nsecond line of each test case contains a binary string \n    S\n of \n    n\n\ncharacters \n    S_1S_2 \n    \u2026 S_n\n. (\n    S_i =\n 0 or \n    S_i =\n 1 for\neach \n    1 \n    \u2264 i \n    \u2264 n\n) It is guaranteed that the sum of \n    n\n over\nall test cases doesn't exceed \n    2 \n    \u00b7 10^5\n. Output For each test case,\noutput the minimum total number of coins required to sort \n    S\n in\nincreasing order. Example Input 7 1 1 2 10 3 101 4 1000 5 11010 6 110000 20\n01000010001010011000 Output 0 1 1 3 2 2 5 Note In the first test case, \n    S\n\nis already sorted. In the second test case, it's enough to apply the operation\nwith \n    l = 1, r = 2\n. In the third test case, it's enough to apply the\noperation with \n    l = 1, r = 2\n.\n\n",
        "cf_contest_id": 1693,
        "cf_index": "F",
        "cf_rating": 3400,
        "difficulty": 0,
        "cf_tags": [
            "binary search",
            "greedy",
            "two pointers"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "7\r\n1\r\n1\r\n2\r\n10\r\n3\r\n101\r\n4\r\n1000\r\n5\r\n11010\r\n6\r\n110000\r\n20\r\n01000010001010011000\r\n",
                "0\r\n1\r\n1\r\n3\r\n2\r\n2\r\n5\r\n"
            ]
        ],
        "private_cases": []
    }
]