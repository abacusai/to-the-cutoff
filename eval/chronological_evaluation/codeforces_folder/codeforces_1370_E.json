[
    {
        "name": "Binary Subsequence Rotation",
        "description": "Naman has two binary strings \n    s\n and \n    t\n of length \n    n\n (a binary\nstring is a string which only consists of the characters \"0\" and \"1\"). He\nwants to convert \n    s\n into \n    t\n using the following operation as few\ntimes as possible. In one operation, he can choose any subsequence of \n    s\n\nand rotate it clockwise once. For example, if \n    s =\n    1\n    1101\n    00\n, he can choose a subsequence corresponding to\nindices (\n    1\n-based) \n    2, 6, 7\n and rotate them clockwise.\nThe resulting string would then be \n    s = 1\n    0101\n    10\n. A\nstring \n    a\n is said to be a subsequence of string \n    b\n if \n    a\n can be\nobtained from \n    b\n by deleting some characters without changing the\nordering of the remaining characters. To perform a clockwise rotation on a\nsequence \n    c\n of size \n    k\n is to perform an operation which sets\n\n    c_1:=c_k, c_2:=c_1, c_3:=c_2, \n    \u2026, c_k:=c_k-1\n simultaneously.\nDetermine the minimum number of operations Naman has to perform to convert\n\n    s\n into \n    t\n or say that it is impossible. Input The first line\ncontains a single integer \n    n\n \n    (1 \n    \u2264 n \n    \u2264 10^6)\n \u2014 the length of\nthe strings. The second line contains the binary string \n    s\n of length\n\n    n\n. The third line contains the binary string \n    t\n of length \n    n\n.\nOutput If it is impossible to convert \n    s\n to \n    t\n after any number of\noperations, print \n    -1\n. Otherwise, print the minimum number of operations\nrequired. Examples Input 6 010000 000001 Output 1 Input 10 1111100000\n0000011111 Output 5 Input 8 10101010 01010101 Output 1 Input 10 1111100000\n1111100001 Output -1 Note In the first test, Naman can choose the subsequence\ncorresponding to indices \n    2, 6\n and rotate it once to convert\n\n    s\n into \n    t\n. In the second test, he can rotate the subsequence\ncorresponding to all indices \n    5\n times. It can be proved, that it is the\nminimum required number of operations. In the last test, it is impossible to\nconvert \n    s\n into \n    t\n.\n\n",
        "cf_contest_id": 1370,
        "cf_index": "E",
        "cf_rating": 2100,
        "difficulty": 0,
        "cf_tags": [
            "binary search",
            "constructive algorithms",
            "data structures",
            "greedy"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "6\r\n010000\r\n000001\r\n",
                "1\r\n"
            ],
            [
                "10\r\n1111100000\r\n0000011111\r\n",
                "5\r\n"
            ],
            [
                "8\r\n10101010\r\n01010101\r\n",
                "1\r\n"
            ],
            [
                "10\r\n1111100000\r\n1111100001\r\n",
                "-1\r\n"
            ]
        ],
        "private_cases": [
            [
                "12\r\n011001010101\r\n111001010101\r\n",
                "-1\r\n"
            ],
            [
                "9\r\n111110000\r\n111100000\r\n",
                "-1\r\n"
            ],
            [
                "5\r\n10100\r\n01010\r\n",
                "1\r\n"
            ],
            [
                "10\r\n1010111110\r\n1011101101\r\n",
                "2\r\n"
            ],
            [
                "3\r\n000\r\n000\r\n",
                "0\r\n"
            ],
            [
                "5\r\n11011\r\n10111\r\n",
                "1\r\n"
            ],
            [
                "10\r\n0111101111\r\n0111111110\r\n",
                "1\r\n"
            ],
            [
                "10\r\n1100000100\r\n0010000011\r\n",
                "2\r\n"
            ]
        ]
    }
]