[
    {
        "name": "Tit for Tat",
        "description": "Given an array \n    a\n of length \n    n\n, you can do at most \n    k\n\noperations of the following type on it: choose \n    2\n different elements in\nthe array, add \n    1\n to the first, and subtract \n    1\n from the second.\nHowever, all the elements of \n    a\n have to remain non-negative after this\noperation. What is lexicographically the smallest array you can obtain? An\narray \n    x\n is lexicographically smaller than an array \n    y\n if there\nexists an index \n    i\n such that \n    x_i<y_i\n, and \n    x_j=y_j\n for all\n\n    1 \n    \u2264 j < i\n. Less formally, at the first index \n    i\n in which they\ndiffer, \n    x_i<y_i\n. Input The first line contains an integer \n    t\n (\n    1\n    \n    \u2264 t \n    \u2264 20\n) \u2013 the number of test cases you need to solve. The first\nline of each test case contains \n    2\n integers \n    n\n and \n    k\n (\n    2\n    \n    \u2264 n \n    \u2264 100\n, \n    1 \n    \u2264 k \n    \u2264 10000\n) \u2014 the number of elements in\nthe array and the maximum number of operations you can make. The second line\ncontains \n    n\n space-separated integers \n    a_1\n, \n    a_2\n,\n\n    \u2026\n, \n    a_n\n (\n    0 \n    \u2264 a_i \n    \u2264 100\n) \u2014 the elements of\nthe array \n    a\n. Output For each test case, print the lexicographically\nsmallest array you can obtain after at most \n    k\n operations. Example Input\n2 3 1 3 1 4 2 10 1 0 Output 2 1 5 0 1 Note In the second test case, we start\nby subtracting \n    1\n from the first element and adding \n    1\n to the\nsecond. Then, we can't get any lexicographically smaller arrays, because we\ncan't make any of the elements negative.\n\n",
        "cf_contest_id": 1516,
        "cf_index": "A",
        "cf_rating": 800,
        "difficulty": 0,
        "cf_tags": [
            "greedy"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "2\r\n3 1\r\n3 1 4\r\n2 10\r\n1 0\r\n",
                "2 1 5\r\n0 1\r\n"
            ]
        ],
        "private_cases": [
            [
                "1\r\n3 1\r\n1 8 9\r\n",
                "0 8 10\r\n"
            ],
            [
                "1\r\n3 1\r\n3 1 9\r\n",
                "2 1 10\r\n"
            ],
            [
                "1\r\n3 1\r\n1 0 1\r\n",
                "0 0 2\r\n"
            ]
        ]
    }
]