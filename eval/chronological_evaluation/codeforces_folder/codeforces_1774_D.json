[
    {
        "name": "Same Count One",
        "description": "ChthollyNotaSeniorious received a special gift from AquaMoon: \n    n\n binary\narrays of length \n    m\n. AquaMoon tells him that in one operation, he can\nchoose any two arrays and any position \n    pos\n from \n    1\n to \n    m\n, and\nswap the elements at positions \n    pos\n in these arrays. He is fascinated\nwith this game, and he wants to find the minimum number of operations needed\nto make the numbers of \n    1\ns in all arrays the same. He has invited you to\nparticipate in this interesting game, so please try to find it! If it is\npossible, please output specific exchange steps in the format described in the\noutput section. Otherwise, please output \n    -1\n. Input The first line of the\ninput contains a single integer \n    t\n (\n    1 \n    \u2264 t \n    \u2264 2\n    \u00b7\n    10^4\n) \u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains two integers \n    n\n and \n    m\n\n(\n    2 \n    \u2264 n \n    \u2264 10^5\n, \n    2 \n    \u2264 m \n    \u2264 10^5\n). The \n    i\n-th\nof the following \n    n\n lines contains \n    m\n integers \n    a_i, 1, a_i,\n    2, \n    \u2026, a_i, m\n \n    (0 \n    \u2264 a_i, j\n    \u2264 1)\n \u2014 the elements of\nthe \n    i\n-th array. It is guaranteed that the sum of \n    n \n    \u00b7 m\n over\nall test cases does not exceed \n    10^6\n. Output For each test case, if the\nobjective is not achievable, output \n    -1\n. Otherwise, in the first line\noutput \n    k\n \n    (0 \n    \u2264 k \n    \u2264 mn)\n \u2014 the minimum number of operations\nrequired. The \n    i\n-th of the following \n    k\n lines should contain \n    3\n\nintegers, \n    x_i, y_i, z_i\n \n    (1 \n    \u2264 x_i, y_i \n    \u2264 n, 1 \n    \u2264 z_i \n    \u2264\n    m)\n, which describe an operation that swap \n    a_x_i, z_i, a_y_i, z_i\n:\nswap the \n    z_i\n-th number of the \n    x_i\n-th and \n    y_i\n-th arrays.\nExample Input 3 3 4 1 1 1 0 0 0 1 0 1 0 0 1 4 3 1 0 0 0 1 1 0 0 1 0 0 0 2 2 0\n0 0 1 Output 1 2 1 1 1 4 2 2 -1 Note In the first test case, it's enough to do\na single operation: to swap the first element in the second and the first\nrows. The arrays will become \n    [0, 1, 1, 0], [1, 0, 1, 0], [1, 0, 0, 1]\n,\neach of them contains exactly two \n    1\ns.\n\n",
        "cf_contest_id": 1774,
        "cf_index": "D",
        "cf_rating": 1600,
        "difficulty": 0,
        "cf_tags": [
            "brute force",
            "constructive algorithms",
            "greedy",
            "implementation",
            "two pointers"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 512.0,
        "public_cases": [
            [
                "3\r\n3 4\r\n1 1 1 0\r\n0 0 1 0\r\n1 0 0 1\r\n4 3\r\n1 0 0\r\n0 1 1\r\n0 0 1\r\n0 0 0\r\n2 2\r\n0 0\r\n0 1\r\n",
                "1\r\n1 2 1\r\n1\r\n2 4 2\r\n-1\r\n"
            ]
        ],
        "private_cases": []
    }
]