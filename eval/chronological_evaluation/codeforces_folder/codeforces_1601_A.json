[
    {
        "name": "Array Elimination",
        "description": "You are given array \n    a_1, a_2, \n    \u2026, a_n\n, consisting of non-negative\nintegers. Let's define operation of \"elimination\" with integer parameter\n\n    k\n (\n    1 \n    \u2264 k \n    \u2264 n\n) as follows: Choose \n    k\n distinct array\nindices \n    1 \n    \u2264 i_1 < i_2 < \n    \u2026 < i_k \n    \u2264 n\n. Calculate \n    x =\n    a_i_1\u00a0\n    &\u00a0 a_i_2\u00a0\n    &\u00a0\n    \u2026\u00a0\n    &\u00a0 a_i_k\n, where\n\n    &\n denotes the bitwise AND operation (notes section contains formal\ndefinition). Subtract \n    x\n from each of \n    a_i_1, a_i_2, \n    \u2026,\n    a_i_k\n; all other elements remain untouched. Find all possible values of\n\n    k\n, such that it's possible to make all elements of array \n    a\n equal\nto \n    0\n using a finite number of elimination operations with parameter\n\n    k\n. It can be proven that exists at least one possible \n    k\n for any\narray \n    a\n. Note that you firstly choose \n    k\n and only after that\nperform elimination operations with value \n    k\n you've chosen initially.\nInput Each test contains multiple test cases. The first line contains the\nnumber of test cases \n    t\n (\n    1 \n    \u2264 t \n    \u2264 10^4\n). Description of\nthe test cases follows. The first line of each test case contains one integer\n\n    n\n (\n    1 \n    \u2264 n \n    \u2264 200\n     000\n) \u2014 the length of array \n    a\n.\nThe second line of each test case contains \n    n\n integers \n    a_1, a_2,\n    \n    \u2026, a_n\n (\n    0 \n    \u2264 a_i < 2^30\n) \u2014 array \n    a\n itself. It's\nguaranteed that the sum of \n    n\n over all test cases doesn't exceed\n\n    200\n     000\n. Output For each test case, print all values \n    k\n, such\nthat it's possible to make all elements of \n    a\n equal to \n    0\n in a\nfinite number of elimination operations with the given parameter \n    k\n.\nPrint them in increasing order. Example Input 5 4 4 4 4 4 4 13 7 25 19 6 3 5 3\n1 7 1 1 1 5 0 0 0 0 0 Output 1 2 4 1 2 1 1 1 2 3 4 5 Note In the first test\ncase: If \n    k = 1\n, we can make four elimination operations with sets of\nindices \n    1\n, \n    2\n, \n    3\n,\n\n    4\n. Since \n    &\n of one element is equal to the element\nitself, then for each operation \n    x = a_i\n, so \n    a_i - x = a_i - a_i =\n    0\n. If \n    k = 2\n, we can make two elimination operations with, for\nexample, sets of indices \n    1, 3\n and \n    2, 4\n: \n    x =\n    a_1 \u00a0\n    &\u00a0 a_3\n \n    =\n \n    a_2 \u00a0\n    &\u00a0 a_4\n \n    =\n \n    4 \u00a0\n    &\u00a0 4 =\n    4\n. For both operations \n    x = 4\n, so after the first operation \n    a_1 - x\n    = 0\n and \n    a_3 - x = 0\n, and after the second operation \u2014 \n    a_2 - x =\n    0\n and \n    a_4 - x = 0\n. If \n    k = 3\n, it's impossible to make all\n\n    a_i\n equal to \n    0\n. After performing the first operation, we'll get\nthree elements equal to \n    0\n and one equal to \n    4\n. After that, all\nelimination operations won't change anything, since at least one chosen\nelement will always be equal to \n    0\n. If \n    k = 4\n, we can make one\noperation with set \n    1, 2, 3, 4\n, because \n    x = a_1 \u00a0\n    &\u00a0 a_2\n    \u00a0\n    &\u00a0 a_3 \u00a0\n    &\u00a0 a_4\n \n    = 4\n. In the second test case, if \n    k =\n    2\n then we can make the following elimination operations: Operation with\nindices \n    1, 3\n: \n    x = a_1 \u00a0\n    &\u00a0 a_3\n \n    =\n \n    13 \u00a0\n    &\u00a0 25 = 9\n. \n    a_1 - x = 13 - 9 = 4\n and \n    a_3 - x = 25 - 9 = 16\n. Array\n\n    a\n will become equal to \n    [4, 7, 16, 19]\n. Operation with indices\n\n    3, 4\n: \n    x = a_3 \u00a0\n    &\u00a0 a_4\n \n    =\n \n    16 \u00a0\n    &\u00a0 19 =\n    16\n. \n    a_3 - x = 16 - 16 = 0\n and \n    a_4 - x = 19 - 16 = 3\n. Array\n\n    a\n will become equal to \n    [4, 7, 0, 3]\n. Operation with indices\n\n    2, 4\n: \n    x = a_2 \u00a0\n    &\u00a0 a_4\n \n    =\n \n    7 \u00a0\n    &\u00a0 3 =\n    3\n. \n    a_2 - x = 7 - 3 = 4\n and \n    a_4 - x = 3 - 3 = 0\n. Array \n    a\n\nwill become equal to \n    [4, 4, 0, 0]\n. Operation with indices \n    1,\n    2\n: \n    x = a_1 \u00a0\n    &\u00a0 a_2\n \n    =\n \n    4 \u00a0\n    &\u00a0 4 = 4\n. \n    a_1 -\n    x = 4 - 4 = 0\n and \n    a_2 - x = 4 - 4 = 0\n. Array \n    a\n will become\nequal to \n    [0, 0, 0, 0]\n. Formal definition of bitwise AND: Let's define\nbitwise AND (\n    &\n) as follows. Suppose we have two non-negative integers\n\n    x\n and \n    y\n, let's look at their binary representations (possibly,\nwith leading zeroes): \n    x_k \n    \u2026 x_2 x_1 x_0\n and \n    y_k \n    \u2026 y_2 y_1\n    y_0\n. Here, \n    x_i\n is the \n    i\n-th bit of number \n    x\n, and \n    y_i\n\nis the \n    i\n-th bit of number \n    y\n. Let \n    r = x \u00a0\n    &\u00a0 y\n is a\nresult of operation \n    &\n on number \n    x\n and \n    y\n. Then binary\nrepresentation of \n    r\n will be \n    r_k \n    \u2026 r_2 r_1 r_0\n, where: \n    \n\n    r_i = \n     1, \u00a0\n    if\u00a0 x_i = 1 \u00a0\n    and\u00a0 y_i = 1\n    \n    \n    \n     0, \u00a0\n    if\u00a0 x_i = 0 \u00a0\n    or\u00a0 y_i = 0\n\n    \n\n\n",
        "cf_contest_id": 1601,
        "cf_index": "A",
        "cf_rating": 1300,
        "difficulty": 0,
        "cf_tags": [
            "bitmasks",
            "greedy",
            "math",
            "number theory"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 512.0,
        "public_cases": [
            [
                "5\r\n4\r\n4 4 4 4\r\n4\r\n13 7 25 19\r\n6\r\n3 5 3 1 7 1\r\n1\r\n1\r\n5\r\n0 0 0 0 0\r\n",
                "1 2 4 \r\n1 2 \r\n1 \r\n1 \r\n1 2 3 4 5 \r\n"
            ]
        ],
        "private_cases": []
    }
]