[
    {
        "name": "Perfect Matching",
        "description": "You are given a tree consisting of \n    n\n vertices (numbered from \n    1\n to\n\n    n\n) and \n    n-1\n edges (numbered from \n    1\n to \n    n-1\n). Initially,\nall vertices except vertex \n    1\n are inactive. You have to process queries\nof three types: \n    1\n \n    v\n \u2014 activate the vertex \n    v\n. It is\nguaranteed that the vertex \n    v\n is inactive before this query, and one of\nits neighbors is active. After activating the vertex, you have to choose a\nsubset of edges of the tree such that each active vertex is incident to\nexactly one chosen edge, and each inactive vertex is not incident to any of\nthe chosen edges \u2014 in other words, this subset should represent a perfect\nmatching on the active part of the tree. If any such subset of edges exists,\nprint the sum of indices of edges in it; otherwise, print \n    0\n. \n    2\n \u2014\nqueries of this type will be asked only right after a query of type \n    1\n,\nand there will be at most \n    10\n such queries. If your answer to the\nprevious query was \n    0\n, simply print \n    0\n; otherwise, print the subset\nof edges for the previous query as follows: first, print the number of edges\nin the subset, then print the indices of the chosen edges in ascending order.\nThe sum of indices should be equal to your answer to the previous query.\n\n    3\n \u2014 terminate the program. Note that you should solve the problem in\nonline mode. It means that you can't read the whole input at once. You can\nread each query only after writing the answer for the last query. Use\nfunctions fflush in C++ and BufferedWriter.flush in Java languages after each\nwriting in your program. Input The first line contains one integer \n    n\n\n(\n    2 \n    \u2264 n \n    \u2264 2 \n    \u00b7 10^5\n) \u2014 the number of vertices of the tree.\nThen \n    n-1\n lines follow. The \n    i\n-th line contains two integers\n\n    u_i\n and \n    v_i\n (\n    1 \n    \u2264 u_i, v_i \n    \u2264 n\n; \n    u_i \n     v_i\n)\n\u2014 the endpoints of the \n    i\n-th edge. These edges form a tree. Then the\nqueries follow in the format described in the statement, one line per query.\nThere will be at least \n    2\n and at most \n    n+10\n queries. The last query\n(and only the last one) will be of type \n    3\n. Note that you can read the\n\n    i\n-th query only if you have already given the answer for the query\n\n    i-1\n (except for \n    i = 1\n). If your answer for one of the queries is\nincorrect and the judging program recognizes it, instead of the next query,\nyou may receive the integer \n    0\n on a separate line. After receiving it,\nyour program should terminate gracefully, and you will receive \"Wrong Answer\"\nverdict. If your program doesn't terminate, your solution may receive some\nother verdict, like \"Time Limit Exceeded\", \"Idleness Limit Exceeded\", etc.\nNote that the fact that your solution doesn't receive the integer \n    0\n, it\ndoes not mean that all your answers are correct, some of them will be checked\nonly after your program is terminated. Output For each query of type \n    1\n\nor \n    2\n, print the answer on a separate line as described in the statement.\nDon't forget to flush the output. Example Input 6 1 4 6 1 3 2 1 2 5 1 1 4 2 1\n2 2 1 3 2 1 5 1 6 2 3 Output 1 1 1 0 0 4 2 1 3 0 0 0\n\n",
        "cf_contest_id": 1633,
        "cf_index": "F",
        "cf_rating": 2800,
        "difficulty": 0,
        "cf_tags": [
            "data structures",
            "divide and conquer",
            "interactive",
            "trees"
        ],
        "time_limit_seconds": 12.0,
        "memory_limit_bytes": 512.0,
        "public_cases": [
            [
                "6\r\n1 4\r\n6 1\r\n3 2\r\n1 2\r\n5 1\r\n1 4\r\n2\r\n1 2\r\n2\r\n1 3\r\n2\r\n1 5\r\n1 6\r\n2\r\n3\r\n",
                "1\r\n1\r\n0\r\n0\r\n1\r\n2\r\n0\r\n0\r\n0\r\n"
            ]
        ],
        "private_cases": []
    }
]