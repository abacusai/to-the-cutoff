[
    {
        "name": "Equal Reversal",
        "description": "There is an array \n    a\n of length \n    n\n. You may perform the following\noperation on it: Choose two indices \n    l\n and \n    r\n where \n    1 \n    \u2264 l\n    \n    \u2264 r \n    \u2264 n\n and \n    a_l = a_r\n. Then, reverse the subsegment from the\n\n    l\n-th to the \n    r\n-th element, i. e. set \n    [a_l, a_l + 1, \n    \u2026,\n    a_r - 1, a_r]\n to \n    [a_r, a_r-1, \n    \u2026, a_l+1, a_l]\n. You are\nalso given another array \n    b\n of length \n    n\n which is a permutation of\n\n    a\n. Find a sequence of at most \n    n^2\n operations that transforms array\n\n    a\n into \n    b\n, or report that no such sequence exists. Input Each test\ncontains multiple test cases. The first line contains a single integer \n    t\n\n(\n    1 \n    \u2264 t \n    \u2264 100\n) \u2014 the number of test cases. The description of\nthe test cases follows. The first line of each test case contains an integer\n\n    n\n (\n    1 \n    \u2264 n \n    \u2264 500\n) \u2014 the length of array \n    a\n and \n    b\n.\nThe second line of each test case contains \n    n\n integers \n    a_1, a_2,\n    \n    \u2026, a_n\n (\n    1 \n    \u2264 a_i \n    \u2264 n\n) \u2014 elements of the array \n    a\n.\nThe third line of each test case contains \n    n\n integers \n    b_1, b_2,\n    \n    \u2026, b_n\n (\n    1 \n    \u2264 b_i \n    \u2264 n\n) \u2014 elements of the array \n    b\n.\nIt is guaranteed that \n    b\n is a permutation of \n    a\n. It is guaranteed\nthat the sum of \n    n\n over all test cases does not exceed \n    500\n. Output\nFor each test case, output \"NO\" (without quotes) if it is impossible to turn\n\n    a\n into \n    b\n using at most \n    n^2\n operations. Otherwise, output\n\"YES\" (without quotes). Then output an integer \n    k\n (\n    0 \n    \u2264 k \n    \u2264\n    n^2\n) denoting the number of operations you will perform. Note that you\ndon't have to minimize the number of operations. Afterwards, output \n    k\n\nlines. The \n    i\n-th line should contain two integers \n    l_i\n and \n    r_i\n\n(\n    1 \n    \u2264 l_i \n    \u2264 r_i \n    \u2264 n\n) \u2014 the left and right indices for the\n\n    i\n-th operation. You can output \"YES\" and \"NO\" in any case (for example,\nstrings \"yEs\", \"yes\" and \"Yes\" will be recognized as a positive response). If\nthere are multiple possible sequences of operations, you may output any of\nthem. Example Input 5 8 1 2 4 3 1 2 1 1 1 1 3 4 2 1 2 1 7 1 2 3 1 3 2 3 1 3 2\n3 1 2 3 3 1 1 2 1 2 1 2 1 2 2 1 1 1 1 Output YES 2 5 8 1 6 YES 2 1 4 3 6 NO NO\nYES 0 Note In the first test case, we can perform the following operations:\n\n    \n\n    [1,2,4,3,1,2,1,1] \n     [1,2,4,3,1,1,2,1]\n    \n     [1,1,3,4,2,1,2,1].\n\n    \n In the second test\ncase, we can perform the following operations: \n    \n\n    [1,2,3,1,3,2,3]\n    \n     [1,3,2,1,3,2,3] \n    \n    [1,3,2,3,1,2,3].\n\n    \n It can be proven that it is impossible to turn \n    a\n\ninto \n    b\n in the third and fourth test cases.\n\n",
        "cf_contest_id": 1698,
        "cf_index": "F",
        "cf_rating": 2800,
        "difficulty": 0,
        "cf_tags": [
            "constructive algorithms",
            "graphs",
            "implementation",
            "math"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "5\r\n8\r\n1 2 4 3 1 2 1 1\r\n1 1 3 4 2 1 2 1\r\n7\r\n1 2 3 1 3 2 3\r\n1 3 2 3 1 2 3\r\n3\r\n1 1 2\r\n1 2 1\r\n2\r\n1 2\r\n2 1\r\n1\r\n1\r\n1\r\n",
                "YES\r\n3\r\n1 8\r\n4 8\r\n2 8\r\nYES\r\n2\r\n1 4\r\n3 6\r\nNO\r\nNO\r\nYES\r\n0\r\n"
            ]
        ],
        "private_cases": []
    }
]