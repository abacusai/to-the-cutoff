[
    {
        "name": "Binary String To Subsequences",
        "description": "You are given a binary string \n    s\n consisting of \n    n\n zeros and ones.\nYour task is to divide the given string into the minimum number of\nsubsequences in such a way that each character of the string belongs to\nexactly one subsequence and each subsequence looks like \"010101 ...\" or\n\"101010 ...\" (i.e. the subsequence should not contain two adjacent zeros or\nones). Recall that a subsequence is a sequence that can be derived from the\ngiven sequence by deleting zero or more elements without changing the order of\nthe remaining elements. For example, subsequences of \"1011101\" are \"0\", \"1\",\n\"11111\", \"0111\", \"101\", \"1001\", but not \"000\", \"101010\" and \"11100\". You have\nto answer \n    t\n independent test cases. Input The first line of the input\ncontains one integer \n    t\n (\n    1 \n    \u2264 t \n    \u2264 2 \n    \u00b7 10^4\n) \u2014 the\nnumber of test cases. Then \n    t\n test cases follow. The first line of the\ntest case contains one integer \n    n\n (\n    1 \n    \u2264 n \n    \u2264 2 \n    \u00b7 10^5\n)\n\u2014 the length of \n    s\n. The second line of the test case contains \n    n\n\ncharacters '0' and '1' \u2014 the string \n    s\n. It is guaranteed that the sum of\n\n    n\n does not exceed \n    2 \n    \u00b7 10^5\n (\n    \u2211 n \n    \u2264 2 \n    \u00b7\n    10^5\n). Output For each test case, print the answer: in the first line print\none integer \n    k\n (\n    1 \n    \u2264 k \n    \u2264 n\n) \u2014 the minimum number of\nsubsequences you can divide the string \n    s\n to. In the second line print\n\n    n\n integers \n    a_1, a_2, \n    \u2026, a_n\n (\n    1 \n    \u2264 a_i \n    \u2264 k\n),\nwhere \n    a_i\n is the number of subsequence the \n    i\n-th character of\n\n    s\n belongs to. If there are several answers, you can print any. Example\nInput 4 4 0011 6 111111 5 10101 8 01010000 Output 2 1 2 2 1 6 1 2 3 4 5 6 1 1\n1 1 1 1 4 1 1 1 1 1 2 3 4\n\n",
        "cf_contest_id": 1399,
        "cf_index": "D",
        "cf_rating": 1500,
        "difficulty": 0,
        "cf_tags": [
            "constructive algorithms",
            "data structures",
            "greedy",
            "implementation"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "4\r\n4\r\n0011\r\n6\r\n111111\r\n5\r\n10101\r\n8\r\n01010000\r\n",
                "2 2 1 1 2\r\n6 1 2 3 4 5 6\r\n1 1 1 1 1 1\r\n4 4 4 4 4 4 3 2 1\r\n"
            ]
        ],
        "private_cases": []
    }
]