[
    {
        "name": "Colorful Tree Again",
        "description": "An edge-weighted tree of \n    n\n nodes is given with each edge colored in some\ncolor. Each node of this tree can be blocked or unblocked, all nodes are\nunblocked initially. A simple path is a path in a graph that does not have\nrepeating nodes. The length of a path is defined as the sum of weights of all\nedges on the path. A path is good when it is a simple path consisting of edges\nof the same color \n    c\n, all edges of color \n    c\n are on this path, and\nevery node on the path is unblocked. You need to operate \n    2\n kinds of\nqueries: block a node, unblock a node. After each query, print the maximum\nlength among all good paths. If there are no good paths, print \n    0\n. Input\nThe first line contains two integers \n    n\n, \n    q\n (\n    1 \n    \u2264 n,q \n    \u2264\n    2\n    \u00b7 10^5\n) \u2014 the number of nodes and the number of queries. Then\n\n    n-1\n lines follow, each containing four integers \n    u\n, \n    v\n,\n\n    w\n and \n    c\n (\n    1 \n    \u2264 u,v,w,c \n    \u2264 n\n; \n    u \n    \u2260 v\n),\ndenoting a weighted edge connecting node \n    u\n and node \n    v\n with weight\n\n    w\n and color \n    c\n. It is guaranteed that these edges form a tree. Then\n\n    q\n lines follow, each containing two integers \n    p\n and \n    x\n (\n    p =\n    0\n or \n    p = 1\n, \n    1\n    \u2264 x\n    \u2264 n\n), denoting a query: if \n    p =\n    0\n, block the node \n    x\n. It's guaranteed that it's not blocked at this\ntime; if \n    p = 1\n, unblock the node \n    x\n. It's guaranteed that it's\nblocked at this time. Output For each query, print the maximum length of a\ngood path. If there are no good paths, print \n    0\n. Examples Input 5 4 4 1 3\n4 5 2 4 4 3 1 3 2 1 2 5 1 0 4 0 3 0 2 1 3 Output 5 5 0 3 Input 5 5 4 1 4 4 4 5\n2 2 3 1 2 4 3 2 3 1 0 3 0 4 1 3 1 4 0 1 Output 2 0 3 6 3 Input 6 9 3 2 2 3 2 4\n4 2 3 1 5 5 6 4 3 2 5 3 1 3 0 2 0 4 0 5 0 6 1 2 1 4 1 5 0 3 1 6 Output 5 5 5 5\n5 5 5 0 7 Input 1 2 0 1 1 1 Output 0 0\n\n",
        "cf_contest_id": 1787,
        "cf_index": "G",
        "cf_rating": 3000,
        "difficulty": 0,
        "cf_tags": [
            "brute force",
            "data structures",
            "trees"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 512.0,
        "public_cases": [
            [
                "5 4\r\n4 1 3 4\r\n5 2 4 4\r\n3 1 3 2\r\n1 2 5 1\r\n0 4\r\n0 3\r\n0 2\r\n1 3\r\n",
                "5\r\n5\r\n0\r\n3\r\n"
            ],
            [
                "5 5\r\n4 1 4 4\r\n4 5 2 2\r\n3 1 2 4\r\n3 2 3 1\r\n0 3\r\n0 4\r\n1 3\r\n1 4\r\n0 1\r\n",
                "2\r\n0\r\n3\r\n6\r\n3\r\n"
            ],
            [
                "6 9\r\n3 2 2 3\r\n2 4 4 2\r\n3 1 5 5\r\n6 4 3 2\r\n5 3 1 3\r\n0 2\r\n0 4\r\n0 5\r\n0 6\r\n1 2\r\n1 4\r\n1 5\r\n0 3\r\n1 6\r\n",
                "5\r\n5\r\n5\r\n5\r\n5\r\n5\r\n5\r\n0\r\n7\r\n"
            ],
            [
                "1 2\r\n0 1\r\n1 1\r\n",
                "0\r\n0\r\n"
            ]
        ],
        "private_cases": [
            [
                "4 2\r\n1 2 1 1\r\n1 3 1 1\r\n1 4 1 1\r\n0 1\r\n1 1\r\n",
                "0\r\n0\r\n"
            ]
        ]
    }
]