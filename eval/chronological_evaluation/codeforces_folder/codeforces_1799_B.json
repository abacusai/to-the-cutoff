[
    {
        "name": "Equalize by Divide",
        "description": "You are given an array \n    a_1, a_2, \n    \u2026, a_n\n of positive integers. You\ncan make this operation multiple (possibly zero) times: Choose two indices\n\n    i\n, \n    j\n (\n    1 \n    \u2264 i, j \n    \u2264 n\n, \n    i \n    \u2260 j\n). Assign\n\n    a_i := \n    \u2308\n    a_i/a_j\n    \u2309\n. Here \n    \u2308 x\n    \n    \u2309\n denotes \n    x\n rounded up to the smallest integer \n    \u2265 x\n.\nIs it possible to make all array elements equal by some sequence of operations\n(possibly empty)? If yes, print any way to do it in at most \n    30n\n\noperations. It can be proven, that under the problem constraints, if some way\nexists to make all elements equal, there exists a way with at most \n    30n\n\noperations. Input The first line contains a single integer \n    t\n (\n    1\n    \n    \u2264 t \n    \u2264 1000\n) \u2014 the number of test cases. Descriptions of test\ncases follow. The first line of each test case description contains a single\ninteger \n    n\n (\n    1 \n    \u2264 n \n    \u2264 100\n). The second line of each test\ncase description contains \n    n\n integers \n    a_1, a_2, \n    \u2026, a_n\n (\n    1\n    \n    \u2264 a_i \n    \u2264 10^9\n). It is guaranteed, that the sum of \n    n\n for all\ntest cases does not exceed \n    1000\n. Output For each test case print a\nsingle integer \n    q\n (\n    -1 \n    \u2264 q \n    \u2264 30n\n). If \n    q=-1\n, there is\nno solution, otherwise \n    q\n is equal to the number of operations. If \n    q\n    \n    \u2265 0\n, on the next \n    q\n lines print two integers \n    i\n, \n    j\n\n(\n    1 \n    \u2264 i, j \n    \u2264 n\n, \n    i \n    \u2260 j\n) \u2014 descriptions of operations.\nIf there are multiple solutions, you can print any. Example Input 10 1 100 3 1\n1 1 2 2 1 2 5 5 3 4 3 2 4 3 3 4 4 2 2 100 5 5 3 6 7 8 6 3 3 80 3 8 3 4 19 40\n19 55 Output 0 0 -1 0 2 1 3 2 1 4 3 1 4 2 1 3 2 4 6 2 1 2 1 2 1 2 1 2 1 2 1 8\n5 2 4 2 3 2 1 3 1 3 2 1 4 1 5 1 4 5 1 3 1 3 1 3 1 9 4 2 2 1 1 2 1 2 3 2 3 2 1\n4 2 4 3 4 Note In the first and second, fourth test cases all numbers are\nequal, so it is possible to do nothing. In the third test case, it is\nimpossible to make all numbers equal. In the fifth test case:\n\n    [\n    4, 3, \n    2] \n    \u2192 [\n    2,\n    \n    3, 2] \n    \u2192 [2, 2, 2]\n. In the sixth test case:\n\n    [\n    3, 3, \n    4, 4] \n    \u2192 [3, \n    3, 2,\n    \n    4] \n    \u2192 [\n    3, 3, \n    2, 2] \n    \u2192 [2,\n    \n    3, 2, \n    2] \n    \u2192 [2, 2, 2, 2]\n. Here the red\nnumbers are \n    i\n indices (that will be assigned), blue numbers are \n    j\n\nindices.\n\n",
        "cf_contest_id": 1799,
        "cf_index": "B",
        "cf_rating": 1200,
        "difficulty": 0,
        "cf_tags": [
            "brute force",
            "constructive algorithms",
            "greedy",
            "math"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "10\r\n1\r\n100\r\n3\r\n1 1 1\r\n2\r\n2 1\r\n2\r\n5 5\r\n3\r\n4 3 2\r\n4\r\n3 3 4 4\r\n2\r\n2 100\r\n5\r\n5 3 6 7 8\r\n6\r\n3 3 80 3 8 3\r\n4\r\n19 40 19 55\r\n",
                "0\r\n\r\n0\r\n-1\r\n0\r\n\r\n2\r\n1 3\r\n2 1\r\n4\r\n3 1\r\n4 3\r\n1 3\r\n2 1\r\n6\r\n2 1\r\n2 1\r\n2 1\r\n2 1\r\n2 1\r\n2 1\r\n8\r\n5 2\r\n4 2\r\n3 2\r\n1 3\r\n1 3\r\n2 1\r\n4 1\r\n5 1\r\n4\r\n3 1\r\n3 1\r\n3 1\r\n5 1\r\n11\r\n4 1\r\n2 4\r\n1 4\r\n3 4\r\n2 4\r\n1 4\r\n3 1\r\n2 1\r\n1 2\r\n3 1\r\n4 1\r\n"
            ]
        ],
        "private_cases": []
    }
]