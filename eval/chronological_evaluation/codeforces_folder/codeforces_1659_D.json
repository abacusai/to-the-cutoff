[
    {
        "name": "Reverse Sort Sum",
        "description": "Suppose you had an array \n    A\n of \n    n\n elements, each of which is \n    0\n\nor \n    1\n. Let us define a function \n    f(k,A)\n which returns another array\n\n    B\n, the result of sorting the first \n    k\n elements of \n    A\n in non-\ndecreasing order. For example, \n    f(4,[0,1,1,0,0,1,0]) = [0,0,1,1,0,1,0]\n.\nNote that the first \n    4\n elements were sorted. Now consider the arrays\n\n    B_1, B_2,\n    \u2026, B_n\n generated by \n    f(1,A),\n    f(2,A),\n    \u2026,f(n,A)\n. Let \n    C\n be the array obtained by taking the\nelement-wise sum of \n    B_1, B_2,\n    \u2026, B_n\n. For example, let\n\n    A=[0,1,0,1]\n. Then we have \n    B_1=[0,1,0,1]\n, \n    B_2=[0,1,0,1]\n,\n\n    B_3=[0,0,1,1]\n, \n    B_4=[0,0,1,1]\n. Then\n\n    C=B_1+B_2+B_3+B_4=[0,1,0,1]+[0,1,0,1]+[0,0,1,1]+[0,0,1,1]=[0,2,2,4]\n. You\nare given \n    C\n. Determine a binary array \n    A\n that would give \n    C\n\nwhen processed as above. It is guaranteed that an array \n    A\n exists for\ngiven \n    C\n in the input. Input The first line contains a single integer\n\n    t\n (\n    1 \n    \u2264 t \n    \u2264 1000\n) \u2014 the number of test cases. Each test\ncase has two lines. The first line contains a single integer \n    n\n (\n    1\n    \n    \u2264 n \n    \u2264 2 \n    \u00b7 10^5\n). The second line contains \n    n\n integers\n\n    c_1, c_2, \n    \u2026, c_n\n (\n    0 \n    \u2264 c_i \n    \u2264 n\n). It is guaranteed\nthat a valid array \n    A\n exists for the given \n    C\n. The sum of \n    n\n\nover all test cases does not exceed \n    2 \n    \u00b7 10^5\n. Output For each test\ncase, output a single line containing \n    n\n integers \n    a_1, a_2, \n    \u2026,\n    a_n\n (\n    a_i\n is \n    0\n or \n    1\n). If there are multiple answers, you\nmay output any of them. Example Input 5 4 2 4 2 4 7 0 3 4 2 3 2 7 3 0 0 0 4 0\n0 0 4 3 1 2 3 Output 1 1 0 1 0 1 1 0 0 0 1 0 0 0 0 0 0 1 1 0 1 Note Here's the\nexplanation for the first test case. Given that \n    A=[1,1,0,1]\n, we can\nconstruct each \n    B_i\n: \n    B_1=[\n    1,1,0,1]\n;\n\n    B_2=[\n    1,\n    1,0,1]\n;\n\n    B_3=[\n    0,\n    1,\n    1,1]\n;\n\n    B_4=[\n    0,\n    1,\n    1,\n    1]\n\nAnd then, we can sum up each column above to get\n\n    C=[1+1+0+0,1+1+1+1,0+0+1+1,1+1+1+1]=[2,4,2,4]\n.\n\n",
        "cf_contest_id": 1659,
        "cf_index": "D",
        "cf_rating": 1900,
        "difficulty": 0,
        "cf_tags": [
            "constructive algorithms",
            "data structures",
            "greedy",
            "implementation",
            "math",
            "two pointers"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "5\r\n4\r\n2 4 2 4\r\n7\r\n0 3 4 2 3 2 7\r\n3\r\n0 0 0\r\n4\r\n0 0 0 4\r\n3\r\n1 2 3\r\n",
                "1 1 0 1\r\n0 1 1 0 0 0 1\r\n0 0 0\r\n0 0 0 1\r\n1 0 1\r\n"
            ]
        ],
        "private_cases": [
            [
                "2\r\n1\r\n0\r\n1\r\n1\r\n",
                "0\r\n1\r\n"
            ]
        ]
    }
]