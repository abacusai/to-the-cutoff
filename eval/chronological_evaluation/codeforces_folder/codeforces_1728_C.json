[
    {
        "name": "Digital Logarithm",
        "description": "Let's define \n    f(x)\n for a positive integer \n    x\n as the length of the\nbase-10 representation of \n    x\n without leading zeros. I like to call it a\ndigital logarithm. Similar to a digital root, if you are familiar with that.\nYou are given two arrays \n    a\n and \n    b\n, each containing \n    n\n positive\nintegers. In one operation, you do the following: pick some integer \n    i\n\nfrom \n    1\n to \n    n\n; assign either \n    f(a_i)\n to \n    a_i\n or\n\n    f(b_i)\n to \n    b_i\n. Two arrays are considered similar to each other if\nyou can rearrange the elements in both of them, so that they are equal (e. g.\n\n    a_i = b_i\n for all \n    i\n from \n    1\n to \n    n\n). What's the smallest\nnumber of operations required to make \n    a\n and \n    b\n similar to each\nother? Input The first line contains a single integer \n    t\n (\n    1 \n    \u2264 t\n    \n    \u2264 10^4\n) \u2014 the number of testcases. The first line of the testcase\ncontains a single integer \n    n\n (\n    1 \n    \u2264 n \n    \u2264 2 \n    \u00b7 10^5\n) \u2014 the\nnumber of elements in each of the arrays. The second line contains \n    n\n\nintegers \n    a_1, a_2, \n    \u2026, a_n\n (\n    1 \n    \u2264 a_i < 10^9\n). The third\nline contains \n    n\n integers \n    b_1, b_2, \n    \u2026, b_n\n (\n    1 \n    \u2264 b_j <\n    10^9\n). The sum of \n    n\n over all testcases doesn't exceed \n    2 \n    \u00b7\n    10^5\n. Output For each testcase, print the smallest number of operations\nrequired to make \n    a\n and \n    b\n similar to each other. Example Input 4 1\n1 1000 4 1 2 3 4 3 1 4 2 3 2 9 3 1 100 9 10 75019 709259 5 611271314 9024533\n81871864 9 3 6 4865 9503 2 371245467 6 7 37376159 8 364036498 52295554 169\nOutput 2 0 2 18 Note In the first testcase, you can apply the digital\nlogarithm to \n    b_1\n twice. In the second testcase, the arrays are already\nsimilar to each other. In the third testcase, you can first apply the digital\nlogarithm to \n    a_1\n, then to \n    b_2\n.\n\n",
        "cf_contest_id": 1728,
        "cf_index": "C",
        "cf_rating": 1400,
        "difficulty": 0,
        "cf_tags": [
            "data structures",
            "greedy",
            "sortings"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "4\r\n1\r\n1\r\n1000\r\n4\r\n1 2 3 4\r\n3 1 4 2\r\n3\r\n2 9 3\r\n1 100 9\r\n10\r\n75019 709259 5 611271314 9024533 81871864 9 3 6 4865\r\n9503 2 371245467 6 7 37376159 8 364036498 52295554 169\r\n",
                "2\r\n0\r\n2\r\n18\r\n"
            ]
        ],
        "private_cases": []
    }
]