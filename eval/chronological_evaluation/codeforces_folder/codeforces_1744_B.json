[
    {
        "name": "Even-Odd Increments ",
        "description": "You are given \n    n\n of integers \n    a_1, a_2, \n    \u2026, a_n\n. Process\n\n    q\n queries of two types: query of the form \"0 \n    x_j\n\": add the value\n\n    x_j\n to all even elements of the array \n    a\n, query of the form \"1\n\n    x_j\n\": add the value \n    x_j\n to all odd elements of the array\n\n    a\n.Note that when processing the query, we look specifically at the\nodd/even value of \n    a_i\n, not its index. After processing each query, print\nthe sum of the elements of the array \n    a\n. Please note that the answer for\nsome test cases won't fit into 32-bit integer type, so you should use at least\n64-bit integer type in your programming language (like long long for C++).\nInput The first line of the input contains an integer \n    t\n \n    (1 \n    \u2264 t\n    \n    \u2264 10^4\n) \u2014 the number of test cases. The descriptions of the test cases\nfollow. The first line of each test case contains two integers \n    n\n and\n\n    q\n (\n    1 \n    \u2264 n\n, \n    q \n    \u2264 10^5\n) \u2014 the length of array \n    a\n\nand the number of queries. The second line of each test case contains exactly\n\n    n\n integers: \n    a_1, a_2, \n    \u2026, a_n\n (\n    1 \n    \u2264 a_i \n    \u2264\n    10^9\n) \u2014 elements of the array \n    a\n. The following \n    q\n lines contain\nqueries as two integers \n    type_j\n and \n    x_j\n \n    (0 \n    \u2264 type_j \n    \u2264\n    1\n, \n    1 \n    \u2264 x_j \n    \u2264 10^4\n). It is guaranteed that the sum of values\n\n    n\n over all test cases in a test does not exceed \n    10^5\n. Similarly,\nthe sum of values \n    q\n over all test cases does not exceed \n    10^5\n.\nOutput For each test case, print \n    q\n numbers: the sum of the elements of\nthe array \n    a\n after processing a query. Example Input 4 1 1 1 1 1 3 3 1 2\n4 0 2 1 3 0 5 6 7 1 3 2 4 10 48 1 6 0 5 0 4 0 5 1 3 0 12 0 1 6 7 1000000000\n1000000000 1000000000 11 15 17 0 17 1 10000 1 51 0 92 0 53 1 16 0 1 Output 2\n11 14 29 80 100 100 100 118 190 196 3000000094 3000060094 3000060400\n3000060952 3000061270 3000061366 3000061366 Note In the first test case, the\narray \n    a = [2]\n after the first query. In the third test case, the array\n\n    a\n is modified as follows: \n    [1, 3, 2, 4, 10, 48]\n \n    \u2192\n\n\n    [7, 9, 2, 4, 10, 48]\n \n    \u2192\n \n    [7, 9, 7, 9, 15, 53]\n\n\n    \u2192\n \n    [7, 9, 7, 9, 15, 53]\n \n    \u2192\n \n    [10, 12,\n    10, 12, 18, 56]\n \n    \u2192\n \n    [22, 24, 22, 24, 30, 68]\n\n\n    \u2192\n \n    [23, 25, 23, 25, 31, 69]\n.\n\n",
        "cf_contest_id": 1744,
        "cf_index": "B",
        "cf_rating": 800,
        "difficulty": 0,
        "cf_tags": [
            "implementation",
            "math"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "4\r\n1 1\r\n1\r\n1 1\r\n3 3\r\n1 2 4\r\n0 2\r\n1 3\r\n0 5\r\n6 7\r\n1 3 2 4 10 48\r\n1 6\r\n0 5\r\n0 4\r\n0 5\r\n1 3\r\n0 12\r\n0 1\r\n6 7\r\n1000000000 1000000000 1000000000 11 15 17\r\n0 17\r\n1 10000\r\n1 51\r\n0 92\r\n0 53\r\n1 16\r\n0 1\r\n",
                "2\r\n11\r\n14\r\n29\r\n80\r\n100\r\n100\r\n100\r\n118\r\n190\r\n196\r\n3000000094\r\n3000060094\r\n3000060400\r\n3000060952\r\n3000061270\r\n3000061366\r\n3000061366\r\n"
            ]
        ],
        "private_cases": []
    }
]