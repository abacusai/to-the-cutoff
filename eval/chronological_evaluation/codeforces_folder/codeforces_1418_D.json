[
    {
        "name": "Trash Problem",
        "description": "Vova decided to clean his room. The room can be represented as the coordinate\naxis \n    OX\n. There are \n    n\n piles of trash in the room, coordinate of the\n\n    i\n-th pile is the integer \n    p_i\n. All piles have different\ncoordinates. Let's define a total cleanup as the following process. The goal\nof this process is to collect all the piles in no more than two different\n\n    x\n coordinates. To achieve this goal, Vova can do several (possibly,\nzero) moves. During one move, he can choose some \n    x\n and move all piles\nfrom \n    x\n to \n    x+1\n or \n    x-1\n using his broom. Note that he can't\nchoose how many piles he will move. Also, there are two types of queries:\n\n    0\n \n    x\n \u2014 remove a pile of trash from the coordinate \n    x\n. It is\nguaranteed that there is a pile in the coordinate \n    x\n at this moment.\n\n    1\n \n    x\n \u2014 add a pile of trash to the coordinate \n    x\n. It is\nguaranteed that there is no pile in the coordinate \n    x\n at this moment.\nNote that it is possible that there are zero piles of trash in the room at\nsome moment. Vova wants to know the minimum number of moves he can spend if he\nwants to do a total cleanup before any queries. He also wants to know this\nnumber of moves after applying each query. Queries are applied in the given\norder. Note that the total cleanup doesn't actually happen and doesn't change\nthe state of piles. It is only used to calculate the number of moves. For\nbetter understanding, please read the Notes section below to see an\nexplanation for the first example. Input The first line of the input contains\ntwo integers \n    n\n and \n    q\n (\n    1 \n    \u2264 n, q \n    \u2264 10^5\n) \u2014 the number\nof piles in the room before all queries and the number of queries,\nrespectively. The second line of the input contains \n    n\n distinct integers\n\n    p_1, p_2, \n    \u2026, p_n\n (\n    1 \n    \u2264 p_i \n    \u2264 10^9\n), where \n    p_i\n\nis the coordinate of the \n    i\n-th pile. The next \n    q\n lines describe\nqueries. The \n    i\n-th query is described with two integers \n    t_i\n and\n\n    x_i\n (\n    0 \n    \u2264 t_i \n    \u2264 1; 1 \n    \u2264 x_i \n    \u2264 10^9\n), where \n    t_i\n\nis \n    0\n if you need to remove a pile from the coordinate \n    x_i\n and is\n\n    1\n if you need to add a pile to the coordinate \n    x_i\n. It is\nguaranteed that for \n    t_i = 0\n there is such pile in the current set of\npiles and for \n    t_i = 1\n there is no such pile in the current set of piles.\nOutput Print \n    q+1\n integers: the minimum number of moves Vova needs to do\na total cleanup before the first query and after each of \n    q\n queries.\nExamples Input 5 6 1 2 6 8 10 1 4 1 9 0 6 0 10 1 100 1 50 Output 5 7 7 5 4 8\n49 Input 5 8 5 1 2 4 3 0 1 0 2 0 3 0 4 0 5 1 1000000000 1 1 1 500000000 Output\n3 2 1 0 0 0 0 0 499999999 Note Consider the first example. Initially, the set\nof piles is \n    [1, 2, 6, 8, 10]\n. The answer before the first query is\n\n    5\n because you can move all piles from \n    1\n to \n    2\n with one move,\nall piles from \n    10\n to \n    8\n with \n    2\n moves and all piles from\n\n    6\n to \n    8\n with \n    2\n moves. After the first query, the set becomes\n\n    [1, 2, 4, 6, 8, 10]\n. Then the answer is \n    7\n because you can move all\npiles from \n    6\n to \n    4\n with \n    2\n moves, all piles from \n    4\n to\n\n    2\n with \n    2\n moves, all piles from \n    2\n to \n    1\n with \n    1\n\nmove and all piles from \n    10\n to \n    8\n with \n    2\n moves. After the\nsecond query, the set of piles becomes \n    [1, 2, 4, 6, 8, 9, 10]\n and the\nanswer is the same (and the previous sequence of moves can be applied to the\ncurrent set of piles). After the third query, the set of piles becomes \n    [1,\n    2, 4, 8, 9, 10]\n and the answer is \n    5\n because you can move all piles\nfrom \n    1\n to \n    2\n with \n    1\n move, all piles from \n    2\n to \n    4\n\nwith \n    2\n moves, all piles from \n    10\n to \n    9\n with \n    1\n move and\nall piles from \n    9\n to \n    8\n with \n    1\n move. After the fourth query,\nthe set becomes \n    [1, 2, 4, 8, 9]\n and the answer is almost the same (the\nprevious sequence of moves can be applied without moving piles from \n    10\n).\nAfter the fifth query, the set becomes \n    [1, 2, 4, 8, 9, 100]\n. You can\nmove all piles from \n    1\n and further to \n    9\n and keep \n    100\n at its\nplace. So the answer is \n    8\n. After the sixth query, the set becomes \n    [1,\n    2, 4, 8, 9, 50, 100]\n. The answer is \n    49\n and can be obtained with\nalmost the same sequence of moves as after the previous query. The only\ndifference is that you need to move all piles from \n    50\n to \n    9\n too.\n\n",
        "cf_contest_id": 1418,
        "cf_index": "D",
        "cf_rating": 2100,
        "difficulty": 0,
        "cf_tags": [
            "data structures",
            "implementation"
        ],
        "time_limit_seconds": 3.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "5 6\r\n1 2 6 8 10\r\n1 4\r\n1 9\r\n0 6\r\n0 10\r\n1 100\r\n1 50\r\n",
                "5\r\n7\r\n7\r\n5\r\n4\r\n8\r\n49\r\n"
            ],
            [
                "5 8\r\n5 1 2 4 3\r\n0 1\r\n0 2\r\n0 3\r\n0 4\r\n0 5\r\n1 1000000000\r\n1 1\r\n1 500000000\r\n",
                "3\r\n2\r\n1\r\n0\r\n0\r\n0\r\n0\r\n0\r\n499999999\r\n"
            ]
        ],
        "private_cases": []
    }
]