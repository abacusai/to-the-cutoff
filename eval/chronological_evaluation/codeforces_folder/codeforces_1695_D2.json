[
    {
        "name": "Tree Queries (Hard Version)",
        "description": "The only difference between this problem and D1 is the bound on the size of\nthe tree. You are given an unrooted tree with \n    n\n vertices. There is some\nhidden vertex \n    x\n in that tree that you are trying to find. To do this,\nyou may ask \n    k\n queries \n    v_1, v_2, \n    \u2026, v_k\n where the \n    v_i\n\nare vertices in the tree. After you are finished asking all of the queries,\nyou are given \n    k\n numbers \n    d_1, d_2, \n    \u2026, d_k\n, where \n    d_i\n\nis the number of edges on the shortest path between \n    v_i\n and \n    x\n.\nNote that you know which distance corresponds to which query. What is the\nminimum \n    k\n such that there exists some queries \n    v_1, v_2, \n    \u2026,\n    v_k\n that let you always uniquely identify \n    x\n (no matter what \n    x\n\nis). Note that you don't actually need to output these queries. Input Each\ntest contains multiple test cases. The first line contains the number of test\ncases \n    t\n (\n    1 \n    \u2264 t \n    \u2264 10^4\n). Description of the test cases\nfollows. The first line of each test case contains a single integer \n    n\n\n(\n    1 \n    \u2264 n \n    \u2264 2\n    \u00b710^5\n) \u2014 the number of vertices in the tree.\nEach of the next \n    n-1\n lines contains two integers \n    x\n and \n    y\n\n(\n    1 \n    \u2264 x, y \n    \u2264 n\n), meaning there is an edges between vertices\n\n    x\n and \n    y\n in the tree. It is guaranteed that the given edges form a\ntree. It is guaranteed that the sum of \n    n\n over all test cases does not\nexceed \n    2\n    \u00b710^5\n. Output For each test case print a single\nnonnegative integer, the minimum number of queries you need, on its own line.\nExample Input 3 1 2 1 2 10 2 4 2 1 5 7 3 10 8 6 6 1 1 3 4 7 9 6 Output 0 1 2\nNote In the first test case, there is only one vertex, so you don't need any\nqueries. In the second test case, you can ask a single query about the node\n\n    1\n. Then, if \n    x = 1\n, you will get \n    0\n, otherwise you will get\n\n    1\n.\n\n",
        "cf_contest_id": 1695,
        "cf_index": "D2",
        "cf_rating": 2300,
        "difficulty": 0,
        "cf_tags": [
            "constructive algorithms",
            "dfs and similar",
            "dp",
            "greedy",
            "trees"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "3\r\n1\r\n2\r\n1 2\r\n10\r\n2 4\r\n2 1\r\n5 7\r\n3 10\r\n8 6\r\n6 1\r\n1 3\r\n4 7\r\n9 6\r\n",
                "0\r\n1\r\n2\r\n"
            ]
        ],
        "private_cases": []
    }
]