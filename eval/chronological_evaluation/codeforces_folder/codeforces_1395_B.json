[
    {
        "name": "Boboniu Plays Chess",
        "description": "Boboniu likes playing chess with his employees. As we know, no employee can\nbeat the boss in the chess game, so Boboniu has never lost in any round. You\nare a new applicant for his company. Boboniu will test you with the following\nchess question: Consider a \n    n\n    \u00d7 m\n grid (rows are numbered from\n\n    1\n to \n    n\n, and columns are numbered from \n    1\n to \n    m\n). You\nhave a chess piece, and it stands at some cell \n    (S_x,S_y)\n which is not on\nthe border (i.e. \n    2 \n    \u2264 S_x \n    \u2264 n-1\n and \n    2 \n    \u2264 S_y \n    \u2264 m-1\n).\nFrom the cell \n    (x,y)\n, you can move your chess piece to \n    (x,y')\n\n(\n    1\n    \u2264 y'\n    \u2264 m, y' \n    \u2260 y\n) or \n    (x',y)\n (\n    1\n    \u2264 x'\n    \u2264 n,\n    x'\n    \u2260 x\n). In other words, the chess piece moves as a rook. From the\ncell, you can move to any cell on the same row or column. Your goal is to\nvisit each cell exactly once. Can you find a solution? Note that cells on the\npath between two adjacent cells in your route are not counted as visited, and\nit is not required to return to the starting point. Input The only line of the\ninput contains four integers \n    n\n, \n    m\n, \n    S_x\n and \n    S_y\n\n(\n    3\n    \u2264 n,m\n    \u2264 100\n, \n    2 \n    \u2264 S_x \n    \u2264 n-1\n, \n    2 \n    \u2264 S_y \n    \u2264\n    m-1\n) \u2014 the number of rows, the number of columns, and the initial position\nof your chess piece, respectively. Output You should print \n    n\n    \u00b7 m\n\nlines. The \n    i\n-th line should contain two integers \n    x_i\n and \n    y_i\n\n(\n    1 \n    \u2264 x_i \n    \u2264 n\n, \n    1 \n    \u2264 y_i \n    \u2264 m\n), denoting the\n\n    i\n-th cell that you visited. You should print exactly \n    nm\n pairs\n\n    (x_i, y_i)\n, they should cover all possible pairs \n    (x_i, y_i)\n, such\nthat \n    1 \n    \u2264 x_i \n    \u2264 n\n, \n    1 \n    \u2264 y_i \n    \u2264 m\n. We can show\nthat under these constraints there always exists a solution. If there are\nmultiple answers, print any. Examples Input 3 3 2 2 Output 2 2 1 2 1 3 2 3 3 3\n3 2 3 1 2 1 1 1 Input 3 4 2 2 Output 2 2 2 1 2 3 2 4 1 4 3 4 3 3 3 2 3 1 1 1 1\n2 1 3 Note Possible routes for two examples:\n\n",
        "cf_contest_id": 1395,
        "cf_index": "B",
        "cf_rating": 1100,
        "difficulty": 0,
        "cf_tags": [
            "constructive algorithms"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 512.0,
        "public_cases": [
            [
                "3 3 2 2\r\n",
                "2 2 2 3 2 1 3 1 3 2 3 3 1 3 1 1 1 2 "
            ],
            [
                "3 4 2 2\r\n",
                "2 2 2 3 2 4 2 1 3 1 3 2 3 3 3 4 1 4 1 1 1 2 1 3 "
            ]
        ],
        "private_cases": [
            [
                "4 4 2 3\r\n",
                "2 3 2 4 2 1 2 2 3 2 3 3 3 4 3 1 4 1 4 2 4 3 4 4 1 4 1 1 1 2 1 3 "
            ],
            [
                "4 3 3 2\r\n",
                "3 2 3 3 3 1 4 1 4 2 4 3 1 3 1 1 1 2 2 2 2 3 2 1 "
            ],
            [
                "4 3 2 2\r\n",
                "2 2 2 3 2 1 3 1 3 2 3 3 4 3 4 1 4 2 1 2 1 3 1 1 "
            ],
            [
                "4 4 3 2\r\n",
                "3 2 3 3 3 4 3 1 4 1 4 2 4 3 4 4 1 4 1 1 1 2 1 3 2 3 2 4 2 1 2 2 "
            ],
            [
                "4 4 2 2\r\n",
                "2 2 2 3 2 4 2 1 3 1 3 2 3 3 3 4 4 4 4 1 4 2 4 3 1 3 1 4 1 1 1 2 "
            ],
            [
                "4 4 3 3\r\n",
                "3 3 3 4 3 1 3 2 4 2 4 3 4 4 4 1 1 1 1 2 1 3 1 4 2 4 2 1 2 2 2 3 "
            ]
        ]
    }
]