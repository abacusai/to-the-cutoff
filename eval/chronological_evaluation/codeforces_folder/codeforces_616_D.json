[
    {
        "name": "Longest k-Good Segment",
        "description": "The array a with n integers is given. Let's call the sequence of one or more\nconsecutive elements in a segment. Also let's call the segment k-good if it\ncontains no more than k different values. Find any longest k-good segment. As\nthe input/output can reach huge size it is recommended to use fast\ninput/output methods: for example, prefer to use scanf/printf instead of\ncin/cout in C++, prefer to use BufferedReader/PrintWriter instead of\nScanner/System.out in Java. Input The first line contains two integers n, k (1\n\u2264 k \u2264 n \u2264 5\u00b710^5) \u2014 the number of elements in a and the parameter k. The\nsecond line contains n integers ai (0 \u2264 ai \u2264 10^6) \u2014 the elements of the array\na. Output Print two integers l, r (1 \u2264 l \u2264 r \u2264 n) \u2014 the index of the left and\nthe index of the right ends of some k-good longest segment. If there are\nseveral longest segments you can print any of them. The elements in a are\nnumbered from 1 to n from left to right. Examples Input 5 5 1 2 3 4 5 Output 1\n5 Input 9 3 6 5 1 2 3 2 1 4 5 Output 3 7 Input 3 1 1 2 3 Output 1 1\n\n",
        "cf_contest_id": 616,
        "cf_index": "D",
        "cf_rating": 1600,
        "difficulty": 0,
        "cf_tags": [
            "binary search",
            "data structures",
            "two pointers"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "5 5\r\n1 2 3 4 5\r\n",
                "1 5"
            ],
            [
                "9 3\r\n6 5 1 2 3 2 1 4 5\r\n",
                "3 7"
            ],
            [
                "3 1\r\n1 2 3\r\n",
                "3 3"
            ]
        ],
        "private_cases": [
            [
                "1 1\r\n747391\r\n",
                "1 1"
            ],
            [
                "5 2\r\n171230 171230 171230 171230 171230\r\n",
                "1 5"
            ],
            [
                "10 3\r\n512008 512008 452221 512008 314256 123232 314256 512008 314256 123232\r\n",
                "4 10"
            ],
            [
                "6 1\r\n1 1 2 1 1 1\r\n",
                "4 6"
            ],
            [
                "5 4\r\n1 2 3 4 0\r\n",
                "2 5"
            ],
            [
                "5 4\r\n2 3 4 5 0\r\n",
                "2 5"
            ],
            [
                "2 2\r\n0 1\r\n",
                "1 2"
            ],
            [
                "2 2\r\n0 0\r\n",
                "1 2"
            ],
            [
                "5 4\r\n1 2 3 45 0\r\n",
                "2 5"
            ]
        ]
    }
]