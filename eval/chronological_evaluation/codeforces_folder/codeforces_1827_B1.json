[
    {
        "name": "Range Sorting (Easy Version)",
        "description": "The only difference between this problem and the hard version is the\nconstraints on \n    t\n and \n    n\n. You are given an array \n    a\n, consisting\nof \n    n\n distinct integers \n    a_1, a_2, \n    \u2026, a_n\n. Define the beauty\nof an array \n    p_1, p_2, \n    \u2026 p_k\n as the minimum amount of time needed\nto sort this array using an arbitrary number of range-sort operations. In each\nrange-sort operation, you will do the following: Choose two integers \n    l\n\nand \n    r\n (\n    1 \n    \u2264 l < r \n    \u2264 k\n). Sort the subarray \n    p_l, p_l +\n    1, \n    \u2026, p_r\n in \n    r - l\n seconds. Please calculate the sum of\nbeauty over all subarrays of array \n    a\n. A subarray of an array is defined\nas a sequence of consecutive elements of the array. Input Each test contains\nmultiple test cases. The first line contains the number of test cases \n    t\n\n(\n    1 \n    \u2264 t \n    \u2264 5 \n    \u00b7 10^3\n). The description of the test cases\nfollows. The first line of each test case contains a single integer \n    n\n\n(\n    1 \n    \u2264 n \n    \u2264 5 \n    \u00b7 10^3\n) \u2014 the length of the array \n    a\n. The\nsecond line of each test case consists of \n    n\n integers\n\n    a_1,a_2,\n    \u2026, a_n\n (\n    1\n    \u2264 a_i\n    \u2264 10^9\n). It is guaranteed\nthat all elements of \n    a\n are pairwise distinct. It is guaranteed that the\nsum of \n    n\n over all test cases does not exceed \n    5 \n    \u00b7 10^3\n.\nOutput For each test case, output the sum of beauty over all subarrays of\narray \n    a\n. Example Input 5 2 6 4 3 3 10 6 4 4 8 7 2 5 9 8 2 4 6 12 2 6 13\n3 15 5 10 8 16 9 11 18 Output 1 2 8 16 232 Note In the first test case: The\nsubarray \n    [6]\n is already sorted, so its beauty is \n    0\n. The subarray\n\n    [4]\n is already sorted, so its beauty is \n    0\n. You can sort the\nsubarray \n    [6, 4]\n in one operation by choosing \n    l = 1\n and \n    r =\n    2\n. Its beauty is equal to \n    1\n. The sum of beauty over all subarrays of\nthe given array is equal to \n    0 + 0 + 1 = 1\n.In the second test case: The\nsubarray \n    [3]\n is already sorted, so its beauty is \n    0\n. The subarray\n\n    [10]\n is already sorted, so its beauty is \n    0\n. The subarray \n    [6]\n\nis already sorted, so its beauty is \n    0\n. The subarray \n    [3, 10]\n is\nalready sorted, so its beauty is \n    0\n. You can sort the subarray \n    [10,\n    6]\n in one operation by choosing \n    l = 1\n and \n    r = 2\n. Its beauty is\nequal to \n    2 - 1 = 1\n. You can sort the subarray \n    [3, 10, 6]\n in one\noperation by choosing \n    l = 2\n and \n    r = 3\n. Its beauty is equal to \n    3\n    - 2 = 1\n. The sum of beauty over all subarrays of the given array is equal\nto \n    0 + 0 + 0 + 0 + 1 + 1 = 2\n.\n\n",
        "cf_contest_id": 1827,
        "cf_index": "B1",
        "cf_rating": 2000,
        "difficulty": 0,
        "cf_tags": [
            "binary search",
            "dp",
            "dsu",
            "greedy",
            "trees",
            "two pointers"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "5\r\n2\r\n6 4\r\n3\r\n3 10 6\r\n4\r\n4 8 7 2\r\n5\r\n9 8 2 4 6\r\n12\r\n2 6 13 3 15 5 10 8 16 9 11 18\r\n",
                "1\r\n2\r\n8\r\n16\r\n232\r\n"
            ]
        ],
        "private_cases": []
    }
]