[
    {
        "name": "Two 0-1 Sequences",
        "description": "AquaMoon has two binary sequences \n    a\n and \n    b\n, which contain only\n\n    0\n and \n    1\n. AquaMoon can perform the following two operations any\nnumber of times (\n    a_1\n is the first element of \n    a\n, \n    a_2\n is the\nsecond element of \n    a\n, and so on): Operation 1: if \n    a\n contains at\nleast two elements, change \n    a_2\n to \n    min(a_1,a_2)\n,\nand remove the first element of \n    a\n. Operation 2: if \n    a\n contains at\nleast two elements, change \n    a_2\n to \n    max(a_1,a_2)\n,\nand remove the first element of \n    a\n.Note that after a removal of the first\nelement of \n    a\n, the former \n    a_2\n becomes the first element of \n    a\n,\nthe former \n    a_3\n becomes the second element of \n    a\n and so on, and the\nlength of \n    a\n reduces by one. Determine if AquaMoon can make \n    a\n equal\nto \n    b\n by using these operations. Input The first line contains a single\ninteger \n    t\n (\n    1 \n    \u2264 t \n    \u2264 2\n     000\n) \u2014 the number of test cases.\nDescription of test cases follows. The first line of each test case contains\ntwo integers \n    n\n, \n    m\n (\n    1 \n    \u2264 n,m \n    \u2264 50\n, \n    m \n    \u2264 n\n)\n\u2014 the lengths of \n    a\n and \n    b\n respectively. The second line of each\ntest case contains a string \n    a\n of length \n    n\n, consisting only \n    0\n\nand \n    1\n. The third line of each test case contains a string \n    b\n of\nlength \n    m\n, consisting only \n    0\n and \n    1\n. Output For each test\ncase, output \"YES\" if AquaMoon can change \n    a\n to \n    b\n by using these\noptions; otherwise, output \"NO\". You may print each letter in any case (for\nexample, \"YES\", \"Yes\", \"yes\", \"yEs\" will all be recognized as a positive\nanswer). Example Input 10 6 2 001001 11 6 2 110111 01 6 2 000001 11 6 2 111111\n01 8 5 10000101 11010 7 4 1010001 1001 8 6 01010010 010010 8 4 01010101 1001 8\n4 10101010 0110 7 5 1011100 11100 Output YES YES NO NO NO YES YES NO NO YES\nNote In the first test case, you can use Operation 2 four times to make\n\n    a\n equals to \n    b\n. In the second test case, you can use Operation 1\nfour times to make \n    a\n equals to \n    b\n. In the third test case, it can\nbe proved that no matter how we use the operations, it is impossible to make\n\n    a\n equal to \n    b\n. In the fourth test case, it can be proved that no\nmatter how we use the operations, it is impossible to make \n    a\n equal to\n\n    b\n. In the fifth test case, you can use Operation 2 three times to make\n\n    a\n become \n    10101\n, so the first element of \n    a\n equals to the\nfirst element of \n    b\n, but it can be proved that no matter how to operate,\nthe second to the fifth elements of \n    a\n can't be the same as \n    b\n.\n\n",
        "cf_contest_id": 1704,
        "cf_index": "A",
        "cf_rating": 800,
        "difficulty": 0,
        "cf_tags": [
            "constructive algorithms",
            "greedy"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "10\r\n6 2\r\n001001\r\n11\r\n6 2\r\n110111\r\n01\r\n6 2\r\n000001\r\n11\r\n6 2\r\n111111\r\n01\r\n8 5\r\n10000101\r\n11010\r\n7 4\r\n1010001\r\n1001\r\n8 6\r\n01010010\r\n010010\r\n8 4\r\n01010101\r\n1001\r\n8 4\r\n10101010\r\n0110\r\n7 5\r\n1011100\r\n11100\r\n",
                "YES\r\nYES\r\nNO \r\nNO \r\nNO \r\nYES\r\nYES\r\nNO \r\nNO \r\nYES\r\n"
            ]
        ],
        "private_cases": []
    }
]