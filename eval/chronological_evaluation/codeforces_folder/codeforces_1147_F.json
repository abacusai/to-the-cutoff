[
    {
        "name": "Zigzag Game",
        "description": "You are given a complete bipartite graph with \n    2n\n nodes, with \n    n\n\nnodes on each side of the bipartition. Nodes \n    1\n through \n    n\n are on\none side of the bipartition, and nodes \n    n+1\n to \n    2n\n are on the other\nside. You are also given an \n    n \n    \u00d7 n\n matrix \n    a\n describing the\nedge weights. \n    a_ij\n denotes the weight of the edge between nodes\n\n    i\n and \n    j+n\n. Each edge has a distinct weight. Alice and Bob are\nplaying a game on this graph. First Alice chooses to play as either\n\"increasing\" or \"decreasing\" for herself, and Bob gets the other choice. Then\nshe places a token on any node of the graph. Bob then moves the token along\nany edge incident to that node. They now take turns playing the following\ngame, with Alice going first. The current player must move the token from the\ncurrent vertex to some adjacent unvisited vertex. Let \n    w\n be the last\nweight of the last edge that was traversed. The edge that is traversed must be\nstrictly greater than \n    w\n if the player is playing as \"increasing\",\notherwise, it must be strictly less. The first player unable to make a move\nloses. You are given \n    n\n and the edge weights of the graph. You can choose\nto play as either Alice or Bob, and you will play against the judge. You must\nwin all the games for your answer to be judged correct. Interaction Each test\ncontains multiple test cases. The first line contains the number of test cases\n\n    t\n (\n    1 \n    \u2264 t \n    \u2264 50\n). Description of the test cases follows.\nEach test starts with an integer \n    n\n (\n    1 \n    \u2264 n \n    \u2264 50\n) \u2014 the\nnumber of nodes on each side of the bipartition. The next \n    n\n lines\ncontain \n    n\n integers \n    a_ij\n (\n    1 \n    \u2264 a_ij\n    \u2264 n^2\n).\n\n    a_ij\n denotes the weight of the edge between node \n    i\n and node\n\n    j+n\n. All \n    a_ij\n will be distinct. You first print a string \"A\" or\n\"B\", denoting which player you want to play (\"A\" for Alice and \"B\" for Bob).\nIf playing as Alice, first print either \"I\" or \"D\" (denoting whether you\nchoose \"increasing\" or \"decreasing\"). Then, print the node that you wish to\nstart at. If playing as Bob, read in a character \"I\" or \"D\" (denoting whether\nthe judge chose \"increasing\" or \"decreasing\"), then the node that the judge\nchooses to start at. To make a move, print the index of the node that you wish\nto go to. To read what move the judge made, read an integer from standard in.\nIf the judge responds with \n    -1\n, then that means the judge has determined\nit has no legal moves (or it may have just given up) and that you won the\ncase. Stop processing this case immediately and start processing the next\ncase. If the judge responds with \n    -2\n, that means that the judge has\ndetermined that you made an invalid move, so you should exit immediately to\navoid getting other verdicts. If you are unable to make a move or give up,\nprint \n    -1\n and then exit immediately. This will give you a Wrong answer\nverdict. After printing a move do not forget to output end of line and flush\nthe output. Otherwise, you will get Idleness limit exceeded. To do this, use:\nfflush(stdout) or cout.flush() in C++; System.out.flush() in Java;\nflush(output) in Pascal; stdout.flush() in Python; see documentation for other\nlanguages.Hack Format To hack, use the following format. Note that you can\nonly hack with one test case. The first line should contain a single integer\n\n    t\n (\n    t=1\n). The second line should contain an integer \n    n\n (\n    1\n    \n    \u2264 n \n    \u2264 50\n). The next \n    n\n lines should contain \n    n\n integers\neach, the \n    a_ij\n (\n    1 \n    \u2264 a_ij\n    \u2264 n^2\n). \n    a_ij\n\ndenotes the weight of the edge between node \n    i\n and node \n    j+n\n. All\n\n    a_ij\n must be distinct. The judge will play a uniformly random legal\nmove with this case versus the hacked program. If it has no legal moves left,\nit will give up and declare the player as the winner. Example Input 2 3 3 1 9\n2 5 7 6 4 8 6 -1 1 1 I 1 -1 Output A D 3 2 B 2 Note The first example has two\ntest cases. In the first test case, the graph looks like the following. In the\nsample output, the player decides to play as Alice and chooses \"decreasing\"\nand starting at node \n    3\n. The judge responds by moving to node \n    6\n.\nAfter, the player moves to node \n    2\n. At this point, the judge has no more\nmoves (since the weight must \"increase\"), so it gives up and prints \n    -1\n.\nIn the next case, we have two nodes connected by an edge of weight \n    1\n.\nThe player decides to play as Bob. No matter what the judge chooses, the\nplayer can move the token to the other node and the judge has no moves so will\nlose.\n\n",
        "cf_contest_id": 1147,
        "cf_index": "F",
        "cf_rating": 3500,
        "difficulty": 0,
        "cf_tags": [
            "games",
            "interactive"
        ],
        "time_limit_seconds": 5.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "2\r\n3\r\n3 1 9\r\n2 5 7\r\n6 4 8\r\n1\r\n1\r\n",
                "player won game 1!\r\nplayer won game 2!\r\n"
            ]
        ],
        "private_cases": [
            [
                "1\r\n2\r\n1 2\r\n3 4\r\n",
                "player won game 1!\r\n"
            ]
        ]
    }
]