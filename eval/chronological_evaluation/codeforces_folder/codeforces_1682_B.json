[
    {
        "name": "AND Sorting",
        "description": "You are given a permutation \n    p\n of integers from \n    0\n to \n    n-1\n\n(each of them occurs exactly once). Initially, the permutation is not sorted\n(that is, \n    p_i>p_i+1\n for at least one \n    1 \n    \u2264 i \n    \u2264 n - 1\n). The\npermutation is called \n    X\n-sortable for some non-negative integer \n    X\n\nif it is possible to sort the permutation by performing the operation below\nsome finite number of times: Choose two indices \n    i\n and \n    j\n \n    (1\n    \n    \u2264 i \n     j \n    \u2264 n)\n such that \n    p_i \n    & p_j = X\n. Swap \n    p_i\n\nand \n    p_j\n. Here \n    &\n denotes the bitwise AND operation. Find the\nmaximum value of \n    X\n such that \n    p\n is \n    X\n-sortable. It can be\nshown that there always exists some value of \n    X\n such that \n    p\n is\n\n    X\n-sortable. Input The input consists of multiple test cases. The first\nline contains a single integer \n    t\n \n    (1 \n    \u2264 t \n    \u2264 10^4)\n \u2014 the\nnumber of test cases. Description of test cases follows. The first line of\neach test case contains a single integer \n    n\n \n    (2 \n    \u2264 n \n    \u2264 2 \n    \u00b7\n    10^5)\n \u2014 the length of the permutation. The second line of each test case\ncontains \n    n\n integers \n    p_1, p_2, ..., p_n\n (\n    0 \n    \u2264 p_i \n    \u2264\n    n-1\n, all \n    p_i\n are distinct) \u2014 the elements of \n    p\n. It is\nguaranteed that \n    p\n is not sorted. It is guaranteed that the sum of\n\n    n\n over all cases does not exceed \n    2 \n    \u00b7 10^5\n. Output For each\ntest case output a single integer \u2014 the maximum value of \n    X\n such that\n\n    p\n is \n    X\n-sortable. Example Input 4 4 0 1 3 2 2 1 0 7 0 1 2 3 5 6 4 5\n0 3 2 1 4 Output 2 0 4 1 Note In the first test case, the only \n    X\n for\nwhich the permutation is \n    X\n-sortable are \n    X = 0\n and \n    X = 2\n,\nmaximum of which is \n    2\n. Sorting using \n    X = 0\n: Swap \n    p_1\n and\n\n    p_4\n, \n    p = [2, 1, 3, 0]\n. Swap \n    p_3\n and \n    p_4\n, \n    p = [2, 1,\n    0, 3]\n. Swap \n    p_1\n and \n    p_3\n, \n    p = [0, 1, 2, 3]\n. Sorting using\n\n    X = 2\n: Swap \n    p_3\n and \n    p_4\n, \n    p = [0, 1, 2, 3]\n. In the\nsecond test case, we must swap \n    p_1\n and \n    p_2\n which is possible only\nwith \n    X = 0\n.\n\n",
        "cf_contest_id": 1682,
        "cf_index": "B",
        "cf_rating": 1100,
        "difficulty": 0,
        "cf_tags": [
            "bitmasks",
            "constructive algorithms",
            "sortings"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "4\r\n4\r\n0 1 3 2\r\n2\r\n1 0\r\n7\r\n0 1 2 3 5 6 4\r\n5\r\n0 3 2 1 4\r\n",
                "2\r\n0\r\n4\r\n1\r\n"
            ]
        ],
        "private_cases": []
    }
]