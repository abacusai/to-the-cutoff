[
    {
        "name": "Flip the Bits",
        "description": "There is a binary string \n    a\n of length \n    n\n. In one operation, you can\nselect any prefix of \n    a\n with an equal number of \n    0\n and \n    1\n\nsymbols. Then all symbols in the prefix are inverted: each \n    0\n becomes\n\n    1\n and each \n    1\n becomes \n    0\n. For example, suppose\n\n    a=0111010000\n. In the first operation, we can select the prefix of length\n\n    8\n since it has four \n    0\n's and four \n    1\n's: \n    [01110100]00\n    \u2192\n    [10001011]00\n. In the second operation, we can select the prefix of length\n\n    2\n since it has one \n    0\n and one \n    1\n: \n    [10]00101100\n    \u2192\n    [01]00101100\n. It is illegal to select the prefix of length \n    4\n for the\nthird operation, because it has three \n    0\n's and one \n    1\n. Can you\ntransform the string \n    a\n into the string \n    b\n using some finite number\nof operations (possibly, none)? Input The first line contains a single integer\n\n    t\n (\n    1\n    \u2264 t\n    \u2264 10^4\n) \u2014 the number of test cases. The first line\nof each test case contains a single integer \n    n\n (\n    1\n    \u2264 n\n    \u2264 3\n    \u00b7\n    10^5\n) \u2014 the length of the strings \n    a\n and \n    b\n. The following two\nlines contain strings \n    a\n and \n    b\n of length \n    n\n, consisting of\nsymbols \n    0\n and \n    1\n. The sum of \n    n\n across all test cases does not\nexceed \n    3\n    \u00b7 10^5\n. Output For each test case, output \"YES\" if it is\npossible to transform \n    a\n into \n    b\n, or \"NO\" if it is impossible. You\ncan print each letter in any case (upper or lower). Example Input 5 10\n0111010000 0100101100 4 0000 0000 3 001 000 12 010101010101 100110011010 6\n000111 110100 Output YES YES NO YES NO Note The first test case is shown in\nthe statement. In the second test case, we transform \n    a\n into \n    b\n by\nusing zero operations. In the third test case, there is no legal operation, so\nit is impossible to transform \n    a\n into \n    b\n. In the fourth test case,\nhere is one such transformation: Select the length \n    2\n prefix to get\n\n    100101010101\n. Select the length \n    12\n prefix to get\n\n    011010101010\n. Select the length \n    8\n prefix to get\n\n    100101011010\n. Select the length \n    4\n prefix to get\n\n    011001011010\n. Select the length \n    6\n prefix to get\n\n    100110011010\n. In the fifth test case, the only legal operation is to\ntransform \n    a\n into \n    111000\n. From there, the only legal operation is\nto return to the string we started with, so we cannot transform \n    a\n into\n\n    b\n.\n\n",
        "cf_contest_id": 1504,
        "cf_index": "B",
        "cf_rating": 1200,
        "difficulty": 0,
        "cf_tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "math"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "5\r\n10\r\n0111010000\r\n0100101100\r\n4\r\n0000\r\n0000\r\n3\r\n001\r\n000\r\n12\r\n010101010101\r\n100110011010\r\n6\r\n000111\r\n110100\r\n",
                "YES\r\nYES\r\nNO \r\nYES\r\nNO \r\n"
            ]
        ],
        "private_cases": []
    }
]