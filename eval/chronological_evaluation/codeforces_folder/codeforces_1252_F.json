[
    {
        "name": "Regular Forestation",
        "description": "A forestation is an act of planting a bunch of trees to grow a forest, usually\nto replace a forest that had been cut down. Strangely enough, graph theorists\nhave another idea on how to make a forest, i.e. by cutting down a tree! A tree\nis a graph of \n    N\n nodes connected by \n    N - 1\n edges. Let \n    u\n be a\nnode in a tree \n    U\n which degree is at least \n    2\n (i.e. directly\nconnected to at least \n    2\n other nodes in \n    U\n). If we remove \n    u\n\nfrom \n    U\n, then we will get two or more disconnected (smaller) trees, or\nalso known as forest by graph theorists. In this problem, we are going to\ninvestigate a special forestation of a tree done by graph theorists. Let\n\n    V(S)\n be the set of nodes in a tree \n    S\n and \n    V(T)\n be the set of\nnodes in a tree \n    T\n. Tree \n    S\n and tree \n    T\n are identical if there\nexists a bijection \n    f : V(S) \n    \u2192 V(T)\n such that for all pairs\nof nodes \n    (s_i, s_j)\n in \n    V(S)\n, \n    s_i\n and \n    s_j\n is connected\nby an edge in \n    S\n if and only if node \n    f(s_i)\n and \n    f(s_j)\n is\nconnected by an edge in \n    T\n. Note that \n    f(s) = t\n implies node \n    s\n\nin \n    S\n corresponds to node \n    t\n in \n    T\n. We call a node \n    u\n in a\ntree \n    U\n as a good cutting point if and only if the removal of \n    u\n\nfrom \n    U\n causes two or more disconnected trees, and all those disconnected\ntrees are pairwise identical. Given a tree \n    U\n, your task is to determine\nwhether there exists a good cutting point in \n    U\n. If there is such a node,\nthen you should output the maximum number of disconnected trees that can be\nobtained by removing exactly one good cutting point. For example, consider the\nfollowing tree of \n    13\n nodes. There is exactly one good cutting point in\nthis tree, i.e. node \n    4\n. Observe that by removing node \n    4\n, we will\nget three identical trees (in this case, line graphs), i.e. \n    5, 1, 7,\n    13\n, \n    8, 2, 11, 6\n, and \n    3, 12, 9, 10\n,\nwhich are denoted by \n    A\n, \n    B\n, and \n    C\n respectively in the figure.\nThe bijection function between \n    A\n and \n    B\n: \n    f(5) = 8\n, \n    f(1) =\n    2\n, \n    f(7) = 11\n, and \n    f(13) = 6\n. The bijection function between\n\n    A\n and \n    C\n: \n    f(5) = 3\n, \n    f(1) = 12\n, \n    f(7) = 9\n, and\n\n    f(13) = 10\n. The bijection function between \n    B\n and \n    C\n: \n    f(8)\n    = 3\n, \n    f(2) = 12\n, \n    f(11) = 9\n, and \n    f(6) = 10\n. Of course,\nthere exists other bijection functions for those trees. Input Input begins\nwith a line containting an integer: \n    N\n (\n    3 \n    \u2264 N \n    \u2264 4000\n)\nrepresenting the number of nodes in the given tree. The next \n    N - 1\n lines\neach contains two integers: \n    a_i\n \n    b_i\n (\n    1 \n    \u2264 a_i < b_i \n    \u2264\n    N\n) representing an edge \n    (a_i,b_i)\n in the given tree. It is guaranteed\nthat any two nodes in the given tree are connected to each other by a sequence\nof edges. Output Output in a line an integer representing the maximum number\nof disconnected trees that can be obtained by removing exactly one good\ncutting point, or output -1 if there is no such good cutting point. Examples\nInput 13 1 5 1 7 2 4 2 8 2 11 3 12 4 7 4 12 6 11 7 13 9 10 9 12 Output 3 Input\n6 1 2 1 3 2 4 3 5 3 6 Output -1 Note Explanation for the sample input/output\n#1 This is the example from the problem description.\n\n",
        "cf_contest_id": 1252,
        "cf_index": "F",
        "cf_rating": 2400,
        "difficulty": 0,
        "cf_tags": [
            "hashing",
            "trees"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [],
        "private_cases": []
    }
]