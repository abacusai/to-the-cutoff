[
    {
        "name": "Lex String",
        "description": "Kuznecov likes art, poetry, and music. And strings consisting of lowercase\nEnglish letters. Recently, Kuznecov has found two strings, \n    a\n and\n\n    b\n, of lengths \n    n\n and \n    m\n respectively. They consist of\nlowercase English letters and no character is contained in both strings. Let\nanother string \n    c\n be initially empty. Kuznecov can do the following two\ntypes of operations: Choose any character from the string \n    a\n, remove it\nfrom \n    a\n, and add it to the end of \n    c\n. Choose any character from the\nstring \n    b\n, remove it from \n    b\n, and add it to the end of \n    c\n. But,\nhe can not do more than \n    k\n operations of the same type in a row. He must\nperform operations until either \n    a\n or \n    b\n becomes empty. What is the\nlexicographically smallest possible value of \n    c\n after he finishes? A\nstring \n    x\n is lexicographically smaller than a string \n    y\n if and only\nif one of the following holds: \n    x\n is a prefix of \n    y\n, but \n    x \n    \u2260\n    y\n; in the first position where \n    x\n and \n    y\n differ, the string\n\n    x\n has a letter that appears earlier in the alphabet than the\ncorresponding letter in \n    y\n. Input There are several test cases in the\ninput data. The first line contains a single integer \n    t\n (\n    1 \n    \u2264 t\n    \n    \u2264 100\n) \u2014 the number of test cases. This is followed by the test cases\ndescription. The first line of each test case contains three integers \n    n\n,\n\n    m\n, and \n    k\n (\n    1\n    \u2264 n,m,k \n    \u2264 100\n) \u2014 parameters from the\nstatement. The second line of each test case contains the string \n    a\n of\nlength \n    n\n. The third line of each test case contains the string \n    b\n\nof length \n    m\n. The strings contain only lowercase English letters. It is\nguaranteed that no symbol appears in \n    a\n and \n    b\n simultaneously.\nOutput In each test case, output a single string \n    c\n \u2014 the answer to the\nproblem. Example Input 3 6 4 2 aaaaaa bbbb 5 9 3 caaca bedededeb 7 7 1 noskill\nwxhtzdy Output aabaabaa aaabbcc dihktlwlxnyoz Note In the first test case, it\nis optimal to take two 'a's from the string \n    a\n and add them to the string\n\n    c\n. Then it is forbidden to take more characters from \n    a\n, hence one\ncharacter 'b' from the string \n    b\n has to be taken. Following that logic,\nwe end up with \n    c\n being 'aabaabaa' when string \n    a\n is emptied. In the\nsecond test case it is optimal to take as many 'a's from string \n    a\n as\npossible, then take as many 'b's as possible from string \n    b\n. In the end,\nwe take two 'c's from the string \n    a\n emptying it.\n\n",
        "cf_contest_id": 1689,
        "cf_index": "A",
        "cf_rating": 800,
        "difficulty": 0,
        "cf_tags": [
            "brute force",
            "greedy",
            "implementation",
            "sortings",
            "two pointers"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "3\r\n6 4 2\r\naaaaaa\r\nbbbb\r\n5 9 3\r\ncaaca\r\nbedededeb\r\n7 7 1\r\nnoskill\r\nwxhtzdy\r\n",
                "aabaabaa\r\naaabbcc\r\ndihktlwlxnyoz\r\n"
            ]
        ],
        "private_cases": [
            [
                "1\r\n5 1 5\r\naaaaa\r\nx\r\n",
                "aaaaa\r\n"
            ]
        ]
    }
]