[
    {
        "name": "BinaryStringForces",
        "description": "You are given a binary string \n    s\n of length \n    n\n. We define a maximal\nsubstring as a substring that cannot be extended while keeping all elements\nequal. For example, in the string \n    11000111\n there are three maximal\nsubstrings: \n    11\n, \n    000\n and \n    111\n. In one operation, you can\nselect two maximal adjacent substrings. Since they are maximal and adjacent,\nit's easy to see their elements must have different values. Let \n    a\n be the\nlength of the sequence of ones and \n    b\n be the length of the sequence of\nzeros. Then do the following: If \n    a \n    \u2265 b\n, then replace \n    b\n\nselected zeros with \n    b\n ones. If \n    a < b\n, then replace \n    a\n\nselected ones with \n    a\n zeros.As an example, for \n    1110000\n we make it\n\n    0000000\n, for \n    0011\n we make it \n    1111\n. We call a string being\ngood if it can be turned into \n    1111...1111\n using the aforementioned\noperation any number of times (possibly, zero). Find the number of good\nsubstrings among all \n    n(n+1)/2\n non-empty substrings of \n    s\n.\nInput Each test consists of multiple test cases. The first line contains a\nsingle integer \n    t\n (\n    1 \n    \u2264 t \n    \u2264 10^5\n) \u2014 the number of test\ncases. The description of test cases follows. The first line of each test case\ncontains \n    n\n (\n    1 \n    \u2264 n \n    \u2264 2 \n    \u00b7 10^5\n) \u2014 the length of the\nstring \n    s\n. The second line of each test case contains the binary string\n\n    s\n of length \n    n\n. It is guaranteed that sum of \n    n\n across all\ntest cases doesn't exceed \n    2 \n    \u00b7 10^5\n. Output For each test case,\nprint a single integer \u2014 the number of good substrings. Example Input 4 6\n100011 3 101 5 11111 6 010101 Output 8 5 15 18 Note Let's define a substring\nfrom index \n    l\n to index \n    r\n as \n    [l, r]\n. For the first test case,\nthe good substrings are: \n    [1,1]\n, \n    [1,2]\n, \n    [3,6]\n, \n    [4,5]\n,\n\n    [4,6]\n, \n    [5,5]\n, \n    [5,6]\n, \n    [6,6]\n. In the second test case,\nall substrings are good except \n    [2,2]\n. In the third test case, all\nsubstrings are good.\n\n",
        "cf_contest_id": 1750,
        "cf_index": "H",
        "cf_rating": 3500,
        "difficulty": 0,
        "cf_tags": [
            "constructive algorithms",
            "data structures",
            "dp"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "4\r\n6\r\n100011\r\n3\r\n101\r\n5\r\n11111\r\n6\r\n010101\r\n",
                "8\r\n5\r\n15\r\n18\r\n"
            ]
        ],
        "private_cases": [
            [
                "1\r\n10\r\n0101000010\r\n",
                "25\r\n"
            ],
            [
                "1\r\n10\r\n1001100000\r\n",
                "24\r\n"
            ],
            [
                "1\r\n10\r\n0010010010\r\n",
                "30\r\n"
            ],
            [
                "1\r\n100\r\n0111000000000010101110101110110001110111100011000100100100111101000111011011111101011100000100110010\r\n",
                "4658\r\n"
            ],
            [
                "1\r\n100\r\n1001100000011111100000000000000000011111111111111111100000000000000000000000000000000000000000000000\r\n",
                "1993\r\n"
            ],
            [
                "1\r\n100\r\n0010010010010010010010010010010010010010010010010010010010010010010010010010010010010010010010010010\r\n",
                "2805\r\n"
            ],
            [
                "1\r\n1\r\n0\r\n",
                "0\r\n"
            ],
            [
                "1\r\n10\r\n1000100100\r\n",
                "21\r\n"
            ],
            [
                "1\r\n100\r\n0110010010010001101000001101010111000100100100100100100100100100100100100100100100100001110110100010\r\n",
                "4028\r\n"
            ],
            [
                "1\r\n1\r\n1\r\n",
                "1\r\n"
            ],
            [
                "1\r\n10\r\n1100100100\r\n",
                "31\r\n"
            ],
            [
                "1\r\n100\r\n1001000100100100100100010010010001000010010010100010010000100100101001000010010010010000110001100100\r\n",
                "3924\r\n"
            ]
        ]
    }
]