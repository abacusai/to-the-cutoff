[
    {
        "name": "Kirk and a Binary String (easy version)",
        "description": "The only difference between easy and hard versions is the length of the\nstring. You can hack this problem only if you solve both problems. Kirk has a\nbinary string \n    s\n (a string which consists of zeroes and ones) of length\n\n    n\n and he is asking you to find a binary string \n    t\n of the same\nlength which satisfies the following conditions: For any \n    l\n and \n    r\n\n(\n    1 \n    \u2264 l \n    \u2264 r \n    \u2264 n\n) the length of the longest non-decreasing\nsubsequence of the substring \n    s_ls_l+1\n    \u2026 s_r\n is equal to the\nlength of the longest non-decreasing subsequence of the substring\n\n    t_lt_l+1\n    \u2026 t_r\n; The number of zeroes in \n    t\n is the\nmaximum possible.A non-decreasing subsequence of a string \n    p\n is a\nsequence of indices \n    i_1, i_2, \n    \u2026, i_k\n such that \n    i_1 < i_2 <\n    \n    \u2026 < i_k\n and \n    p_i_1\n    \u2264 p_i_2\n    \u2264\n    \u2026\n    \u2264\n    p_i_k\n. The length of the subsequence is \n    k\n. If there are multiple\nsubstrings which satisfy the conditions, output any. Input The first line\ncontains a binary string of length not more than \n    2\n      000\n. Output\nOutput a binary string which satisfied the above conditions. If there are many\nsuch strings, output any of them. Examples Input 110 Output 010 Input 010\nOutput 010 Input 0001111 Output 0000000 Input 0111001100111011101000 Output\n0011001100001011101000 Note In the first example: For the substrings of the\nlength \n    1\n the length of the longest non-decreasing subsequnce is \n    1\n;\nFor \n    l = 1, r = 2\n the longest non-decreasing subsequnce of the substring\n\n    s_1s_2\n is \n    11\n and the longest non-decreasing subsequnce of the\nsubstring \n    t_1t_2\n is \n    01\n; For \n    l = 1, r = 3\n the longest\nnon-decreasing subsequnce of the substring \n    s_1s_3\n is \n    11\n and\nthe longest non-decreasing subsequnce of the substring \n    t_1t_3\n is\n\n    00\n; For \n    l = 2, r = 3\n the longest non-decreasing subsequnce of the\nsubstring \n    s_2s_3\n is \n    1\n and the longest non-decreasing\nsubsequnce of the substring \n    t_2t_3\n is \n    1\n; The second example is\nsimilar to the first one.\n\n",
        "cf_contest_id": 1204,
        "cf_index": "D1",
        "cf_rating": 2000,
        "difficulty": 0,
        "cf_tags": [
            "brute force",
            "greedy",
            "strings"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "110\r\n",
                "010\n"
            ],
            [
                "010\r\n",
                "010\n"
            ],
            [
                "0001111\r\n",
                "0000000\n"
            ],
            [
                "0111001100111011101000\r\n",
                "0011001100001011101000\n"
            ]
        ],
        "private_cases": [
            [
                "0\r\n",
                "0\n"
            ],
            [
                "1\r\n",
                "0\n"
            ],
            [
                "0000000000000000\r\n",
                "0000000000000000\n"
            ],
            [
                "0100000001000001\r\n",
                "0100000001000000\n"
            ],
            [
                "0000100010001110\r\n",
                "0000100010000010\n"
            ],
            [
                "1001101000001101\r\n",
                "1001101000000100\n"
            ],
            [
                "0010000110000100\r\n",
                "0010000110000100\n"
            ],
            [
                "1111101000110110\r\n",
                "0011101000010010\n"
            ],
            [
                "1111111111111010\r\n",
                "0000000000001010\n"
            ],
            [
                "1111111111111111\r\n",
                "0000000000000000\n"
            ]
        ]
    }
]