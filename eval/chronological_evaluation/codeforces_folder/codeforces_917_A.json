[
    {
        "name": "The Monster",
        "description": "As Will is stuck in the Upside Down, he can still communicate with his mom,\nJoyce, through the Christmas lights (he can turn them on and off with his\nmind). He can't directly tell his mom where he is, because the monster that\ntook him to the Upside Down will know and relocate him. Thus, he came up with\na puzzle to tell his mom his coordinates. His coordinates are the answer to\nthe following problem. A string consisting only of parentheses ('(' and ')')\nis called a bracket sequence. Some bracket sequence are called correct bracket\nsequences. More formally: Empty string is a correct bracket sequence. if s is\na correct bracket sequence, then (s) is also a correct bracket sequence. if s\nand t are correct bracket sequences, then st (concatenation of s and t) is\nalso a correct bracket sequence. A string consisting of parentheses and\nquestion marks ('?') is called pretty if and only if there's a way to replace\neach question mark with either '(' or ')' such that the resulting string is a\nnon-empty correct bracket sequence. Will gave his mom a string s consisting of\nparentheses and question marks (using Morse code through the lights) and his\ncoordinates are the number of pairs of integers (l, r) such that 1 \u2264 l \u2264 r \u2264\n|s| and the string slsl + 1... sr is pretty, where si is i-th character of s.\nJoyce doesn't know anything about bracket sequences, so she asked for your\nhelp. Input The first and only line of input contains string s, consisting\nonly of characters '(', ')' and '?' (2 \u2264 |s| \u2264 5000). Output Print the answer\nto Will's puzzle in the first and only line of output. Examples Input ((?))\nOutput 4 Input ??()?? Output 7 Note For the first sample testcase, the pretty\nsubstrings of s are: \"(?\" which can be transformed to \"()\". \"?)\" which can be\ntransformed to \"()\". \"((?)\" which can be transformed to \"(())\". \"(?))\" which\ncan be transformed to \"(())\". For the second sample testcase, the pretty\nsubstrings of s are: \"??\" which can be transformed to \"()\". \"()\". \"??()\" which\ncan be transformed to \"()()\". \"?()?\" which can be transformed to \"(())\". \"??\"\nwhich can be transformed to \"()\". \"()??\" which can be transformed to \"()()\".\n\"??()??\" which can be transformed to \"()()()\".\n\n",
        "cf_contest_id": 917,
        "cf_index": "A",
        "cf_rating": 1800,
        "difficulty": 0,
        "cf_tags": [
            "dp",
            "greedy",
            "implementation",
            "math"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "((?))\r\n",
                "4\r\n"
            ],
            [
                "??()??\r\n",
                "7\r\n"
            ]
        ],
        "private_cases": [
            [
                "?????)(???\r\n",
                "21\r\n"
            ],
            [
                "()()((?(()(((()()(())(((()((())))(()))(()(((((())))()))(((()()()))))))(((((()))))))))\r\n",
                "62\r\n"
            ],
            [
                "))((()(()((((()))())()())((())())(((()()(())))))((())()()(()()(())()))()()(()()()(((()(()(()(()))))(\r\n",
                "88\r\n"
            ],
            [
                "????????????????????????????????????????????????????????????????????????????????????????????????????\r\n",
                "2500\r\n"
            ],
            [
                ")(\r\n",
                "0\r\n"
            ],
            [
                "?(\r\n",
                "0\r\n"
            ],
            [
                "??\r\n",
                "1\r\n"
            ],
            [
                ")?(??((???????()?(?????????)??(????????((?)?????)????)??????(?????)?)?????)??????(??()??????)????????)?)()??????????????())????????(???)??)????????????????????(?????)??)???)??(???????????????)???)??)?\r\n",
                "8314\r\n"
            ],
            [
                "()\r\n",
                "1\r\n"
            ],
            [
                "(?\r\n",
                "1\r\n"
            ]
        ]
    }
]