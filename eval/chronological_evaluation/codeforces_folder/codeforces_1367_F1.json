[
    {
        "name": "Flying Sort (Easy Version)",
        "description": "This is an easy version of the problem. In this version, all numbers in the\ngiven array are distinct and the constraints on \n    n\n are less than in the\nhard version of the problem. You are given an array \n    a\n of \n    n\n\nintegers (there are no equals elements in the array). You can perform the\nfollowing operations on array elements: choose any index \n    i\n (\n    1 \n    \u2264 i\n    \n    \u2264 n\n) and move the element \n    a[i]\n to the begin of the array; choose\nany index \n    i\n (\n    1 \n    \u2264 i \n    \u2264 n\n) and move the element \n    a[i]\n to\nthe end of the array. For example, if \n    n = 5\n, \n    a = [4, 7, 2, 3, 9]\n,\nthen the following sequence of operations can be performed: after performing\nthe operation of the first type to the second element, the array \n    a\n will\nbecome \n    [7, 4, 2, 3, 9]\n; after performing the operation of the second\ntype to the second element, the array \n    a\n will become \n    [7, 2, 3, 9,\n    4]\n. You can perform operations of any type any number of times in any\norder. Find the minimum total number of operations of the first and second\ntype that will make the \n    a\n array sorted in non-decreasing order. In other\nwords, what is the minimum number of operations that must be performed so the\narray satisfies the inequalities \n    a[1] \n    \u2264 a[2] \n    \u2264\n    \u2026\n    \u2264\n    a[n]\n. Input The first line contains a single integer \n    t\n (\n    1 \n    \u2264 t\n    \n    \u2264 100\n) \u2014 the number of test cases in the test. Then \n    t\n test cases\nfollow. Each test case starts with a line containing an integer \n    n\n (\n    1\n    \n    \u2264 n \n    \u2264 3000\n) \u2014 length of the array \n    a\n. Then follow \n    n\n\nintegers \n    a_1, a_2, \n    \u2026, a_n\n (\n    0 \n    \u2264 a_i \n    \u2264 10^9\n) \u2014 an\narray that needs to be sorted by the given operations. All numbers in the\ngiven array are distinct. The sum of \n    n\n for all test cases in one test\ndoes not exceed \n    3000\n. Output For each test case output one integer \u2014 the\nminimum total number of operations of the first and second type, which will\nmake the array sorted in non-decreasing order. Example Input 4 5 4 7 2 3 9 5 3\n5 8 1 7 5 1 4 5 7 12 4 0 2 1 3 Output 2 2 0 2 Note In the first test case, you\nfirst need to move 3, and then 2 to the beginning of the array. Therefore, the\ndesired sequence of operations: \n    [4, 7, 2, 3, 9] \n    \u2192 [3, 4, 7, 2,\n    9] \n    \u2192 [2, 3, 4, 7, 9]\n. In the second test case, you need to move\nthe 1 to the beginning of the array, and the 8 \u2014 to the end. Therefore, the\ndesired sequence of operations: \n    [3, 5, 8, 1, 7] \n    \u2192 [1, 3, 5, 8,\n    7] \n    \u2192 [1, 3, 5, 7, 8]\n. In the third test case, the array is\nalready sorted.\n\n",
        "cf_contest_id": 1367,
        "cf_index": "F1",
        "cf_rating": 2100,
        "difficulty": 0,
        "cf_tags": [
            "dp",
            "greedy",
            "two pointers"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "4\r\n5\r\n4 7 2 3 9\r\n5\r\n3 5 8 1 7\r\n5\r\n1 4 5 7 12\r\n4\r\n0 2 1 3\r\n",
                "2\r\n2\r\n0\r\n2\r\n"
            ]
        ],
        "private_cases": []
    }
]