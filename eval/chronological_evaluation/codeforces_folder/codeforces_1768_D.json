[
    {
        "name": "Lucky Permutation",
        "description": "You are given a permutation\n    ^\n    \u2020\n \n    p\n of length \n    n\n. In one\noperation, you can choose two indices \n    1 \n    \u2264 i < j \n    \u2264 n\n and swap\n\n    p_i\n with \n    p_j\n. Find the minimum number of operations needed to have\nexactly one inversion\n    ^\n in the permutation. \n    ^\n    \u2020\n A\npermutation is an array consisting of \n    n\n distinct integers from \n    1\n\nto \n    n\n in arbitrary order. For example, \n    [2,3,1,5,4]\n is a\npermutation, but \n    [1,2,2]\n is not a permutation (\n    2\n appears twice in\nthe array), and \n    [1,3,4]\n is also not a permutation (\n    n=3\n but there\nis \n    4\n in the array). \n    ^\n The number of inversions of a\npermutation \n    p\n is the number of pairs of indices \n    (i, j)\n such that\n\n    1 \n    \u2264 i < j \n    \u2264 n\n and \n    p_i > p_j\n. Input The first line contains\na single integer \n    t\n (\n    1 \n    \u2264 t \n    \u2264 10^4\n) \u2014 the number of test\ncases. The description of test cases follows. The first line of each test case\ncontains a single integer \n    n\n (\n    2 \n    \u2264 n \n    \u2264 2 \n    \u00b7 10^5\n). The\nsecond line of each test case contains \n    n\n integers \n    p_1,p_2,\n    \u2026,\n    p_n\n (\n    1 \n    \u2264 p_i \n    \u2264 n\n). It is guaranteed that \n    p\n is a\npermutation. It is guaranteed that the sum of \n    n\n over all test cases does\nnot exceed \n    2 \n    \u00b7 10^5\n. Output For each test case output a single\ninteger \u2014 the minimum number of operations needed to have exactly one\ninversion in the permutation. It can be proven that an answer always exists.\nExample Input 4 2 2 1 2 1 2 4 3 4 1 2 4 2 4 3 1 Output 0 1 3 1 Note In the\nfirst test case, the permutation already satisfies the condition. In the\nsecond test case, you can perform the operation with \n    (i,j)=(1,2)\n, after\nthat the permutation will be \n    [2,1]\n which has exactly one inversion. In\nthe third test case, it is not possible to satisfy the condition with less\nthan \n    3\n operations. However, if we perform \n    3\n operations with\n\n    (i,j)\n being \n    (1,3)\n,\n    (2,4)\n, and \n    (3,4)\n in that order, the\nfinal permutation will be \n    [1, 2, 4, 3]\n which has exactly one inversion.\nIn the fourth test case, you can perform the operation with \n    (i,j)=(2,4)\n,\nafter that the permutation will be \n    [2,1,3,4]\n which has exactly one\ninversion.\n\n",
        "cf_contest_id": 1768,
        "cf_index": "D",
        "cf_rating": 1800,
        "difficulty": 0,
        "cf_tags": [
            "constructive algorithms",
            "dfs and similar",
            "graphs",
            "greedy"
        ],
        "time_limit_seconds": 1.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "4\r\n2\r\n2 1\r\n2\r\n1 2\r\n4\r\n3 4 1 2\r\n4\r\n2 4 3 1\r\n",
                "0\r\n1\r\n3\r\n1\r\n"
            ]
        ],
        "private_cases": [
            [
                "1\r\n10\r\n9 6 7 10 3 2 1 4 5 8\r\n",
                "8\r\n"
            ]
        ]
    }
]