[
    {
        "name": "Yuezheng Ling and Dynamic Tree",
        "description": "Yuezheng Ling gives Luo Tianyi a tree which has \n    n\n nodes, rooted at\n\n    1\n. Luo Tianyi will tell you that the parent of the \n    i\n-th node is\n\n    a_i\n (\n    1 \n    \u2264 a_i<i\n for \n    2 \n    \u2264 i \n    \u2264 n\n), and she will ask\nyou to perform \n    q\n queries of \n    2\n types: She'll give you three\nintegers \n    l\n, \n    r\n and \n    x\n (\n    2 \n    \u2264 l \n    \u2264 r \n    \u2264 n\n, \n    1\n    \n    \u2264 x \n    \u2264 10^5\n). You need to replace \n    a_i\n with\n\n    max(a_i-x,1)\n for all \n    i\n with \n    l \n    \u2264 i \n    \u2264 r\n. She'll\ngive you two integers \n    u\n, \n    v\n (\n    1 \n    \u2264 u, v \n    \u2264 n\n). You need\nto find the LCA of nodes \n    u\n and \n    v\n (their lowest common ancestor).\nInput The first line contains two integers \n    n\n and \n    q\n (\n    2\n    \u2264 n,q\n    \n    \u2264 10^5\n) \u2014 the number of nodes and the number of queries, respectively.\nThe second line contains \n    n-1\n integers \n    a_2, a_3,\n    \u2026, a_n\n (\n    1\n    \n    \u2264 a_i < i\n), where \n    a_i\n is the parent of the node \n    i\n. Next\n\n    q\n lines contain queries. For each query, the first integer of each line\nis \n    t\n (\n    t = 1\n or \n    2\n) \u2014 the type of the query. If \n    t = 1\n,\nthis represents the query of the first type. Then, three integers will follow:\n\n    l\n, \n    r\n, \n    x\n (\n    2 \n    \u2264 l \n    \u2264 r \n    \u2264 n\n, \n    1 \n    \u2264 x \n    \u2264\n    10^5\n), meaning that you have to replace \n    a_i\n with\n\n    max(a_i-x,1)\n for all \n    i\n with \n    l \n    \u2264 i \n    \u2264 r\n. If \n    t\n    = 2\n, this represents the query of the second type. Then, two integers will\nfollow: \n    u\n and \n    v\n (\n    1 \n    \u2264 u, v \n    \u2264 n\n), and you have to find\nthe LCA of \n    u\n and \n    v\n. It's guaranteed that there is at least one\nquery of the second type. Output For each query of the second type output\nanswer on a new line. Example Input 6 4 1 2 3 3 4 2 3 4 1 2 3 1 2 5 6 2 2 3\nOutput 3 3 1 Note The tree in example is shown below. After the query of the\nfirst type, the tree changes and is looking as shown below.\n\n",
        "cf_contest_id": 1491,
        "cf_index": "H",
        "cf_rating": 3400,
        "difficulty": 0,
        "cf_tags": [
            "data structures",
            "trees"
        ],
        "time_limit_seconds": 1.5,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "6 4\r\n1 2 3 3 4\r\n2 3 4\r\n1 2 3 1\r\n2 5 6\r\n2 2 3\r\n",
                "3\r\n3\r\n1\r\n"
            ]
        ],
        "private_cases": [
            [
                "10 10\r\n1 1 2 1 3 6 1 8 8\r\n1 4 5 1\r\n1 3 4 2\r\n2 2 8\r\n2 5 7\r\n1 5 7 5\r\n1 5 9 5\r\n2 5 8\r\n1 5 8 2\r\n1 2 7 4\r\n2 2 3\r\n",
                "1\r\n1\r\n1\r\n1\r\n"
            ],
            [
                "20 20\r\n1 1 2 2 5 4 2 5 2 4 10 3 2 12 13 6 4 13 13\r\n2 2 15\r\n2 1 10\r\n1 12 14 5\r\n1 4 16 2\r\n1 8 18 3\r\n1 7 9 1\r\n1 4 6 5\r\n2 9 18\r\n1 15 15 3\r\n1 13 19 5\r\n2 11 12\r\n1 12 15 4\r\n1 2 7 3\r\n2 8 15\r\n1 8 15 4\r\n2 11 19\r\n1 3 14 2\r\n1 17 17 4\r\n2 1 5\r\n1 4 11 5\r\n",
                "2\r\n1\r\n1\r\n1\r\n1\r\n1\r\n1\r\n"
            ],
            [
                "2 2\r\n1\r\n2 1 2\r\n2 2 2\r\n",
                "1\r\n2\r\n"
            ]
        ]
    }
]