[
    {
        "name": "Best Binary String",
        "description": "You are given a string \n    s\n consisting of the characters 0, 1 and/or ?.\nLet's call it a pattern. Let's say that the binary string (a string where each\ncharacter is either 0 or 1) matches the pattern if you can replace each\ncharacter ? with 0 or 1 (for each character, the choice is independent) so\nthat the strings become equal. For example, 0010 matches ?01?, but 010 doesn't\nmatch 1??, ??, or ????. Let's define the cost of the binary string as the\nminimum number of operations of the form \"reverse an arbitrary contiguous\nsubstring of the string\" required to sort the string in non-descending order.\nYou have to find a binary string with the minimum possible cost among those\nthat match the given pattern. If there are multiple answers, print any of\nthem. Input The first line contains a single integer \n    t\n (\n    1 \n    \u2264 t\n    \n    \u2264 3 \n    \u00b7 10^4\n) \u2014 the number of test cases. The first and only line\nof each test case contains the string \n    s\n (\n    1 \n    \u2264 |s| \n    \u2264 3 \n    \u00b7\n    10^5\n) consisting of characters 0, 1, and/or ?. The sum of the string\nlengths over all test cases does not exceed \n    3 \n    \u00b7 10^5\n. Output For\neach test case, print a binary string with the minimum possible cost among\nthose that match the given pattern. If there are multiple answers, print any\nof them. Example Input 4 ??01? 10100 1??10? 0?1?10?10 Output 00011 10100\n111101 011110010 Note In the first test case of the example, the cost of the\nresulting string is \n    0\n. In the second test case, the cost of the\nresulting string is \n    2\n: we can reverse the substring from the \n    1\n-st\ncharacter to the \n    5\n-th character, and we obtain the string 00101. Then we\nreverse the substring from the \n    3\n-rd to the \n    4\n-th character, and we\nobtain the string 00011, which is sorted in non-descending order.\n\n",
        "cf_contest_id": 1837,
        "cf_index": "C",
        "cf_rating": 1000,
        "difficulty": 0,
        "cf_tags": [
            "constructive algorithms",
            "greedy"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "4\r\n??01?\r\n10100\r\n1??10?\r\n0?1?10?10\r\n",
                "00011\r\n\r\n10100\r\n\r\n111100\r\n\r\n001110010\r\n\r\n"
            ]
        ],
        "private_cases": [
            [
                "2\r\n??01?\r\n10100\r\n",
                "00011\r\n\r\n10100\r\n\r\n"
            ]
        ]
    }
]