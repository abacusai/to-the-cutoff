[
    {
        "name": "AccurateLee",
        "description": "Lee was cleaning his house for the party when he found a messy string under\nthe carpets. Now he'd like to make it clean accurately and in a stylish way...\nThe string \n    s\n he found is a binary string of length \n    n\n (i. e. string\nconsists only of 0-s and 1-s). In one move he can choose two consecutive\ncharacters \n    s_i\n and \n    s_i+1\n, and if \n    s_i\n is 1 and \n    s_i +\n    1\n is 0, he can erase exactly one of them (he can choose which one to erase\nbut he can't erase both characters simultaneously). The string shrinks after\nerasing. Lee can make an arbitrary number of moves (possibly zero) and he'd\nlike to make the string \n    s\n as clean as possible. He thinks for two\ndifferent strings \n    x\n and \n    y\n, the shorter string is cleaner, and if\nthey are the same length, then the lexicographically smaller string is\ncleaner. Now you should answer \n    t\n test cases: for the \n    i\n-th test\ncase, print the cleanest possible string that Lee can get by doing some number\nof moves. Small reminder: if we have two strings \n    x\n and \n    y\n of the\nsame length then \n    x\n is lexicographically smaller than \n    y\n if there is\na position \n    i\n such that \n    x_1 = y_1\n, \n    x_2 = y_2\n,..., \n    x_i -\n    1 = y_i - 1\n and \n    x_i < y_i\n. Input The first line contains the\ninteger \n    t\n (\n    1 \n    \u2264 t \n    \u2264 10^4\n) \u2014 the number of test cases. Next\n\n    2t\n lines contain test cases \u2014 one per two lines. The first line of each\ntest case contains the integer \n    n\n (\n    1 \n    \u2264 n \n    \u2264 10^5\n) \u2014 the\nlength of the string \n    s\n. The second line contains the binary string\n\n    s\n. The string \n    s\n is a string of length \n    n\n which consists only\nof zeroes and ones. It's guaranteed that sum of \n    n\n over test cases\ndoesn't exceed \n    10^5\n. Output Print \n    t\n answers \u2014 one per test case.\nThe answer to the \n    i\n-th test case is the cleanest string Lee can get\nafter doing some number of moves (possibly zero). Example Input 5 10\n0001111111 4 0101 8 11001101 10 1110000000 1 1 Output 0001111111 001 01 0 1\nNote In the first test case, Lee can't perform any moves. In the second test\ncase, Lee should erase \n    s_2\n. In the third test case, Lee can make moves,\nfor example, in the following order: 11001101 \n    \u2192\n 1100101\n\n    \u2192\n 110101 \n    \u2192\n 10101 \n    \u2192\n 1101\n\n    \u2192\n 101 \n    \u2192\n 01.\n\n",
        "cf_contest_id": 1369,
        "cf_index": "B",
        "cf_rating": 1200,
        "difficulty": 0,
        "cf_tags": [
            "greedy",
            "implementation",
            "strings"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "5\r\n10\r\n0001111111\r\n4\r\n0101\r\n8\r\n11001101\r\n10\r\n1110000000\r\n1\r\n1\r\n",
                "0001111111\r\n\r\n001\r\n\r\n01\r\n\r\n0\r\n\r\n1\r\n\r\n"
            ]
        ],
        "private_cases": []
    }
]