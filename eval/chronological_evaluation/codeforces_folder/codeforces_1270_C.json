[
    {
        "name": "Make Good",
        "description": "Let's call an array \n    a_1, a_2, \n    \u2026, a_m\n of nonnegative integer\nnumbers good if \n    a_1 + a_2 + \n    \u2026 + a_m = 2\n    \u00b7(a_1 \n    \u2295 a_2\n    \n    \u2295\n    \u2026\n    \u2295 a_m)\n, where \n    \u2295\n denotes the bitwise\nXOR operation. For example, array \n    [1, 2, 3, 6]\n is good, as \n    1 + 2 + 3\n    + 6 = 12 = 2\n    \u00b7 6 = 2\n    \u00b7 (1\n    \u2295 2 \n    \u2295 3 \n    \u2295 6)\n. At\nthe same time, array \n    [1, 2, 1, 3]\n isn't good, as \n    1 + 2 + 1 + 3 = 7\n    \n    \u2260 2\n    \u00b7 1 = 2\n    \u00b7(1\n    \u2295 2 \n    \u2295 1 \n    \u2295 3)\n. You are\ngiven an array of length \n    n\n: \n    a_1, a_2, \n    \u2026, a_n\n. Append at most\n\n    3\n elements to it to make it good. Appended elements don't have to be\ndifferent. It can be shown that the solution always exists under the given\nconstraints. If there are different solutions, you are allowed to output any\nof them. Note that you don't have to minimize the number of added elements!.\nSo, if an array is good already you are allowed to not append elements. Input\nEach test contains multiple test cases. The first line contains the number of\ntest cases \n    t\n (\n    1 \n    \u2264 t \n    \u2264 10\n     000\n). The description of the\ntest cases follows. The first line of each test case contains a single integer\n\n    n\n \n    (1\n    \u2264 n \n    \u2264 10^5)\n \u2014 the size of the array. The second line\nof each test case contains \n    n\n integers \n    a_1, a_2, \n    \u2026, a_n\n\n(\n    0\n    \u2264 a_i \n    \u2264 10^9\n) \u2014 the elements of the array. It is guaranteed\nthat the sum of \n    n\n over all test cases does not exceed \n    10^5\n. Output\nFor each test case, output two lines. In the first line, output a single\ninteger \n    s\n (\n    0\n    \u2264 s\n    \u2264 3\n) \u2014 the number of elements you want to\nappend. In the second line, output \n    s\n integers \n    b_1, \n    \u2026, b_s\n\n(\n    0\n    \u2264 b_i \n    \u2264 10^18\n) \u2014 the elements you want to append to the\narray. If there are different solutions, you are allowed to output any of\nthem. Example Input 3 4 1 2 3 6 1 8 2 1 1 Output 0 2 4 4 3 2 6 2 Note In the\nfirst test case of the example, the sum of all numbers is \n    12\n, and their\n\n    \u2295\n is \n    6\n, so the condition is already satisfied. In the\nsecond test case of the example, after adding \n    4, 4\n, the array becomes\n\n    [8, 4, 4]\n. The sum of numbers in it is \n    16\n, \n    \u2295\n of\nnumbers in it is \n    8\n.\n\n",
        "cf_contest_id": 1270,
        "cf_index": "C",
        "cf_rating": 1400,
        "difficulty": 0,
        "cf_tags": [
            "bitmasks",
            "constructive algorithms",
            "math"
        ],
        "time_limit_seconds": 2.0,
        "memory_limit_bytes": 256.0,
        "public_cases": [
            [
                "3\r\n4\r\n1 2 3 6\r\n1\r\n8\r\n2\r\n1 1\r\n",
                "2 \r\n 6 18\r\n2 \r\n 8 16\r\n2 \r\n 0 2\r\n"
            ]
        ],
        "private_cases": []
    }
]